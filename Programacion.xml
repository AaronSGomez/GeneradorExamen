<documento>
  <pregunta>
    <enunciado>
      ¿Qué clase se utiliza para leer datos desde consola?
    </enunciado>
    <A>
      InputReader
    </A>
    <B>
      Scanner
    </B>
    <C>
      ConsoleReader
    </C>
    <D>
      BufferReader
    </D>
    <respuesta_correcta explicacion="Scanner es la clase comúnmente usada para leer datos desde consola en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase en Java se utiliza para recibir entrada de datos desde la consola?
    </enunciado>
    <A>
      System.out
    </A>
    <B>
      BufferedReader
    </B>
    <C>
      Scanner
    </C>
    <D>
      JOptionPane
    </D>
    <respuesta_correcta explicacion="`Scanner` es la clase más común para leer datos desde la consola. Se usa junto con `System.in`, por ejemplo: `Scanner sc = new Scanner(System.in);`">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cómo se declara un array en Java?
    </enunciado>
    <A>
      array[] nombre = new array[10];
    </A>
    <B>
      int[] nombre = new int[10];
    </B>
    <C>
      int nombre[10];
    </C>
    <D>
      new int array[10];
    </D>
    <respuesta_correcta explicacion="La forma correcta de declarar un array en Java es `int[] nombre = new int[10];`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor tiene vector.length si declaramos int[] vector = new int[5];?
    </enunciado>
    <A>
      4
    </A>
    <B>
      5
    </B>
    <C>
      Depende de los valores almacenados
    </C>
    <D>
      No es posible conocerlo
    </D>
    <respuesta_correcta explicacion="El atributo `length` de un array devuelve la cantidad de elementos que puede almacenar, en este caso 5.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de la clase Arrays se usa para ordenar un array en Java?
    </enunciado>
    <A>
      sort()
    </A>
    <B>
      order()
    </B>
    <C>
      arrange()
    </C>
    <D>
      compare()
    </D>
    <respuesta_correcta explicacion="El método `Arrays.sort()` se utiliza para ordenar un array en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de la clase String permite extraer una subcadena?
    </enunciado>
    <A>
      extract()
    </A>
    <B>
      substring()
    </B>
    <C>
      cut()
    </C>
    <D>
      trim()
    </D>
    <respuesta_correcta explicacion="El método `substring()` permite extraer una subcadena de un objeto String.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué devuelve el método compareTo() de la clase String?
    </enunciado>
    <A>
      true si los Strings son iguales
    </A>
    <B>
      Un número positivo, negativo o 0, dependiendo del orden lexicográfico
    </B>
    <C>
      Siempre un número positivo
    </C>
    <D>
      Siempre un número negativo
    </D>
    <respuesta_correcta explicacion="El método `compareTo()` devuelve un número que indica el orden lexicográfico entre dos cadenas.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué diferencia hay entre equals() y == en la comparación de Strings?
    </enunciado>
    <A>
      == compara referencias y equals() el contenido
    </A>
    <B>
      equals() compara referencias y == compara contenido
    </B>
    <C>
      Ambos hacen lo mismo
    </C>
    <D>
      Ninguna
    </D>
    <respuesta_correcta explicacion="`==` compara referencias en memoria, mientras que `equals()` compara el contenido de los Strings.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre métodos sobrecargados es correcta?
    </enunciado>
    <A>
      Deben tener el mismo nombre y mismos parámetros
    </A>
    <B>
      Pueden tener el mismo nombre con diferentes parámetros
    </B>
    <C>
      No pueden tener más de dos versiones
    </C>
    <D>
      Son iguales a los métodos estáticos
    </D>
    <respuesta_correcta explicacion="Los métodos sobrecargados tienen el mismo nombre pero diferentes listas de parámetros (número o tipo).">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de acceso permite que un método sea usado solo dentro de la misma clase?
    </enunciado>
    <A>
      public
    </A>
    <B>
      private
    </B>
    <C>
      protected
    </C>
    <D>
      static
    </D>
    <respuesta_correcta explicacion="El modificador `private` restringe el acceso a los métodos o atributos solo dentro de la misma clase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál será la salida del siguiente código?
                    public class Test{
                        public static void main (String [] args){
                            int i = 0;
                            while (i &lt; 3){
                                System.out.println(i + " ");
                                i++;
                            }
                        }
                    }
    </enunciado>
    <A>
      0 1 2
    </A>
    <B>
      1 2 3
    </B>
    <C>
      0 1 2 3
    </C>
    <D>
      No compila
    </D>
    <respuesta_correcta explicacion="El código imprime 0 1 2 porque el bucle while incrementa i desde 0 hasta 2, deteniéndose cuando i es igual a 3.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la estructura correcta para declarar una matriz 3x3 en Java?
    </enunciado>
    <A>
      int[][] matriz = new int(3,3);
    </A>
    <B>
      int matriz[][] = new int[3][3];
    </B>
    <C>
      matriz = int[3,3];
    </C>
    <D>
      new int matriz[3][3];
    </D>
    <respuesta_correcta explicacion="La forma correcta de declarar una matriz en Java es `int matriz[][] = new int[3][3];`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de la clase Arrays se usa para copiar un array en otro?
    </enunciado>
    <A>
      copy()
    </A>
    <B>
      arraycopy()
    </B>
    <C>
      clone()
    </C>
    <D>
      copyArray()
    </D>
    <respuesta_correcta explicacion="El método `System.arraycopy()` se utiliza para copiar elementos de un array a otro.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué devuelve el método length de un array?
    </enunciado>
    <A>
      La cantidad de elementos
    </A>
    <B>
      El tamaño en bytes
    </B>
    <C>
      Siempre devuelve 0
    </C>
    <D>
      La cantidad de elementos no inicializados
    </D>
    <respuesta_correcta explicacion="El método `length` devuelve la cantidad total de elementos que puede almacenar el array.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre métodos sobrecargados es correcta?
    </enunciado>
    <A>
      Deben tener el mismo nombre y mismos parámetros
    </A>
    <B>
      Pueden tener el mismo nombre con diferentes parámetros
    </B>
    <C>
      No pueden tener más de dos versiones
    </C>
    <D>
      Son iguales a los métodos estáticos
    </D>
    <respuesta_correcta explicacion="Los métodos sobrecargados tienen el mismo nombre pero diferentes listas de parámetros (número o tipo).">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de acceso permite que un método sea usado solo dentro de la misma clase?
    </enunciado>
    <A>
      public
    </A>
    <B>
      private
    </B>
    <C>
      protected
    </C>
    <D>
      static
    </D>
    <respuesta_correcta explicacion="El modificador `private` restringe el acceso a los métodos o atributos solo dentro de la misma clase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál será la salida del siguiente código?

            public class Test {
                public static void main(String args[]) {
                    int x = 5;
                    if (x &gt; 2) {
                        if (x &lt; 10) {
                            System.out.println("A");
                        } else {
                            System.out.println("B");
                        }
                    }
                }
            }
    </enunciado>
    <A>
      A
    </A>
    <B>
      B
    </B>
    <C>
      A B
    </C>
    <D>
      No imprime nada
    </D>
    <respuesta_correcta explicacion="El valor de `x` es 5. La primera condición `x &gt; 2` es verdadera, y dentro de ella la segunda condición `x &lt; 10` también es verdadera, por lo que se imprime solo &quot;A&quot;.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la diferencia entre while y do-while?
    </enunciado>
    <A>
      while evalúa la condición al final del bucle, do-while al inicio
    </A>
    <B>
      do-while evalúa la condición al final, mientras que while la evalúa antes de entrar en el bucle
    </B>
    <C>
      Ambos funcionan de la misma manera
    </C>
    <D>
      Ninguna de las anteriores
    </D>
    <respuesta_correcta explicacion="En un bucle `while`, la condición se evalúa antes de ejecutar el bloque de código, mientras que en un bucle `do-while`, la condición se evalúa después, garantizando que el bloque se ejecute al menos una vez.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En la estructura switch, ¿qué sucede si no se incluye la sentencia break en cada case?
    </enunciado>
    <A>
      El programa lanza un error
    </A>
    <B>
      Se ejecuta únicamente la primera opción válida
    </B>
    <C>
      Se ejecutan todos los case hasta encontrar un break o finalizar el switch
    </C>
    <D>
      No se ejecuta ningún case
    </D>
    <respuesta_correcta explicacion="Si no se incluye un `break`, el programa ejecutará todos los casos consecutivos después de encontrar un caso válido, hasta encontrar un `break` o finalizar el bloque `switch`.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes estructuras de control permite iteraciones?
    </enunciado>
    <A>
      if
    </A>
    <B>
      switch
    </B>
    <C>
      while
    </C>
    <D>
      try-catch
    </D>
    <respuesta_correcta explicacion="La estructura `while` permite iteraciones, ya que repite un bloque de código mientras se cumpla una condición. Las demás estructuras no están diseñadas para iterar.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes estructuras de control se utiliza para tomar decisiones en un programa Java?
    </enunciado>
    <A>
      for
    </A>
    <B>
      while
    </B>
    <C>
      if-else
    </C>
    <D>
      do-while
    </D>
    <respuesta_correcta explicacion="`if-else` es la estructura condicional que permite tomar decisiones según se cumpla o no una condición. Las otras son estructuras de repetición.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se utiliza para declarar una constante en Java?
    </enunciado>
    <A>
      const
    </A>
    <B>
      final
    </B>
    <C>
      static
    </C>
    <D>
      constant
    </D>
    <respuesta_correcta explicacion="La palabra 'final' se utiliza para declarar constantes en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el tipo de datos para números enteros más pequeño en Java?
    </enunciado>
    <A>
      byte
    </A>
    <B>
      short
    </B>
    <C>
      int
    </C>
    <D>
      long
    </D>
    <respuesta_correcta explicacion="El tipo 'byte' usa solo 1 byte de memoria y va de -128 a 127.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la diferencia entre break y continue en un bucle?
    </enunciado>
    <A>
      break detiene la ejecución del bucle y continue solo salta una iteración
    </A>
    <B>
      continue finaliza el programa y break reinicia el bucle
    </B>
    <C>
      Ambos finalizan el bucle inmediatamente
    </C>
    <D>
      No hay diferencia
    </D>
    <respuesta_correcta explicacion="`break` detiene completamente la ejecución del bucle, mientras que `continue` salta la iteración actual y pasa a la siguiente.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el valor predeterminado de un boolean en Java?
    </enunciado>
    <A>
      true
    </A>
    <B>
      null
    </B>
    <C>
      false
    </C>
    <D>
      0
    </D>
    <respuesta_correcta explicacion="En Java, las variables boolean por defecto se inicializan como false.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es la herencia en Java?
    </enunciado>
    <A>
      Permite a una clase heredar métodos y atributos.
    </A>
    <B>
      Se usa con la palabra clave implements.
    </B>
    <C>
      Solo se puede heredar de interfaces.
    </C>
    <D>
      Permite crear nuevas clases basadas en otras.
    </D>
    <respuesta_correcta explicacion="La herencia permite que una clase (subclase) herede métodos y atributos de otra clase (superclase), promoviendo la reutilización de código.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se usa para heredar de una clase?
    </enunciado>
    <A>
      this
    </A>
    <B>
      implements
    </B>
    <C>
      extends
    </C>
    <D>
      inherit
    </D>
    <respuesta_correcta explicacion="La palabra clave `extends` se utiliza para heredar de una clase base en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se puede heredar de una superclase?
    </enunciado>
    <A>
      Atributos públicos
    </A>
    <B>
      Atributos privados
    </B>
    <C>
      Métodos públicos
    </C>
    <D>
      Todo, haciendo uso de super.
    </D>
    <respuesta_correcta explicacion="Se pueden heredar atributos y métodos públicos y protegidos, pero no los privados. `super` permite acceder a los miembros heredados.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué se utiliza principalmente la palabra clave `super` en Java?
    </enunciado>
    <A>
      Para acceder a métodos y atributos de la superclase.
    </A>
    <B>
      Para heredar una clase.
    </B>
    <C>
      Para declarar una clase como abstracta.
    </C>
    <D>
      Para evitar la sobrecarga de métodos.
    </D>
    <respuesta_correcta explicacion="La palabra clave `super` se usa principalmente para acceder a métodos y atributos de la superclase desde una subclase, y también para invocar explícitamente el constructor de la superclase.  &#xA;    La opción b es incorrecta porque la herencia en Java se establece con la palabra clave `extends`, no `super`.  &#xA;    La opción c es incorrecta porque para declarar una clase abstracta se usa la palabra clave `abstract`.  &#xA;    La opción d es incorrecta porque la sobrecarga de métodos no se controla ni se evita usando `super`; la sobrecarga ocurre cuando hay varios métodos con el mismo nombre pero diferentes parámetros.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es una característica fundamental de una clase abstracta en Java?
    </enunciado>
    <A>
      Siempre debe extender otra clase abstracta.
    </A>
    <B>
      No puede contener métodos concretos.
    </B>
    <C>
      No puede ser instanciada directamente.
    </C>
    <D>
      Solo puede declararse en interfaces.
    </D>
    <respuesta_correcta explicacion="La característica fundamental de una clase abstracta es que no puede ser instanciada directamente.  &#xA;    La opción a es incorrecta porque una clase abstracta no está obligada a extender otra clase abstracta; puede existir por sí sola.  &#xA;    La opción b es incorrecta porque una clase abstracta puede contener tanto métodos abstractos (sin implementar) como métodos concretos (implementados).  &#xA;    La opción d es incorrecta porque las clases abstractas se declaran como clases normales, no dentro de interfaces (aunque una interfaz puede tener clases internas estáticas).">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué operador se utiliza para comparar igualdad en Java?
    </enunciado>
    <A>
      =
    </A>
    <B>
      ==
    </B>
    <C>
      equals
    </C>
    <D>
      !=
    </D>
    <respuesta_correcta explicacion="'==' se usa para comparar valores primitivos. Para objetos, se recomienda usar equals().">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes no es una palabra reservada en Java?
    </enunciado>
    <A>
      static
    </A>
    <B>
      try
    </B>
    <C>
      new
    </C>
    <D>
      define
    </D>
    <respuesta_correcta explicacion="'define' no es una palabra reservada en Java, aunque lo es en otros lenguajes como C.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se utiliza para leer datos desde consola?
    </enunciado>
    <A>
      InputReader
    </A>
    <B>
      Scanner
    </B>
    <C>
      ConsoleReader
    </C>
    <D>
      BufferReader
    </D>
    <respuesta_correcta explicacion="Scanner es la clase comúnmente usada para leer datos desde consola en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes estructuras es una clase contenedora?
    </enunciado>
    <A>
      Array
    </A>
    <B>
      List
    </B>
    <C>
      int
    </C>
    <D>
      char
    </D>
    <respuesta_correcta explicacion="List es una interfaz de colección que representa una lista ordenada de elementos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida de System.out.println(3 + "4")?
    </enunciado>
    <A>
      7
    </A>
    <B>
      34
    </B>
    <C>
      Error
    </C>
    <D>
      "7"
    </D>
    <respuesta_correcta explicacion="Se concatena 3 con el String &quot;4&quot;, dando como resultado &quot;34&quot;.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué significa que Java sea un lenguaje fuertemente tipado?
    </enunciado>
    <A>
      Que se puede cambiar el tipo de una variable libremente.
    </A>
    <B>
      Que se deben declarar todos los tipos de datos.
    </B>
    <C>
      Que es sensible a mayúsculas.
    </C>
    <D>
      Que no se pueden usar tipos primitivos.
    </D>
    <respuesta_correcta explicacion="En Java todos los tipos deben ser declarados explícitamente y no se permite el cambio de tipo implícito en la mayoría de los casos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Los operadores lógicos operan con valores booleanos, resultando:
    </enunciado>
    <A>
      Valores enteros.
    </A>
    <B>
      Valores enteros y booleanos.
    </B>
    <C>
      Otros tipos de valores.
    </C>
    <D>
      Solo valores booleanos.
    </D>
    <respuesta_correcta explicacion="Los operadores lógicos trabajan únicamente con valores booleanos (true o false).">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La evaluación de una expresión relacional puede generar un valor de tipo:
    </enunciado>
    <A>
      Entero
    </A>
    <B>
      Real
    </B>
    <C>
      Booleano
    </C>
    <D>
      Todos los anteriores
    </D>
    <respuesta_correcta explicacion="Las expresiones relacionales devuelven un valor booleano (true o false).">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La expresión 3==3 &amp;&amp; 2&lt;3 &amp;&amp; 1!=2 resulta:
    </enunciado>
    <A>
      Cierto
    </A>
    <B>
      Falso
    </B>
    <C>
      No se puede evaluar
    </C>
    <D>
      No genera un booleano, ya que la expresión es aritmética
    </D>
    <respuesta_correcta explicacion="Todas las comparaciones son verdaderas, por tanto el resultado es true (cierto).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La siguiente expresión, donde interviene la variable booleana a: 3!=3 || a || 1&lt;2, resulta:
    </enunciado>
    <A>
      Dependerá del valor de a
    </A>
    <B>
      Cierto
    </B>
    <C>
      Falso
    </C>
    <D>
      No se puede evaluar
    </D>
    <respuesta_correcta explicacion="Aunque `3!=3` es falso, la última parte `1&lt;2` es verdadera, por lo que toda la expresión resulta verdadera debido al operador `||` (OR lógico), sin importar el valor de `a`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Elige los valores de las variables enteras (a, b y c) que permiten que la evaluación de la siguiente expresión sea cierta: a&lt;b &amp;&amp; b!=c &amp;&amp; b&lt;=c:
    </enunciado>
    <A>
      a = 1, b = 1, c = 2
    </A>
    <B>
      a = 2, b = 1, c = 2
    </B>
    <C>
      a = 1, b = 2, c = 2
    </C>
    <D>
      a = 1, b = 2, c = 3
    </D>
    <respuesta_correcta explicacion="1&lt;2 (true), 2!=3 (true), 2&lt;=3 (true). Esta es la única opción que cumple todas las condiciones.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El bloque de instrucciones de una sentencia if se ejecutará:
    </enunciado>
    <A>
      Siempre
    </A>
    <B>
      Nunca
    </B>
    <C>
      Dependerá de la evaluación de la expresión utilizada
    </C>
    <D>
      Todas las respuestas anteriores son correctas
    </D>
    <respuesta_correcta explicacion="Solo se ejecuta si la condición del if se evalúa como true.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En una sentencia if-else los bloques de instrucciones (bloque true y bloque false) pueden ejecutarse:
    </enunciado>
    <A>
      Simultáneamente
    </A>
    <B>
      Es posible, dependiendo de la condición utilizada, que no se ejecute ninguno
    </B>
    <C>
      Siempre se ejecutará al menos uno y son excluyentes
    </C>
    <D>
      Todas las anteriores son incorrectas
    </D>
    <respuesta_correcta explicacion="En un if-else siempre se ejecuta uno de los dos bloques, pero nunca ambos.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor toma la variable `a` en la siguiente expresión: a = 1 &lt; 2?
    </enunciado>
    <A>
      0
    </A>
    <B>
      1
    </B>
    <C>
      true
    </C>
    <D>
      false
    </D>
    <respuesta_correcta explicacion="La expresión `1 &lt; 2` evalúa a `true` en Java, por lo que la variable `a` tomará el valor `true` si es de tipo boolean.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La cláusula default en la sentencia switch es:
    </enunciado>
    <A>
      Obligatoria y tiene que ser la última que aparezca
    </A>
    <B>
      Obligatoria, pero puede aparecer en cualquier lugar
    </B>
    <C>
      Opcional y tiene que ser la última que aparezca
    </C>
    <D>
      Opcional y puede usarse en cualquier lugar
    </D>
    <respuesta_correcta explicacion="default es opcional y puede colocarse en cualquier lugar del switch.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Realiza una traza del siguiente fragmento de código y selecciona el valor que toma finalmente la variable a:
            a = 0;
            switch (a + 1) {
            case 0:
            a = 2;
            case 1:
            a = 3;
            case 2:
            a++;
            break;
            case 3:
            a--;
            break;
            }
    </enunciado>
    <A>
      a = 2.
    </A>
    <B>
      a= 3.
    </B>
    <C>
      a = null;
    </C>
    <D>
      a = 4;
    </D>
    <respuesta_correcta explicacion="El valor inicial de `a` es 0. Se evalúa `switch(1)`, entrando en el `case 1`, donde `a = 3`. No hay `break`, así que continúa al `case 2`, donde se hace `a++` (pasa de 3 a 4), y finalmente rompe el bucle. Resultado final: a = 4.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es una clase en Java?
    </enunciado>
    <A>
      Un objeto instanciado.
    </A>
    <B>
      Un molde o plantilla para crear objetos.
    </B>
    <C>
      Un tipo de método especial.
    </C>
    <D>
      Una interfaz que define métodos.
    </D>
    <respuesta_correcta explicacion="Una clase es un molde o plantilla que define las propiedades y comportamientos de los objetos que se crean a partir de ella.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué significa encapsulación?
    </enunciado>
    <A>
      Ocultar detalles internos de la implementación.
    </A>
    <B>
      Permitir acceso público a todos los métodos.
    </B>
    <C>
      Dividir una clase en varias subclases.
    </C>
    <D>
      Ejecutar múltiples tareas simultáneamente.
    </D>
    <respuesta_correcta explicacion="La encapsulación consiste en ocultar los detalles internos de una clase y exponer solo lo necesario a través de métodos públicos, mejorando la modularidad y seguridad del código.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se usa para crear objetos?
    </enunciado>
    <A>
      class
    </A>
    <B>
      object
    </B>
    <C>
      new
    </C>
    <D>
      static
    </D>
    <respuesta_correcta explicacion="La palabra clave `new` se utiliza para instanciar un objeto en Java, invocando su constructor.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es un atributo de una clase?
    </enunciado>
    <A>
      Una función que realiza operaciones.
    </A>
    <B>
      Un método estático.
    </B>
    <C>
      Una variable que representa el estado de un objeto.
    </C>
    <D>
      Un objeto contenido dentro de otro objeto.
    </D>
    <respuesta_correcta explicacion="Un atributo es una variable que almacena información sobre el estado de un objeto.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace la palabra clave this en Java?
    </enunciado>
    <A>
      Hace referencia a la clase padre.
    </A>
    <B>
      Hace referencia al objeto actual.
    </B>
    <C>
      Permite importar paquetes.
    </C>
    <D>
      Es obligatoria al acceder a variables privadas.
    </D>
    <respuesta_correcta explicacion="La palabra clave `this` se utiliza para referirse al objeto actual dentro de un método o constructor.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirve la interfaz `List` en Java?
    </enunciado>
    <A>
      Permite almacenar elementos ordenados y duplicados.
    </A>
    <B>
      No permite almacenar elementos duplicados.
    </B>
    <C>
      Solo puede almacenar tipos primitivos.
    </C>
    <D>
      No mantiene ningún orden en los elementos.
    </D>
    <respuesta_correcta explicacion="La interfaz `List` permite almacenar una colección ordenada de elementos, donde se pueden incluir duplicados.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede si no se define un constructor en una clase?
    </enunciado>
    <A>
      Java genera uno por defecto (heredado de la clase Object).
    </A>
    <B>
      No se puede crear objetos de la clase.
    </B>
    <C>
      Se lanza un error en tiempo de ejecución.
    </C>
    <D>
      Solo se pueden crear objetos usando new.
    </D>
    <respuesta_correcta explicacion="Si no se define un constructor, Java genera uno por defecto que no realiza ninguna acción específica.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué métodos son conocidos como getters y setters?
    </enunciado>
    <A>
      Métodos que inicializan objetos.
    </A>
    <B>
      Métodos que acceden o modifican atributos.
    </B>
    <C>
      Métodos estáticos.
    </C>
    <D>
      Métodos que ejecutan código externo.
    </D>
    <respuesta_correcta explicacion="Los getters y setters son métodos que permiten acceder y modificar los atributos privados de una clase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué afirmaciones sobre objetos en Java son ciertas?
    </enunciado>
    <A>
      Los objetos pueden tener métodos y atributos.
    </A>
    <B>
      Los objetos no pueden contener otros objetos.
    </B>
    <C>
      Los objetos no pueden implementar interfaces.
    </C>
    <D>
      No se puede crear un objeto sin argumentos.
    </D>
    <respuesta_correcta explicacion="Los objetos en Java pueden tener métodos y atributos, y pueden contener otros objetos o implementar interfaces.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué significa encapsulación?
    </enunciado>
    <A>
      Ocultar detalles internos de la implementación.
    </A>
    <B>
      Permitir acceso público a todos los métodos.
    </B>
    <C>
      Dividir una clase en varias subclases.
    </C>
    <D>
      Ejecutar múltiples tareas simultáneamente
    </D>
    <respuesta_correcta explicacion="La encapsulación consiste en ocultar los detalles internos de una clase y exponer solo lo necesario a través de métodos públicos, mejorando la modularidad y seguridad del código.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es una clase en Java?
    </enunciado>
    <A>
      Un objeto instanciado.
    </A>
    <B>
      Un molde o plantilla para crear objetos.
    </B>
    <C>
      Un tipo de método especial.
    </C>
    <D>
      Una interfaz que define métodos.
    </D>
    <respuesta_correcta explicacion="Una clase es un molde o plantilla que define las propiedades y comportamientos de los objetos que se crean a partir de ella.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es un atributo de una clase?
    </enunciado>
    <A>
      Una función que realiza operaciones.
    </A>
    <B>
      Un método estático.
    </B>
    <C>
      Una variable que representa el estado de un objeto.
    </C>
    <D>
      Un objeto contenido dentro de otro objeto.
    </D>
    <respuesta_correcta explicacion="Un atributo es una variable que almacena información sobre el estado de un objeto.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace la palabra clave this en Java?
    </enunciado>
    <A>
      Hace referencia a la clase padre.
    </A>
    <B>
      Hace referencia al objeto actual.
    </B>
    <C>
      Permite importar paquetes.
    </C>
    <D>
      Es obligatoria al acceder a variables privadas.
    </D>
    <respuesta_correcta explicacion="La palabra clave `this` se utiliza para referirse al objeto actual dentro de un método o constructor.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es una característica del tipo `Set` en Java?
    </enunciado>
    <A>
      No permite elementos duplicados.
    </A>
    <B>
      Almacena los elementos en orden.
    </B>
    <C>
      Permite claves y valores.
    </C>
    <D>
      Solo puede almacenar cadenas.
    </D>
    <respuesta_correcta explicacion="Un `Set` en Java es una colección que no permite elementos duplicados y no garantiza un orden específico.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede si no se define un constructor en una clase?
    </enunciado>
    <A>
      Java genera uno por defecto (heredado de la clase Object).
    </A>
    <B>
      No se puede crear objetos de la clase.
    </B>
    <C>
      Se lanza un error en tiempo de ejecución.
    </C>
    <D>
      Solo se pueden crear objetos usando new.
    </D>
    <respuesta_correcta explicacion="Si no se define un constructor, Java genera uno por defecto que no realiza ninguna acción específica.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué métodos son conocidos como getters y setters?
    </enunciado>
    <A>
      Métodos que inicializan objetos.
    </A>
    <B>
      Métodos que acceden o modifican atributos.
    </B>
    <C>
      Métodos estáticos.
    </C>
    <D>
      Métodos que ejecutan código externo.
    </D>
    <respuesta_correcta explicacion="Los getters y setters son métodos que permiten acceder y modificar los atributos privados de una clase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué afirmaciones sobre objetos en Java son ciertas?
    </enunciado>
    <A>
      Los objetos pueden tener métodos y atributos.
    </A>
    <B>
      Los objetos no pueden contener otros objetos.
    </B>
    <C>
      Los objetos no pueden implementar interfaces.
    </C>
    <D>
      No se puede crear un objeto sin argumentos.
    </D>
    <respuesta_correcta explicacion="Los objetos en Java pueden tener métodos y atributos, y pueden contener otros objetos o implementar interfaces.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el operador lógico 'AND' en Java?
    </enunciado>
    <A>
      &amp;
    </A>
    <B>
      &amp;&amp;
    </B>
    <C>
      and
    </C>
    <D>
      ||
    </D>
    <respuesta_correcta explicacion="En Java '&amp;&amp;' es el operador lógico AND que evalúa condiciones booleanas.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué instrucción se usa para ejecutar código solo si una condición es verdadera?
    </enunciado>
    <A>
      while
    </A>
    <B>
      for
    </B>
    <C>
      if
    </C>
    <D>
      switch
    </D>
    <respuesta_correcta explicacion="'if' evalúa condiciones booleanas para decidir si ejecutar un bloque de código.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un bucle do-while se ejecutará, como mínimo:
    </enunciado>
    <A>
      Cero veces
    </A>
    <B>
      Una vez
    </B>
    <C>
      Infinitas veces
    </C>
    <D>
      Ninguna de las opciones anteriores es correcta
    </D>
    <respuesta_correcta explicacion="El bucle do-while ejecuta primero el bloque de código y luego evalúa la condición. Por tanto, se ejecuta al menos una vez.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El uso de llaves para encerrar el bloque de instrucciones de un bucle:
    </enunciado>
    <A>
      Es siempre opcional
    </A>
    <B>
      Es opcional si el bloque está formado por una única instrucción
    </B>
    <C>
      En cualquier caso, su uso es obligatorio
    </C>
    <D>
      El programador decide su uso
    </D>
    <respuesta_correcta explicacion="Si el bucle contiene solo una instrucción, las llaves son opcionales, aunque su uso es recomendable para claridad.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La instrucción que permite detener completamente las iteraciones de un bucle es:
    </enunciado>
    <A>
      stop
    </A>
    <B>
      break
    </B>
    <C>
      continue
    </C>
    <D>
      finish
    </D>
    <respuesta_correcta explicacion="La instrucción `break` finaliza inmediatamente la ejecución del bucle en curso.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En un bucle for, la inicialización, condición e incremento son:
    </enunciado>
    <A>
      Todos obligatorios
    </A>
    <B>
      Todos opcionales
    </B>
    <C>
      La inicialización siempre es obligatoria
    </C>
    <D>
      La condición siempre es obligatoria
    </D>
    <respuesta_correcta explicacion="Técnicamente, los tres componentes del bucle for son opcionales en Java, aunque se usan por claridad y control.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En el caso de que una función devuelva un valor, ¿cuál es la recomendación con respecto a la instrucción return?
    </enunciado>
    <A>
      Utilizar tantos como hagan falta
    </A>
    <B>
      Emplear tantos como hagan falta, pero siempre que se encuentren en bloques de instrucciones distintas
    </B>
    <C>
      Usar solo uno
    </C>
    <D>
      Utilizar solo uno, que será siempre la primera instrucción de la función
    </D>
    <respuesta_correcta explicacion="Usar un solo `return` mejora la legibilidad del código y facilita el mantenimiento y la depuración.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuáles de las siguientes operaciones se pueden implementar fácilmente mediante funciones recursivas?
    </enunciado>
    <A>
      an = a × an-1
    </A>
    <B>
      esPar(n) = esImpar(n − 1) y esImpar(n) = esPar(n − 1)
    </B>
    <C>
      suma(a, b) = suma(a + 1, b − 1)
    </C>
    <D>
      Todas las respuestas anteriores son correctas
    </D>
    <respuesta_correcta explicacion="Todas estas definiciones son recursivas y pueden implementarse eficazmente con funciones recursivas.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En los identificadores de las funciones, al igual que en los de las variables, se recomienda utilizar la siguiente nomenclatura:
    </enunciado>
    <A>
      suma_notas_alumnos()
    </A>
    <B>
      sumanotasalumnos()
    </B>
    <C>
      SumaNotasAlumnos()
    </C>
    <D>
      sumaNotasAlumnos()
    </D>
    <respuesta_correcta explicacion="La convención de Java para nombres de métodos es camelCase: se empieza en minúscula y cada palabra adicional inicia con mayúscula.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave define un método que no devuelve valor?
    </enunciado>
    <A>
      void
    </A>
    <B>
      null
    </B>
    <C>
      return
    </C>
    <D>
      static
    </D>
    <respuesta_correcta explicacion="'void' se utiliza para indicar que un método no retorna ningún valor.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cómo se llama un método dentro de una clase en Java?
    </enunciado>
    <A>
      función
    </A>
    <B>
      subrutina
    </B>
    <C>
      método
    </C>
    <D>
      operador
    </D>
    <respuesta_correcta explicacion="En Java, una función que está dentro de una clase se denomina 'método'.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Los parámetros en la llamada a una función en Java pueden ser opcionales si:
    </enunciado>
    <A>
      Todos los parámetros son del mismo tipo
    </A>
    <B>
      Todos los parámetros son de distinto tipo
    </B>
    <C>
      Nunca pueden ser opcionales
    </C>
    <D>
      Siempre que el tipo devuelto no sea void
    </D>
    <respuesta_correcta explicacion="En Java, no existen parámetros opcionales de forma directa. Hay que simularlo con sobrecarga de métodos.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una variable local (declarada dentro de una función) puede usarse:
    </enunciado>
    <A>
      En cualquier lugar del código
    </A>
    <B>
      Solo dentro de main()
    </B>
    <C>
      Solo en la función donde se ha declarado
    </C>
    <D>
      Ninguna de las opciones anteriores es correcta
    </D>
    <respuesta_correcta explicacion="Las variables locales solo existen dentro del bloque donde fueron declaradas.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El tipo devuelto de todas las funciones definidas en nuestro programa tiene que ser siempre:
    </enunciado>
    <A>
      int
    </A>
    <B>
      double
    </B>
    <C>
      void
    </C>
    <D>
      Ninguna de las opciones anteriores es correcta
    </D>
    <respuesta_correcta explicacion="El tipo de retorno puede ser cualquiera, no solo los mencionados. Incluso pueden devolver objetos o listas.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué instrucción permite a una función devolver un valor?
    </enunciado>
    <A>
      value
    </A>
    <B>
      return
    </B>
    <C>
      static
    </C>
    <D>
      function
    </D>
    <respuesta_correcta explicacion="'return' es la instrucción que se utiliza para devolver un valor desde una función.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La forma de distinguir entre dos o más funciones sobrecargadas es:
    </enunciado>
    <A>
      Mediante su nombre
    </A>
    <B>
      Mediante el tipo devuelto
    </B>
    <C>
      Mediante el nombre de sus parámetros
    </C>
    <D>
      Mediante su lista de parámetros: número o tipos
    </D>
    <respuesta_correcta explicacion="Java permite la sobrecarga si cambian el número o tipo de los parámetros, no el nombre ni el tipo de retorno.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la definición de una función recursiva?
    </enunciado>
    <A>
      Es aquella que se invoca desde dentro de su propio bloque de instrucciones
    </A>
    <B>
      Es aquella cuyo nombre permite la sobrecarga y además realiza alguna comprobación mediante if
    </B>
    <C>
      Es aquella cuyo bloque de instrucciones utiliza alguna sentencia if (lo que llamamos caso base)
    </C>
    <D>
      Es aquella que genera un bucle infinito
    </D>
    <respuesta_correcta explicacion="Una función recursiva es aquella que se llama a sí misma dentro de su propia definición.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El paso de parámetros a una función en Java es siempre:
    </enunciado>
    <A>
      Un paso de parámetros por copia
    </A>
    <B>
      Un paso de parámetros por desplazamiento
    </B>
    <C>
      Un paso de parámetros recursivo
    </C>
    <D>
      Un paso de parámetros funcional
    </D>
    <respuesta_correcta explicacion="En Java, los tipos primitivos se pasan por valor (copia). En objetos se pasa una copia de la referencia.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La comparación del contenido (los elementos) de dos tablas se realiza utilizando:
    </enunciado>
    <A>
      Arrays.compare()
    </A>
    <B>
      El operador ==
    </B>
    <C>
      Arrays.equals()
    </C>
    <D>
      Arrays.same()
    </D>
    <respuesta_correcta explicacion="El método `Arrays.equals()` compara el contenido de dos arrays elemento por elemento. El operador `==` compara referencias, no contenido.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué condición tiene que cumplir una tabla para que podamos realizar búsquedas dicotómicas en ella?
    </enunciado>
    <A>
      Que esté ordenada
    </A>
    <B>
      Que esté ordenada y sea una tabla de enteros
    </B>
    <C>
      Que no esté ordenada
    </C>
    <D>
      No importa si la tabla está ordenada, lo realmente importante es que sea de algún tipo numérico
    </D>
    <respuesta_correcta explicacion="La búsqueda binaria o dicotómica solo es válida si el array está previamente ordenado. No importa el tipo de datos.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la principal diferencia entre Arrays.copyOf() y System.arraycopy()?
    </enunciado>
    <A>
      No existe diferencia alguna, ambos métodos son idénticos
    </A>
    <B>
      Arrays.copyOf() copia mientras System.arraycopy() copia y compara
    </B>
    <C>
      Arrays.copyOf() copia entre tablas existentes mientras System.arraycopy() crea una nueva tabla y copia en ella
    </C>
    <D>
      Arrays.copyOf() crea una nueva tabla y copia en ella mientras System.arraycopy() solo copia entre tablas ya creadas
    </D>
    <respuesta_correcta explicacion="`Arrays.copyOf()` crea automáticamente un nuevo array y copia los elementos. `System.arraycopy()` copia entre arrays ya existentes.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cómo se declara un array de enteros en Java?
    </enunciado>
    <A>
      int array = new int[];
    </A>
    <B>
      int[] array;
    </B>
    <C>
      int array[] = {};
    </C>
    <D>
      array int = new array();
    </D>
    <respuesta_correcta explicacion="La forma correcta de declarar un array en Java es `int[] nombreArray;`, con el tipo seguido por corchetes.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una tabla puede almacenar datos de distintos tipos, como por ejemplo enteros, booleanos, reales, etcétera:
    </enunciado>
    <A>
      Cierto, las tablas siempre pueden almacenar datos de distintos tipos
    </A>
    <B>
      Falso, las tablas solo pueden almacenar datos de un único tipo
    </B>
    <C>
      Puede almacenar datos de distintos tipos siempre que estos sean numéricos
    </C>
    <D>
      Puede almacenar datos de distintos tipos siempre que la longitud de los datos sea idéntica
    </D>
    <respuesta_correcta explicacion="En Java, los arrays son homogéneos: todos los elementos deben ser del mismo tipo.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En Java, la numeración de los índices que determina la identificación de cada elemento de una tabla comienza en:
    </enunciado>
    <A>
      Cero
    </A>
    <B>
      Uno
    </B>
    <C>
      Depende del tipo de dato de la tabla
    </C>
    <D>
      Es configurable por el usuario
    </D>
    <respuesta_correcta explicacion="Los arrays en Java comienzan siempre en el índice 0.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si en una tabla de 10 elementos utilizamos el elemento con índice 11 (que se encuentra fuera de rango):
    </enunciado>
    <A>
      Al salir del rango de la longitud, Java redimensiona la tabla de forma automática
    </A>
    <B>
      No es posible y produce un error
    </B>
    <C>
      Las tablas tienen un comportamiento circular y utilizar el índice 11 es idéntico a utilizar el índice 1
    </C>
    <D>
      Ninguna de las anteriores respuestas es cierta
    </D>
    <respuesta_correcta explicacion="Acceder a un índice fuera del rango produce una excepción `ArrayIndexOutOfBoundsException`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de la clase Arrays permite realizar una búsqueda dicotómica en una tabla?
    </enunciado>
    <A>
      Arrays.search()
    </A>
    <B>
      Arrays.find()
    </B>
    <C>
      Arrays.binarySearch()
    </C>
    <D>
      Cualquiera de los métodos anteriores realiza una búsqueda
    </D>
    <respuesta_correcta explicacion="El método `Arrays.binarySearch()` realiza una búsqueda binaria, pero solo si el array está previamente ordenado.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Con respecto a las tablas, el operador new:
    </enunciado>
    <A>
      Destruye, crea y redimensiona tablas
    </A>
    <B>
      Destruye y crea tablas
    </B>
    <C>
      Crea tablas
    </C>
    <D>
      Destruye las tablas
    </D>
    <respuesta_correcta explicacion="El operador `new` se usa para crear nuevas instancias de arrays, no para destruir.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la forma correcta de sugerir la ejecución del recolector de basura en Java?
    </enunciado>
    <A>
      Mediante System.gc()
    </A>
    <B>
      Mediante el operador new
    </B>
    <C>
      Mediante Arrays.garbageCollector()
    </C>
    <D>
      No es posible sugerir al recolector de basura.
    </D>
    <respuesta_correcta explicacion="La forma correcta de sugerir la ejecución del recolector de basura en Java es usando `System.gc()`. Aunque esto solicita al sistema la recolección, no garantiza que ocurra inmediatamente.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La forma de conocer la longitud de una tabla t es mediante:
    </enunciado>
    <A>
      t.size
    </A>
    <B>
      t.elements
    </B>
    <C>
      t.length
    </C>
    <D>
      Arrays.size(t)
    </D>
    <respuesta_correcta explicacion="En Java, la propiedad `length` permite conocer el tamaño de un array.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el índice del primer elemento de un array en Java?
    </enunciado>
    <A>
      0
    </A>
    <B>
      1
    </B>
    <C>
      -1
    </C>
    <D>
      depende
    </D>
    <respuesta_correcta explicacion="Los arrays en Java siempre comienzan en el índice 0.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La forma de concatenar dos cadenas es mediante:
    </enunciado>
    <A>
      El operador +
    </A>
    <B>
      El operador +=
    </B>
    <C>
      El método concat()
    </C>
    <D>
      Todas permiten concatenar cadenas
    </D>
    <respuesta_correcta explicacion="En Java puedes concatenar cadenas usando `+`, `+=` o `concat()`; todas son válidas para unir Strings.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El método que permite eliminar los caracteres blancos del principio y el final de una cadena es:
    </enunciado>
    <A>
      isWhiteSpace()
    </A>
    <B>
      deleteWhiteSpace()
    </B>
    <C>
      strip()
    </C>
    <D>
      stripLeading()
    </D>
    <respuesta_correcta explicacion="`strip()` elimina los espacios en blanco al inicio y al final de la cadena, incluido soporte para Unicode.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Existe una relación entre las cadenas (clase String) y las tablas de caracteres (char[]). ¿Qué métodos permiten convertir un String en un char[]?
    </enunciado>
    <A>
      toCharArray()
    </A>
    <B>
      valueOf()
    </B>
    <C>
      convertString()
    </C>
    <D>
      empty()
    </D>
    <respuesta_correcta explicacion="`toCharArray()` convierte una cadena String en un array de caracteres (char[]).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En Java, al igual que en otros muchos lenguajes de programación, las secuencias de escape se escriben mediante:
    </enunciado>
    <A>
      Dos puntos (:)
    </A>
    <B>
      El carácter U mayúscula (U)
    </B>
    <C>
      El carácter u minúscula (u)
    </C>
    <D>
      Una barra invertida (\)
    </D>
    <respuesta_correcta explicacion="Las secuencias de escape en Java usan la barra invertida `\`, como en `\n`, `\t`, etc.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La clase Character se encuentra ubicada en el paquete:
    </enunciado>
    <A>
      java.util
    </A>
    <B>
      java.character
    </B>
    <C>
      java.lang
    </C>
    <D>
      java.unicode
    </D>
    <respuesta_correcta explicacion="La clase `Character` pertenece al paquete `java.lang`, que se importa automáticamente.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La aritmética de caracteres permite que exista una fuerte relación entre el tipo char y el tipo int. Sabiendo que el carácter ‘a’ tiene una representación numérica de 0x61, ¿cómo conseguiremos mostrar el carácter ‘i’ por consola, a partir de la siguiente variable?
            int codepoint = 0x61;
    </enunciado>
    <A>
      System.out.println((char)(codepoint + '8'));
    </A>
    <B>
      System.out.println((char)(codepoint - '8'));
    </B>
    <C>
      System.out.println((char)(codepoint - 8));
    </C>
    <D>
      System.out.println((char)(codepoint + 8));
    </D>
    <respuesta_correcta explicacion="'a' (0x61) más 8 en valor decimal nos da 'i'. El casting `(char)` convierte el valor numérico en carácter.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Marca la opción que devuelve true:
    </enunciado>
    <A>
      Character.isLetter('2');
    </A>
    <B>
      Character.isUpperCase('2');
    </B>
    <C>
      Character.isLowerCase('2');
    </C>
    <D>
      Character.isLetterOrDigit('2');
    </D>
    <respuesta_correcta explicacion="'2' no es letra, pero sí es dígito. `isLetterOrDigit()` devuelve true si el carácter es letra o número.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Señala qué opción es cierta:
    </enunciado>
    <A>
      ‘a’ es un carácter
    </A>
    <B>
      ‘a’ es una cadena de caracteres
    </B>
    <C>
      “a” es un carácter
    </C>
    <D>
      Todas las opciones anteriores son ciertas
    </D>
    <respuesta_correcta explicacion="'a' entre comillas simples es un `char`. &quot;a&quot; (comillas dobles) es un String, por lo tanto no es un carácter.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La forma correcta de comparar alfabéticamente dos cadenas es mediante:
    </enunciado>
    <A>
      El operador ==
    </A>
    <B>
      El método equals() de String
    </B>
    <C>
      El método equal() de Character
    </C>
    <D>
      Todas permiten comparar dos cadenas
    </D>
    <respuesta_correcta explicacion="En realidad, el método correcto es `equals()` de la clase String, no `equal()` ni el operador `==`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La forma de extraer el cuarto carácter de la cadena contenida en la variable cad es mediante:
    </enunciado>
    <A>
      cad.indexOf(3)
    </A>
    <B>
      cad.charAt(3)
    </B>
    <C>
      cad.position(3)
    </C>
    <D>
      cad.extract(3)
    </D>
    <respuesta_correcta explicacion="`charAt(3)` accede al carácter en la posición 4, ya que los índices comienzan en 0.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se utiliza para trabajar con cadenas en Java?
    </enunciado>
    <A>
      char
    </A>
    <B>
      Character
    </B>
    <C>
      String
    </C>
    <D>
      Text
    </D>
    <respuesta_correcta explicacion="La clase `String` permite manipular secuencias de texto en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el método para obtener la longitud de una cadena?
    </enunciado>
    <A>
      length()
    </A>
    <B>
      size()
    </B>
    <C>
      getLength()
    </C>
    <D>
      count()
    </D>
    <respuesta_correcta explicacion="`length()` devuelve el número de caracteres que tiene un objeto `String`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se usa para definir una clase en Java?
    </enunciado>
    <A>
      object
    </A>
    <B>
      define
    </B>
    <C>
      class
    </C>
    <D>
      type
    </D>
    <respuesta_correcta explicacion="La palabra clave `class` se utiliza para declarar una nueva clase en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de método se llama sin necesidad de crear una instancia?
    </enunciado>
    <A>
      privado
    </A>
    <B>
      void
    </B>
    <C>
      abstracto
    </C>
    <D>
      estático
    </D>
    <respuesta_correcta explicacion="Los métodos `static` se pueden invocar directamente desde la clase, sin necesidad de crear un objeto.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Dos clases se consideran vecinas siempre y cuando:
    </enunciado>
    <A>
      Sean visibles
    </A>
    <B>
      Ambas dispongan del mismo número de constructores
    </B>
    <C>
      Pertenezcan al mismo paquete
    </C>
    <D>
      Todo lo anterior ha de cumplirse para que dos clases sean vecinas
    </D>
    <respuesta_correcta explicacion="Las clases se consideran vecinas si pertenecen al mismo paquete.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un miembro cuyo modificador de acceso es private será visible desde:
    </enunciado>
    <A>
      Todas las clases vecinas
    </A>
    <B>
      Todas las clases externas
    </B>
    <C>
      Es indistinto el paquete, pero será visible siempre que se importe la clase que lo contiene
    </C>
    <D>
      Ninguna de las respuestas anteriores
    </D>
    <respuesta_correcta explicacion="Los miembros `private` solo son accesibles dentro de la clase donde se declaran.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si desde un constructor queremos invocar a otro constructor de la misma clase, tendremos que usar:
    </enunciado>
    <A>
      set()
    </A>
    <B>
      get()
    </B>
    <C>
      this()
    </C>
    <D>
      this.
    </D>
    <respuesta_correcta explicacion="`this()` se utiliza para llamar a otro constructor de la misma clase.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si por error dejamos un objeto sin ninguna referencia, siempre podremos volver a referenciarlo mediante:
    </enunciado>
    <A>
      La referencia this
    </A>
    <B>
      La referencia null
    </B>
    <C>
      Utilizando new
    </C>
    <D>
      Es imposible
    </D>
    <respuesta_correcta explicacion="Si no existen referencias a un objeto, este es elegible para recolección de basura y no puede ser accedido nuevamente.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace el operador new?
    </enunciado>
    <A>
      Construye un objeto, invoca al constructor y devuelve su referencia
    </A>
    <B>
      Construye un objeto, comprueba que su clase esté importada y devuelve su referencia
    </B>
    <C>
      Busca en la memoria un objeto del mismo tipo, invoca al constructor y devuelve su referencia
    </C>
    <D>
      Busca en memoria un objeto del mismo tipo y devuelve su referencia
    </D>
    <respuesta_correcta explicacion="El operador `new` crea una nueva instancia de una clase e invoca su constructor.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Cuando hablamos de miembros de una clase, nos estamos refiriendo a:
    </enunciado>
    <A>
      Todos los atributos
    </A>
    <B>
      Todos los métodos
    </B>
    <C>
      Todos los atributos y métodos, indistintamente de los modificadores de acceso utilizados
    </C>
    <D>
      Todos los atributos y métodos que son visibles por sus clases vecinas
    </D>
    <respuesta_correcta explicacion="Se consideran miembros todos los atributos y métodos definidos en una clase.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En la definición de una clase, los únicos modificadores de acceso que se pueden utilizar son:
    </enunciado>
    <A>
      public
    </A>
    <B>
      public y el modificador de acceso por defecto
    </B>
    <C>
      public, el modificador de acceso por defecto y private
    </C>
    <D>
      El modificador class
    </D>
    <respuesta_correcta explicacion="Una clase en Java puede ser `public` o tener acceso por defecto (sin modificador). `private` no se permite para clases top-level.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué diferencia un atributo estático definido en una clase de otro que no lo es?
    </enunciado>
    <A>
      El atributo estático es visible por todas las clases vecinas, mientras que el no estático solo será visible para las clases que usen importación
    </A>
    <B>
      Solo existe una copia del atributo estático en la clase, mientras que el atributo no estático tendrá una copia en cada uno de los objetos
    </B>
    <C>
      Existe una copia del atributo estático en todos y cada uno de los objetos, mientras que del atributo no estático solo existe una copia en la clase
    </C>
    <D>
      Ambos disponen de copias en cada objeto, pero el atributo no estático es accesible mediante la clase y el no estático es accesible mediante los objetos
    </D>
    <respuesta_correcta explicacion="Los atributos estáticos pertenecen a la clase y solo hay una copia compartida, mientras que los no estáticos son propios de cada objeto.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué efecto tienen las siguientes líneas de código?
            Cliente c;
            c.nombre = "Pepita";
    </enunciado>
    <A>
      Inicializa el atributo nombre de Cliente con el valor «Pepita»
    </A>
    <B>
      Invoca al constructor y posteriormente asigna el valor «Pepita» al atributo nombre, siempre y cuando este sea público
    </B>
    <C>
      Si el atributo nombre es público, se le asigna un valor, pero si el atributo es privado, producirá un error
    </C>
    <D>
      Siempre produce un error
    </D>
    <respuesta_correcta explicacion="Cliente c; declara una referencia a un objeto de tipo Cliente,&#xA;         pero no crea ningún objeto (no instancia nada).&#xA;          Como la referencia no apunta a un objeto real (es null),&#xA;           intentar acceder a sus atributos sin haberla inicializado previamente&#xA;            (por ejemplo con new Cliente()) provoca un error en tiempo de ejecución&#xA;             (NullPointerException).">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La ocultación de atributos puede definirse como:
    </enunciado>
    <A>
      El proceso en el que un atributo pasa de ser público a privado
    </A>
    <B>
      El proceso en el que se define una variable local (en un método) con el mismo identificador que un atributo
    </B>
    <C>
      El proceso en el que un atributo estático deja de serlo
    </C>
    <D>
      Todas las respuestas anteriores son correctas
    </D>
    <respuesta_correcta explicacion="La ocultación ocurre cuando una variable local tiene el mismo nombre que un atributo de clase, ocultándolo dentro de su bloque.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La selección dinámica de métodos:
    </enunciado>
    <A>
      Se produce cuando una variable cambia de valor durante la ejecución de un programa
    </A>
    <B>
      Es el cambio de tipo de una variable en tiempo de ejecución
    </B>
    <C>
      Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución
    </C>
    <D>
      Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución
    </D>
    <respuesta_correcta explicacion="Esto se llama polimorfismo. Se ejecuta el método correspondiente al tipo real del objeto, no al tipo de la variable.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?
    </enunciado>
    <A>
      Sirve para llamar al constructor de la superclase
    </A>
    <B>
      Sirve para invocar un método escrito más arriba en el código
    </B>
    <C>
      Sirve para llamar a cualquier método de la superclase
    </C>
    <D>
      Sirve para hacer referencia a un atributo de la superclase
    </D>
    <respuesta_correcta explicacion="`super()` se usa para invocar explícitamente al constructor de la superclase desde una subclase.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Sobre una subclase es correcto afirmar que:
    </enunciado>
    <A>
      Tiene menos atributos que su superclase
    </A>
    <B>
      Tiene menos miembros que su superclase
    </B>
    <C>
      Hereda los miembros no privados de su superclase
    </C>
    <D>
      Hereda todos los miembros de su superclase
    </D>
    <respuesta_correcta explicacion="Una subclase hereda los miembros públicos y protegidos, pero no los privados.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En relación con las clases abstractas es correcto señalar que:
    </enunciado>
    <A>
      Implementan todos sus métodos
    </A>
    <B>
      No implementan ningún método
    </B>
    <C>
      No tienen atributos
    </C>
    <D>
      Tienen algún método abstracto
    </D>
    <respuesta_correcta explicacion="Las clases abstractas pueden tener métodos implementados, pero deben incluir al menos un método abstracto.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿En qué consiste la sustitución u overriding?
    </enunciado>
    <A>
      En sustituir un método heredado por otro implementado en la propia clase
    </A>
    <B>
      En sustituir un atributo por otro del mismo nombre
    </B>
    <C>
      En sustituir una clase por una subclase
    </C>
    <D>
      En sustituir un valor de una variable por otro
    </D>
    <respuesta_correcta explicacion="Overriding es redefinir un método heredado en la subclase, respetando su firma.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Sobre la clase Object es cierto indicar que:
    </enunciado>
    <A>
      Es abstracta
    </A>
    <B>
      Hereda de todas las demás
    </B>
    <C>
      Tiene todos sus métodos abstractos
    </C>
    <D>
      Es superclase de todas las demás clases
    </D>
    <respuesta_correcta explicacion="Todas las clases en Java heredan directa o indirectamente de `Object`.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?
    </enunciado>
    <A>
      Hay que implementarlo, ya que es abstracto
    </A>
    <B>
      Sirve para comparar solo objetos de la clase Object
    </B>
    <C>
      Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase
    </C>
    <D>
      No hay que implementarlo, ya que se hereda de Object
    </D>
    <respuesta_correcta explicacion="Aunque `equals()` está implementado en `Object`, conviene sobreescribirlo para personalizar la comparación.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?
    </enunciado>
    <A>
      Sirve para mostrar la información que nos interesa de un objeto
    </A>
    <B>
      Convierte automáticamente un objeto en una cadena
    </B>
    <C>
      Encadena varios objetos
    </C>
    <D>
      Es un método abstracto de Object que tenemos que implementar
    </D>
    <respuesta_correcta explicacion="`toString()` devuelve una representación textual del objeto. Se puede sobrescribir para personalizarla.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?
    </enunciado>
    <A>
      Convierte los objetos en clases
    </A>
    <B>
      Obtiene la clase a la que pertenece un objeto
    </B>
    <C>
      Obtiene la superclase de una clase
    </C>
    <D>
      Obtiene una clase a partir de su nombre
    </D>
    <respuesta_correcta explicacion="`getClass()` devuelve un objeto de tipo `Class` que representa la clase real del objeto.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una clase puede heredar:
    </enunciado>
    <A>
      De una clase
    </A>
    <B>
      De dos clases
    </B>
    <C>
      De todas las clases que queramos
    </C>
    <D>
      Solo de la clase Object
    </D>
    <respuesta_correcta explicacion="Java solo permite herencia simple: una clase puede heredar de una única superclase.&#xA;            ¿Cuál es la palabra clave para heredar una clase?&#xA;            a) inherits&#xA;            b) extends&#xA;            c) super&#xA;            d) base&#xA;            Respuesta correcta: b&#xA;            'extends' se usa para heredar una clase en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se usa para llamar al constructor de la superclase?
    </enunciado>
    <A>
      super()
    </A>
    <B>
      parent()
    </B>
    <C>
      base()
    </C>
    <D>
      this()
    </D>
    <respuesta_correcta explicacion="'super()' se usa para llamar al constructor de la clase base.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Sobre una subclase es correcto afirmar que:
    </enunciado>
    <A>
      Tiene menos atributos que su superclase.
    </A>
    <B>
      Tiene menos miembros que su superclase.
    </B>
    <C>
      Hereda los miembros no privados de su superclase.
    </C>
    <D>
      Hereda todos los miembros de su superclase.
    </D>
    <respuesta_correcta explicacion="Una subclase hereda los miembros públicos y protegidos de su superclase, no los privados.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En relación con las clases abstractas es correcto señalar que:
    </enunciado>
    <A>
      Implementan todos sus métodos.
    </A>
    <B>
      No implementan ningún método.
    </B>
    <C>
      No tienen atributos.
    </C>
    <D>
      Tienen algún método abstracto.
    </D>
    <respuesta_correcta explicacion="Las clases abstractas pueden tener métodos implementados y atributos, pero deben tener al menos un método abstracto.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿En qué consiste la sustitución u overriding?
    </enunciado>
    <A>
      En sustituir un método heredado por otro implementado en la propia clase.
    </A>
    <B>
      En sustituir un atributo por otro del mismo nombre.
    </B>
    <C>
      En sustituir una clase por una subclase.
    </C>
    <D>
      En sustituir un valor de una variable por otro.
    </D>
    <respuesta_correcta explicacion="Overriding es redefinir un método heredado en una subclase con una nueva implementación.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Sobre la clase Object es cierto indicar que:
    </enunciado>
    <A>
      Es abstracta.
    </A>
    <B>
      Hereda de todas las demás.
    </B>
    <C>
      Tiene todos sus métodos abstractos.
    </C>
    <D>
      Es superclase de todas las demás clases.
    </D>
    <respuesta_correcta explicacion="Object es la superclase de todas las clases en Java.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?
    </enunciado>
    <A>
      Hay que implementarlo, ya que es abstracto.
    </A>
    <B>
      Sirve para comparar solo objetos de la clase Object.
    </B>
    <C>
      Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase.
    </C>
    <D>
      No hay que implementarlo, ya que se hereda de Object.
    </D>
    <respuesta_correcta explicacion="Se hereda de Object, pero se recomienda sobrescribirlo para una comparación personalizada.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?
    </enunciado>
    <A>
      Sirve para mostrar la información que nos interesa de un objeto.
    </A>
    <B>
      Convierte automáticamente un objeto en una cadena.
    </B>
    <C>
      Encadena varios objetos.
    </C>
    <D>
      Es un método abstracto de Object que tenemos que implementar.
    </D>
    <respuesta_correcta explicacion="toString() sirve para devolver una representación textual personalizada de un objeto.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?
    </enunciado>
    <A>
      Convierte los objetos en clases.
    </A>
    <B>
      Obtiene la clase a la que pertenece un objeto.
    </B>
    <C>
      Obtiene la superclase de una clase.
    </C>
    <D>
      Obtiene una clase a partir de su nombre.
    </D>
    <respuesta_correcta explicacion="getClass() devuelve la clase real del objeto en tiempo de ejecución.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una clase puede heredar:
    </enunciado>
    <A>
      De una clase.
    </A>
    <B>
      De dos clases.
    </B>
    <C>
      De todas las clases que queramos.
    </C>
    <D>
      Solo de la clase Object.
    </D>
    <respuesta_correcta explicacion="En Java solo se permite heredar de una única clase (herencia simple).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La selección dinámica de métodos:
    </enunciado>
    <A>
      Se produce cuando una variable cambia de valor durante la ejecución de un programa.
    </A>
    <B>
      Es el cambio de tipo de una variable en tiempo de ejecución.
    </B>
    <C>
      Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución.
    </C>
    <D>
      Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución.
    </D>
    <respuesta_correcta explicacion="Esto es polimorfismo: permite ejecutar la versión del método correspondiente al tipo real del objeto.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?
    </enunciado>
    <A>
      Sirve para llamar al constructor de la superclase.
    </A>
    <B>
      Sirve para invocar un método escrito más arriba en el código.
    </B>
    <C>
      Sirve para llamar a cualquier método de la superclase.
    </C>
    <D>
      Sirve para hacer referencia a un atributo de la superclase.
    </D>
    <respuesta_correcta explicacion="super() se usa para llamar al constructor de la clase base desde una subclase.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el tipo de retorno del método main en Java?
    </enunciado>
    <A>
      void
    </A>
    <B>
      int
    </B>
    <C>
      String
    </C>
    <D>
      boolean
    </D>
    <respuesta_correcta explicacion="El método main debe ser public static void main(String[] args), por eso retorna void.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se utiliza para heredar una clase en Java?
    </enunciado>
    <A>
      this
    </A>
    <B>
      extends
    </B>
    <C>
      implements
    </C>
    <D>
      instanceof
    </D>
    <respuesta_correcta explicacion="La palabra clave 'extends' se utiliza para heredar de una clase base.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué estructura se usa para seleccionar múltiples opciones en Java?
    </enunciado>
    <A>
      if
    </A>
    <B>
      for
    </B>
    <C>
      switch
    </C>
    <D>
      while
    </D>
    <respuesta_correcta explicacion="La estructura 'switch' permite seleccionar múltiples casos según el valor de una expresión.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el valor predeterminado de un boolean en Java?
    </enunciado>
    <A>
      true
    </A>
    <B>
      null
    </B>
    <C>
      false
    </C>
    <D>
      0
    </D>
    <respuesta_correcta explicacion="En Java, las variables boolean por defecto se inicializan como false.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué operador se utiliza para comparar igualdad en Java?
    </enunciado>
    <A>
      =
    </A>
    <B>
      ==
    </B>
    <C>
      equals
    </C>
    <D>
      !=
    </D>
    <respuesta_correcta explicacion="'==' se usa para comparar valores primitivos. Para objetos, se recomienda usar equals().">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes no es una palabra reservada en Java?
    </enunciado>
    <A>
      static
    </A>
    <B>
      try
    </B>
    <C>
      new
    </C>
    <D>
      define
    </D>
    <respuesta_correcta explicacion="'define' no es una palabra reservada en Java, aunque lo es en otros lenguajes como C.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se utiliza para leer datos desde la consola?
    </enunciado>
    <A>
      InputReader
    </A>
    <B>
      Scanner
    </B>
    <C>
      ConsoleReader
    </C>
    <D>
      BufferReader
    </D>
    <respuesta_correcta explicacion="Scanner es la clase comúnmente usada para leer datos desde consola en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes estructuras es una clase contenedora?
    </enunciado>
    <A>
      Array
    </A>
    <B>
      List
    </B>
    <C>
      int
    </C>
    <D>
      char
    </D>
    <respuesta_correcta explicacion="List es una interfaz de colección que representa una lista ordenada de elementos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida de System.out.println(3 + "4")?
    </enunciado>
    <A>
      7
    </A>
    <B>
      34
    </B>
    <C>
      Error
    </C>
    <D>
      "7"
    </D>
    <respuesta_correcta explicacion="Se concatena 3 con el String &quot;4&quot;, dando como resultado &quot;34&quot;.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué significa que Java sea un lenguaje fuertemente tipado?
    </enunciado>
    <A>
      Que se puede cambiar el tipo de una variable libremente.
    </A>
    <B>
      Que se deben declarar todos los tipos de datos.
    </B>
    <C>
      Que es sensible a mayúsculas.
    </C>
    <D>
      Que no se pueden usar tipos primitivos.
    </D>
    <respuesta_correcta explicacion="En Java todos los tipos deben ser declarados explícitamente y no se permite el cambio de tipo implícito en la mayoría de los casos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una interfaz sirve para:
    </enunciado>
    <A>
      Almacenar datos numéricos.
    </A>
    <B>
      Definir una serie de funcionalidades que se implementarán en las clases.
    </B>
    <C>
      Heredar de una clase abstracta.
    </C>
    <D>
      Implementar los métodos abstractos de una clase abstracta.
    </D>
    <respuesta_correcta explicacion="Las interfaces definen un contrato que debe implementarse en las clases.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una interfaz puede heredar de:
    </enunciado>
    <A>
      Una clase.
    </A>
    <B>
      Nada. Las interfaces no pueden heredar.
    </B>
    <C>
      Una o más interfaces.
    </C>
    <D>
      Una cadena.
    </D>
    <respuesta_correcta explicacion="En Java, una interfaz puede heredar de múltiples interfaces.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un método declarado, pero no implementado, en una interfaz se llama:
    </enunciado>
    <A>
      Método estático.
    </A>
    <B>
      Método abstracto.
    </B>
    <C>
      Método de cabecera.
    </C>
    <D>
      Método público.
    </D>
    <respuesta_correcta explicacion="Son métodos abstractos porque no tienen cuerpo, solo la firma.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En una interfaz se pueden definir:
    </enunciado>
    <A>
      Sólo atributos.
    </A>
    <B>
      Sólo métodos abstractos.
    </B>
    <C>
      Atributos, métodos abstractos y métodos no abstractos.
    </C>
    <D>
      Solo métodos públicos.
    </D>
    <respuesta_correcta explicacion="Desde Java 8, una interfaz puede contener métodos default y estáticos, además de constantes.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El criterio de orden natural en una clase es:
    </enunciado>
    <A>
      El criterio más lógico.
    </A>
    <B>
      El criterio implementado en el método compareTo().
    </B>
    <C>
      El criterio más ecológico.
    </C>
    <D>
      El criterio implementado en la interfaz Comparator.
    </D>
    <respuesta_correcta explicacion="El método compareTo() define el orden natural cuando una clase implementa Comparable.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La interfaz Comparator se implementa en:
    </enunciado>
    <A>
      Una clase que queremos ordenar.
    </A>
    <B>
      Una clase que queremos comparar con otra.
    </B>
    <C>
      Una clase cuyos objetos queremos usar para comparar objetos.
    </C>
    <D>
      Un array.
    </D>
    <respuesta_correcta explicacion="Comparator es una interfaz funcional que define objetos que comparan otros objetos.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      El método compare() es invocado por:
    </enunciado>
    <A>
      Un objeto que queremos comparar.
    </A>
    <B>
      Una clase que implementa la interfaz Comparator.
    </B>
    <C>
      Una clase que implementa la interfaz Comparable.
    </C>
    <D>
      Un objeto de una clase que implementa Comparator.
    </D>
    <respuesta_correcta explicacion="El método compare() pertenece a la interfaz Comparator, y se invoca desde un objeto que implementa esta interfaz para comparar dos objetos.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una excepción en Java:
    </enunciado>
    <A>
      Se produce cuando un disco está defectuoso.
    </A>
    <B>
      Es un valor único de una variable.
    </B>
    <C>
      Se arroja al sistema cuando se produce una condición anómala durante la ejecución de un programa.
    </C>
    <D>
      Tiene lugar cuando un código es sintácticamente incorrecto.
    </D>
    <respuesta_correcta explicacion="Las excepciones son condiciones anómalas que ocurren durante la ejecución del programa.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una excepción comprobada es:
    </enunciado>
    <A>
      Una excepción que hemos reparado.
    </A>
    <B>
      Una excepción que no detiene la ejecución del programa.
    </B>
    <C>
      Una excepción previsible, que el propio compilador nos obliga a gestionar.
    </C>
    <D>
      Una excepción muy conocida.
    </D>
    <respuesta_correcta explicacion="Son aquellas que el compilador fuerza a capturar o declarar con `throws`.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Cuando llegamos al final de un flujo de entrada de tipo FileReader, el método read():
    </enunciado>
    <A>
      Muestra el mensaje: End of File
    </A>
    <B>
      Devuelve null.
    </B>
    <C>
      Produce una excepción EOFException
    </C>
    <D>
      Devuelve −1.
    </D>
    <respuesta_correcta explicacion="`read()` devuelve -1 cuando se llega al final del archivo.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La palabra reservada finally:
    </enunciado>
    <A>
      Termina la ejecución de un programa.
    </A>
    <B>
      Termina la ejecución de un método, forzando el return.
    </B>
    <C>
      En una estructura try-catch, fuerza la ejecución de su bloque antes de que se ejecute una sentencia return e independientemente de si se produce o no una excepción.
    </C>
    <D>
      Indica el final de un método.
    </D>
    <respuesta_correcta explicacion="`finally` siempre se ejecuta, ocurra o no una excepción.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un flujo de tipo BufferedReader:
    </enunciado>
    <A>
      Crea un archivo de texto con búfer.
    </A>
    <B>
      Solo sirve para leer cadenas de caracteres.
    </B>
    <C>
      Nos permite acceder a archivos binarios.
    </C>
    <D>
      Accede a un archivo de texto para lectura con búfer.
    </D>
    <respuesta_correcta explicacion="Se usa para leer texto de manera eficiente, línea por línea.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La clase Scanner:
    </enunciado>
    <A>
      Solo permite leer texto de cualquier flujo de texto.
    </A>
    <B>
      Permite digitalizar imágenes.
    </B>
    <C>
      Permite leer y analizar texto de cualquier flujo de entrada de texto.
    </C>
    <D>
      Solo nos permite leer de la consola.
    </D>
    <respuesta_correcta explicacion="Scanner puede leer de consola, archivos, cadenas, etc.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Para cambiar de línea al escribir en el flujo salida de tipo BufferedWriter debemos ejecutar:
    </enunciado>
    <A>
      salida.write(“\n”)
    </A>
    <B>
      salida.write(“\r\n”)
    </B>
    <C>
      salida.write(“newLine”)
    </C>
    <D>
      salida.newLine()
    </D>
    <respuesta_correcta explicacion="`BufferedWriter.newLine()` agrega una nueva línea de forma segura y portátil.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Nos tenemos que asegurar de que todos los flujos abiertos deben cerrarse antes de que termine la aplicación...
    </enunciado>
    <A>
      Porque se quedarían abiertos hasta que se apague el ordenador.
    </A>
    <B>
      Porque otra aplicación podría alterarlos.
    </B>
    <C>
      Porque se deben liberar los recursos asociados, como los archivos. Además, podrían quedar caracteres del búfer sin escribir.
    </C>
    <D>
      Porque se pueden borrar datos de un archivo.
    </D>
    <respuesta_correcta explicacion="Cerrar los flujos garantiza que los datos se escriben correctamente y se libera memoria.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Los flujos se cierran:
    </enunciado>
    <A>
      Con el método close().
    </A>
    <B>
      Apagando el ordenador.
    </B>
    <C>
      Abortando el programa.
    </C>
    <D>
      Con el método cerrar().
    </D>
    <respuesta_correcta explicacion="`close()` es el método estándar para cerrar flujos en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Apertura de flujos con recursos:
    </enunciado>
    <A>
      Consiste en abrir flujos asociados con varios archivos a la vez.
    </A>
    <B>
      Es abrir archivos recurriendo a una tabla.
    </B>
    <C>
      Es una nueva forma de abrir flujos en Java, que permite prescindir del cierre explícito de los archivos y del método close().
    </C>
    <D>
      Consiste en abrir flujos sin peligro de que se produzcan excepciones.
    </D>
    <respuesta_correcta explicacion="Java 7 introdujo `try-with-resources`, que cierra automáticamente los recursos.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirve la clase File en Java?
    </enunciado>
    <A>
      Para crear interfaces gráficas.
    </A>
    <B>
      Para manipular rutas, archivos y directorios.
    </B>
    <C>
      Para leer y escribir ficheros de texto.
    </C>
    <D>
      Para cifrar ficheros.
    </D>
    <respuesta_correcta explicacion="La clase `File` permite manejar rutas, comprobar existencia de archivos, crear o borrar ficheros y directorios.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se utiliza para comprobar si un archivo existe?
    </enunciado>
    <A>
      existsFile()
    </A>
    <B>
      isAvailable()
    </B>
    <C>
      exists()
    </C>
    <D>
      fileFound()
    </D>
    <respuesta_correcta explicacion="El método `exists()` de la clase `File` retorna true si el archivo o carpeta existe.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se usa para escribir texto en un archivo?
    </enunciado>
    <A>
      FileReader
    </A>
    <B>
      File
    </B>
    <C>
      FileWriter
    </C>
    <D>
      FileInputStream
    </D>
    <respuesta_correcta explicacion="`FileWriter` se usa para escribir caracteres en un archivo.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Con qué clase combinamos BufferedWriter para mejorar el rendimiento al escribir archivos?
    </enunciado>
    <A>
      Scanner
    </A>
    <B>
      File
    </B>
    <C>
      FileWriter
    </C>
    <D>
      InputStream
    </D>
    <respuesta_correcta explicacion="`BufferedWriter` se usa junto con `FileWriter` para mejorar el rendimiento mediante búfer de escritura.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué diferencia hay entre FileWriter y FileOutputStream?
    </enunciado>
    <A>
      FileWriter escribe bytes, FileOutputStream caracteres.
    </A>
    <B>
      FileWriter trabaja con texto, FileOutputStream con bytes.
    </B>
    <C>
      Ambas son iguales.
    </C>
    <D>
      FileWriter solo sirve para leer archivos.
    </D>
    <respuesta_correcta explicacion="`FileWriter` es para texto (caracteres) y `FileOutputStream` para datos binarios (bytes).">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se utiliza para leer objetos guardados en un archivo binario?
    </enunciado>
    <A>
      ObjectOutputStream
    </A>
    <B>
      DataInputStream
    </B>
    <C>
      ObjectInputStream
    </C>
    <D>
      FileReader
    </D>
    <respuesta_correcta explicacion="`ObjectInputStream` se usa para leer objetos previamente serializados con `ObjectOutputStream`.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Para que un objeto pueda guardarse en un archivo binario, su clase debe:
    </enunciado>
    <A>
      Extender la clase File.
    </A>
    <B>
      Implementar la interfaz Serializable.
    </B>
    <C>
      Usar anotaciones específicas.
    </C>
    <D>
      Ser pública.
    </D>
    <respuesta_correcta explicacion="La interfaz `Serializable` marca que los objetos de esa clase se pueden guardar como secuencia de bytes.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el propósito de try-with-resources?
    </enunciado>
    <A>
      Evitar errores de compilación.
    </A>
    <B>
      Declarar múltiples métodos en una clase.
    </B>
    <C>
      Manejar múltiples excepciones.
    </C>
    <D>
      Cerrar automáticamente los recursos abiertos como flujos.
    </D>
    <respuesta_correcta explicacion="Es una forma segura de manejar recursos que necesitan cerrarse automáticamente.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase permite leer archivos binarios byte a byte?
    </enunciado>
    <A>
      FileInputStream
    </A>
    <B>
      BufferedReader
    </B>
    <C>
      Scanner
    </C>
    <D>
      PrintWriter
    </D>
    <respuesta_correcta explicacion="`FileInputStream` permite acceder a los archivos binarios como flujo de bytes.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Los ficheros binarios se diferencian de los de texto en que...?
    </enunciado>
    <A>
      Solo tienen ceros y unos.
    </A>
    <B>
      Sirven tanto para escribir como para leer.
    </B>
    <C>
      No sirven para guardar texto.
    </C>
    <D>
      Permiten guardar todo tipo de datos, incluidos datos primitivos y objetos.
    </D>
    <respuesta_correcta explicacion="Los archivos binarios permiten guardar datos primitivos y objetos, no solo texto plano.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si queremos guardar una cadena de caracteres en un flujo binario de tipo ObjectOutputStream, usaremos:
    </enunciado>
    <A>
      writeString().
    </A>
    <B>
      writeChar().
    </B>
    <C>
      writeObject().
    </C>
    <D>
      Nada, no se puede.
    </D>
    <respuesta_correcta explicacion="Con writeObject() puedes guardar cualquier objeto, incluyendo String, si implementa Serializable.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Para guardar una tabla del tipo int[] en un fichero binario con ObjectOutputStream, usaremos:
    </enunciado>
    <A>
      writeInt().
    </A>
    <B>
      writeArrayInt().
    </B>
    <C>
      readObject().
    </C>
    <D>
      writeObject().
    </D>
    <respuesta_correcta explicacion="Las tablas también son objetos en Java, así que deben guardarse con writeObject().">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si queremos leer una tabla de cadenas de caracteres de un flujo ObjectInputStream, escribiremos:
    </enunciado>
    <A>
      String[] tabla = (String[]) entrada.readObject();
    </A>
    <B>
      String tabla = (String) entrada.readObject();
    </B>
    <C>
      String[] tabla = entrada.readObject();
    </C>
    <D>
      String[] tabla = (Object).readObject();
    </D>
    <respuesta_correcta explicacion="Hay que hacer un casting correcto al tipo deseado (String[]), porque readObject() devuelve un Object.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un flujo de tipo ObjectInputStream permite leer de:
    </enunciado>
    <A>
      Cualquier archivo de Windows.
    </A>
    <B>
      Archivos de imagen con extensión JPG.
    </B>
    <C>
      Archivos creados con un flujo ObjectOutputStream.
    </C>
    <D>
      Archivos creados con un flujo BufferedReader.
    </D>
    <respuesta_correcta explicacion="Solo puede leer archivos binarios serializados previamente con ObjectOutputStream.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un flujo de tipo ObjectInputStream permite acceder a:
    </enunciado>
    <A>
      Solo archivos del disco duro.
    </A>
    <B>
      Cualquier fuente de datos primitivos u objetos de Java.
    </B>
    <C>
      Únicamente a conexiones de red.
    </C>
    <D>
      Solo nos permite leer de la consola.
    </D>
    <respuesta_correcta explicacion="Puede leer datos desde archivos, sockets u otros flujos, siempre que el contenido sea compatible.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si guardamos una cadena de caracteres usando ObjectOutputStream, podemos leerla directamente del archivo:
    </enunciado>
    <A>
      Usando un procesador de texto.
    </A>
    <B>
      Usando un editor de texto.
    </B>
    <C>
      Usando una hoja de cálculo.
    </C>
    <D>
      Usando un flujo ObjectInputStream.
    </D>
    <respuesta_correcta explicacion="Los datos binarios solo se pueden leer correctamente desde Java mediante ObjectInputStream.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si guardamos una serie de objetos con ObjectOutputStream, los recuperaremos:
    </enunciado>
    <A>
      En el mismo orden en que se guardaron.
    </A>
    <B>
      En orden inverso.
    </B>
    <C>
      En un orden aleatorio.
    </C>
    <D>
      Nunca se pueden recuperar.
    </D>
    <respuesta_correcta explicacion="La serialización conserva el orden de escritura, y deben recuperarse en el mismo orden.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Los flujos binarios se cierran:
    </enunciado>
    <A>
      Con el método close().
    </A>
    <B>
      Apagando el ordenador.
    </B>
    <C>
      Abortando el programa.
    </C>
    <D>
      Con el método cerrar().
    </D>
    <respuesta_correcta explicacion="Como en otros flujos, close() es el método correcto para liberar recursos.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Hay que cerrar los flujos binarios?
    </enunciado>
    <A>
      Siempre.
    </A>
    <B>
      Una vez al día.
    </B>
    <C>
      Solo si no se han abierto con una estructura try-catch con recursos.
    </C>
    <D>
      Nunca.
    </D>
    <respuesta_correcta explicacion="Es una buena práctica cerrar siempre los flujos para liberar recursos y evitar pérdida de datos.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es Collection?
    </enunciado>
    <A>
      Una interfaz.
    </A>
    <B>
      Una clase.
    </B>
    <C>
      Un sistema operativo.
    </C>
    <D>
      Un método.
    </D>
    <respuesta_correcta explicacion="Collection es una interfaz raíz del marco de colecciones de Java que agrupa tipos como List, Set y Queue.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirven los tipos genéricos?
    </enunciado>
    <A>
      Usar objetos de la clase Object.
    </A>
    <B>
      Usar variables primitivas.
    </B>
    <C>
      Usar tipos parametrizados.
    </C>
    <D>
      No tener que usar ningún tipo.
    </D>
    <respuesta_correcta explicacion="Los genéricos permiten definir estructuras con tipos de datos específicos, aumentando la seguridad y evitando conversiones.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirve una lista?
    </enunciado>
    <A>
      Guardar datos primitivos.
    </A>
    <B>
      Guardar datos que no se pueden repetir.
    </B>
    <C>
      No tener que ordenar un conjunto de datos.
    </C>
    <D>
      Guardar, de forma dinámica, datos que se pueden repetir y ordenar.
    </D>
    <respuesta_correcta explicacion="Las listas (List) permiten almacenar datos en orden y con posibles repeticiones.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un conjunto es una colección de elementos:
    </enunciado>
    <A>
      Que no admiten orden.
    </A>
    <B>
      Que admiten repeticiones.
    </B>
    <C>
      Que no se pueden alterar.
    </C>
    <D>
      Cuyo criterio fundamental es el de pertenecer al conjunto.
    </D>
    <respuesta_correcta explicacion="Un conjunto (Set) se define por la pertenencia, sin duplicados.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ArrayList y LinkedList se diferencian:
    </enunciado>
    <A>
      En el número de elementos.
    </A>
    <B>
      En el rendimiento.
    </B>
    <C>
      En el orden de los elementos.
    </C>
    <D>
      En nada.
    </D>
    <respuesta_correcta explicacion="ArrayList tiene mejor acceso aleatorio, LinkedList es mejor para inserciones o eliminaciones frecuentes.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Los métodos de la interfaz Set:
    </enunciado>
    <A>
      Son los mismos que los de List.
    </A>
    <B>
      Son los mismos que los de Collection.
    </B>
    <C>
      Son implementados en la clase ArrayList.
    </C>
    <D>
      Esta interfaz no tiene métodos.
    </D>
    <respuesta_correcta explicacion="Set hereda de Collection, por lo tanto, sus métodos básicos son los mismos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si la variable a referencia un objeto ArrayList, la expresión new TreeSet(a):
    </enunciado>
    <A>
      Devuelve un conjunto ordenado con los elementos de a.
    </A>
    <B>
      Es incorrecta.
    </B>
    <C>
      Devuelve una lista ordenada.
    </C>
    <D>
      Devuelve una tabla.
    </D>
    <respuesta_correcta explicacion="TreeSet ordena automáticamente los elementos del ArrayList que se le pasa.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es Collections?
    </enunciado>
    <A>
      Una clase cuyos objetos están repetidos.
    </A>
    <B>
      Una interfaz de la que heredan todas las colecciones.
    </B>
    <C>
      Una clase con métodos estáticos que sirven para gestionar colecciones.
    </C>
    <D>
      Nada, le sobra la 's'.
    </D>
    <respuesta_correcta explicacion="Collections es una clase utilitaria con métodos estáticos como sort(), reverse(), etc.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un mapa en Java es:
    </enunciado>
    <A>
      Un gráfico con las relaciones de herencia entre interfaces.
    </A>
    <B>
      Una colección.
    </B>
    <C>
      Una representación de los datos por pantalla.
    </C>
    <D>
      Una estructura dinámica cuyos elementos son parejas clave-valor.
    </D>
    <respuesta_correcta explicacion="Los mapas (Map) almacenan datos en pares clave-valor.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si queremos cambiar el valor de una entrada en un mapa, usaremos el método:
    </enunciado>
    <A>
      put().
    </A>
    <B>
      set().
    </B>
    <C>
      add().
    </C>
    <D>
      insert().
    </D>
    <respuesta_correcta explicacion="put(clave, nuevoValor) actualiza o inserta una nueva entrada en el mapa.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es Collection?
    </enunciado>
    <A>
      Una interfaz.
    </A>
    <B>
      Una clase.
    </B>
    <C>
      Un sistema operativo.
    </C>
    <D>
      Un método.
    </D>
    <respuesta_correcta explicacion="Collection es una interfaz raíz del marco de colecciones de Java que agrupa tipos como List, Set y Queue.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirven los tipos genéricos?
    </enunciado>
    <A>
      Usar objetos de la clase Object.
    </A>
    <B>
      Usar variables primitivas.
    </B>
    <C>
      Usar tipos parametrizados.
    </C>
    <D>
      No tener que usar ningún tipo.
    </D>
    <respuesta_correcta explicacion="Los genéricos permiten definir estructuras con tipos de datos específicos, aumentando la seguridad y evitando conversiones.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirve una lista?
    </enunciado>
    <A>
      Guardar datos primitivos.
    </A>
    <B>
      Guardar datos que no se pueden repetir.
    </B>
    <C>
      No tener que ordenar un conjunto de datos.
    </C>
    <D>
      Guardar, de forma dinámica, datos que se pueden repetir y ordenar.
    </D>
    <respuesta_correcta explicacion="Las listas (List) permiten almacenar datos en orden y con posibles repeticiones.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un conjunto es una colección de elementos:
    </enunciado>
    <A>
      Que no admiten orden.
    </A>
    <B>
      Que admiten repeticiones.
    </B>
    <C>
      Que no se pueden alterar.
    </C>
    <D>
      Cuyo criterio fundamental es el de pertenecer al conjunto.
    </D>
    <respuesta_correcta explicacion="Un conjunto (Set) se define por la pertenencia, sin duplicados.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ArrayList y LinkedList se diferencian:
    </enunciado>
    <A>
      En el número de elementos.
    </A>
    <B>
      En el rendimiento.
    </B>
    <C>
      En el orden de los elementos.
    </C>
    <D>
      En nada.
    </D>
    <respuesta_correcta explicacion="ArrayList tiene mejor acceso aleatorio, LinkedList es mejor para inserciones o eliminaciones frecuentes.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Los métodos de la interfaz Set:
    </enunciado>
    <A>
      Son los mismos que los de List.
    </A>
    <B>
      Son los mismos que los de Collection.
    </B>
    <C>
      Son implementados en la clase ArrayList.
    </C>
    <D>
      Esta interfaz no tiene métodos.
    </D>
    <respuesta_correcta explicacion="Set hereda de Collection, por lo tanto, sus métodos básicos son los mismos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si la variable a referencia un objeto ArrayList, la expresión new TreeSet(a):
    </enunciado>
    <A>
      Devuelve un conjunto ordenado con los elementos de a.
    </A>
    <B>
      Es incorrecta.
    </B>
    <C>
      Devuelve una lista ordenada.
    </C>
    <D>
      Devuelve una tabla.
    </D>
    <respuesta_correcta explicacion="TreeSet ordena automáticamente los elementos del ArrayList que se le pasa.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es Collections?
    </enunciado>
    <A>
      Una clase cuyos objetos están repetidos.
    </A>
    <B>
      Una interfaz de la que heredan todas las colecciones.
    </B>
    <C>
      Una clase con métodos estáticos que sirven para gestionar colecciones.
    </C>
    <D>
      Nada, le sobra la 's'.
    </D>
    <respuesta_correcta explicacion="Collections es una clase utilitaria con métodos estáticos como sort(), reverse(), etc.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Un mapa en Java es:
    </enunciado>
    <A>
      Un gráfico con las relaciones de herencia entre interfaces.
    </A>
    <B>
      Una colección.
    </B>
    <C>
      Una representación de los datos por pantalla.
    </C>
    <D>
      Una estructura dinámica cuyos elementos son parejas clave-valor.
    </D>
    <respuesta_correcta explicacion="Los mapas (Map) almacenan datos en pares clave-valor.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si queremos cambiar el valor de una entrada en un mapa, usaremos el método:
    </enunciado>
    <A>
      put().
    </A>
    <B>
      set().
    </B>
    <C>
      add().
    </C>
    <D>
      insert().
    </D>
    <respuesta_correcta explicacion="put(clave, nuevoValor) actualiza o inserta una nueva entrada en el mapa.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Sobre una subclase es correcto afirmar que:
    </enunciado>
    <A>
      Tiene menos atributos que su superclase.
    </A>
    <B>
      Tiene menos miembros que su superclase.
    </B>
    <C>
      Hereda los miembros no privados de su superclase.
    </C>
    <D>
      Hereda todos los miembros de su superclase.
    </D>
    <respuesta_correcta explicacion="Una subclase hereda los miembros públicos y protegidos de su superclase, no los privados.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En relación con las clases abstractas es correcto señalar que:
    </enunciado>
    <A>
      Implementan todos sus métodos.
    </A>
    <B>
      No implementan ningún método.
    </B>
    <C>
      No tienen atributos.
    </C>
    <D>
      Tienen algún método abstracto.
    </D>
    <respuesta_correcta explicacion="Las clases abstractas pueden tener métodos implementados y atributos, pero deben tener al menos un método abstracto.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿En qué consiste la sustitución u overriding?
    </enunciado>
    <A>
      En sustituir un método heredado por otro implementado en la propia clase.
    </A>
    <B>
      En sustituir un atributo por otro del mismo nombre.
    </B>
    <C>
      En sustituir una clase por una subclase.
    </C>
    <D>
      En sustituir un valor de una variable por otro.
    </D>
    <respuesta_correcta explicacion="Overriding es redefinir un método heredado en una subclase con una nueva implementación.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Sobre la clase Object es cierto indicar que:
    </enunciado>
    <A>
      Es abstracta.
    </A>
    <B>
      Hereda de todas las demás.
    </B>
    <C>
      Tiene todos sus métodos abstractos.
    </C>
    <D>
      Es superclase de todas las demás clases.
    </D>
    <respuesta_correcta explicacion="Object es la superclase de todas las clases en Java.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?
    </enunciado>
    <A>
      Hay que implementarlo, ya que es abstracto.
    </A>
    <B>
      Sirve para comparar solo objetos de la clase Object.
    </B>
    <C>
      Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase.
    </C>
    <D>
      No hay que implementarlo, ya que se hereda de Object.
    </D>
    <respuesta_correcta explicacion="Se hereda de Object, pero se recomienda sobrescribirlo para una comparación personalizada.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?
    </enunciado>
    <A>
      Sirve para mostrar la información que nos interesa de un objeto.
    </A>
    <B>
      Convierte automáticamente un objeto en una cadena.
    </B>
    <C>
      Encadena varios objetos.
    </C>
    <D>
      Es un método abstracto de Object que tenemos que implementar.
    </D>
    <respuesta_correcta explicacion="toString() sirve para devolver una representación textual personalizada de un objeto.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?
    </enunciado>
    <A>
      Convierte los objetos en clases.
    </A>
    <B>
      Obtiene la clase a la que pertenece un objeto.
    </B>
    <C>
      Obtiene la superclase de una clase.
    </C>
    <D>
      Obtiene una clase a partir de su nombre.
    </D>
    <respuesta_correcta explicacion="getClass() devuelve la clase real del objeto en tiempo de ejecución.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Una clase puede heredar:
    </enunciado>
    <A>
      De una clase.
    </A>
    <B>
      De dos clases.
    </B>
    <C>
      De todas las clases que queramos.
    </C>
    <D>
      Solo de la clase Object.
    </D>
    <respuesta_correcta explicacion="En Java solo se permite heredar de una única clase (herencia simple).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      La selección dinámica de métodos:
    </enunciado>
    <A>
      Se produce cuando una variable cambia de valor durante la ejecución de un programa.
    </A>
    <B>
      Es el cambio de tipo de una variable en tiempo de ejecución.
    </B>
    <C>
      Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución.
    </C>
    <D>
      Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución.
    </D>
    <respuesta_correcta explicacion="Esto es polimorfismo: permite ejecutar la versión del método correspondiente al tipo real del objeto.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?
    </enunciado>
    <A>
      Sirve para llamar al constructor de la superclase.
    </A>
    <B>
      Sirve para invocar un método escrito más arriba en el código.
    </B>
    <C>
      Sirve para llamar a cualquier método de la superclase.
    </C>
    <D>
      Sirve para hacer referencia a un atributo de la superclase.
    </D>
    <respuesta_correcta explicacion="super() se usa para llamar al constructor de la clase base desde una subclase.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el tipo de retorno del método main en Java?
    </enunciado>
    <A>
      void
    </A>
    <B>
      int
    </B>
    <C>
      String
    </C>
    <D>
      boolean
    </D>
    <respuesta_correcta explicacion="El método main debe ser public static void main(String[] args), por eso retorna void.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es el overriding (sobreescritura)?
    </enunciado>
    <A>
      Repetir un método en la subclase con la misma firma.
    </A>
    <B>
      Crear múltiples métodos con el mismo nombre y distintos parámetros.
    </B>
    <C>
      Cambiar el tipo de retorno de un método.
    </C>
    <D>
      Es lo mismo que sobrecarga.
    </D>
    <respuesta_correcta explicacion="El overriding consiste en redefinir un método heredado en una subclase, manteniendo la misma firma (nombre, parámetros y tipo de retorno).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué condiciones debe cumplir un método para ser sobrescrito?
    </enunciado>
    <A>
      Mismo nombre
    </A>
    <B>
      Mismo tipo de retorno
    </B>
    <C>
      Misma lista de parámetros
    </C>
    <D>
      Todas son correctas
    </D>
    <respuesta_correcta explicacion="Para sobrescribir un método, debe tener el mismo nombre, tipo de retorno y lista de parámetros. El modificador de acceso no puede ser más restrictivo.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es el overloading (sobrecarga)?
    </enunciado>
    <A>
      Crear múltiples métodos con el mismo nombre pero distintos parámetros.
    </A>
    <B>
      Repetir métodos en subclases.
    </B>
    <C>
      Cambiar solo el tipo de retorno.
    </C>
    <D>
      Solo se puede hacer en interfaces.
    </D>
    <respuesta_correcta explicacion="La sobrecarga permite definir múltiples métodos con el mismo nombre, pero con diferentes listas de parámetros (número o tipo).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es necesario para hacer un cast explícito?
    </enunciado>
    <A>
      Que haya relación de herencia entre clases.
    </A>
    <B>
      Que los tipos sean compatibles.
    </B>
    <C>
      Que la clase base tenga métodos abstractos.
    </C>
    <D>
      Que ambos objetos estén en el mismo paquete.
    </D>
    <respuesta_correcta explicacion="Para realizar un cast explícito, los tipos deben ser compatibles, ya sea por herencia o implementación de interfaces.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué operador comprueba si un objeto pertenece a una clase?
    </enunciado>
    <A>
      instanceOf
    </A>
    <B>
      instanceof
    </B>
    <C>
      belongs
    </C>
    <D>
      castTo
    </D>
    <respuesta_correcta explicacion="El operador `instanceof` verifica si un objeto es una instancia de una clase o de una subclase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la diferencia entre this y super?
    </enunciado>
    <A>
      this accede a la clase actual.
    </A>
    <B>
      super accede a la clase padre.
    </B>
    <C>
      a y b son correctas
    </C>
    <D>
      super permite acceder a métodos privados.
    </D>
    <respuesta_correcta explicacion="`this` se refiere a la instancia actual de la clase, mientras que `super` se utiliza para acceder a miembros de la clase padre.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
                    Persona p = new Persona("Ana", "López", "123456");
                    System.out.println(p.getNombre());
    </enunciado>
    <A>
      Ana
    </A>
    <B>
      null
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      "Ana López 123456"
    </D>
    <respuesta_correcta explicacion="La salida será &quot;Ana&quot; si la clase `Persona` tiene un método `getNombre()` correctamente implementado que devuelve el atributo `nombre` inicializado en el constructor.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
                class A {
                    int x = 10;
                    void mostrar() {
                        System.out.println("Clase A: " + x);
                    }
                }
                class B extends A {
                    int x = 20;
                    void mostrar() {
                        System.out.println("Clase B: " + x);
                    }
                }
                public class Test {
                    public static void main(String[] args) {
                        A obj = new B();
                        obj.mostrar();
                    }
                }
    </enunciado>
    <A>
      Clase A: 10
    </A>
    <B>
      Clase B: 20
    </B>
    <C>
      Clase A: 20
    </C>
    <D>
      Clase B: 10
    </D>
    <respuesta_correcta explicacion="La salida es &quot;Clase B: 20&quot; porque el método `mostrar()` es sobrescrito en la clase `B`. Aunque la referencia es de tipo `A`, el objeto real es de tipo `B`, por lo que se ejecuta el método de la clase `B` debido al polimorfismo.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
                class A {
                    int x = 10;
                    void mostrar() {
                        System.out.println("Clase A: " + x);
                    }
                }
                class B extends A {
                    int x = 20;
                    void mostrar() {
                        System.out.println("Clase B: " + x);
                    }
                }
                public class Test {
                    public static void main(String[] args) {
                        A obj = new B();
                        obj.mostrar();
                    }
                }
    </enunciado>
    <A>
      Clase A: 10
    </A>
    <B>
      Clase B: 20
    </B>
    <C>
      Clase A: 20
    </C>
    <D>
      Clase B: 10
    </D>
    <respuesta_correcta explicacion="La salida es &quot;Clase B: 20&quot; porque el método `mostrar()` es sobrescrito en la clase `B`. Aunque la referencia es de tipo `A`, el objeto real es de tipo `B`, por lo que se ejecuta el método de la clase `B` debido al polimorfismo.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué salida produce este código?
                public class Test {
                    public static void main(String[] args) {
                        int a = 5, b = 10;
                        System.out.println(a + b + "Resultado");
                        System.out.println("Resultado" + a + b);
                    }
                }
    </enunciado>
    <A>
      15Resultado Resultado15
    </A>
    <B>
      15Resultado Resultado510
    </B>
    <C>
      Resultado15 Resultado15
    </C>
    <D>
      5Resultado10 Resultado15
    </D>
    <respuesta_correcta explicacion="En la primera línea, `a + b` se evalúa como 15 antes de concatenar con &quot;Resultado&quot;, dando &quot;15Resultado&quot;. En la segunda línea, &quot;Resultado&quot; se concatena con `a` y luego con `b`, resultando en &quot;Resultado510&quot;.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede al ejecutar este código?
                class Padre {
                    void saludar() {
                        System.out.println("Hola desde Padre");
                    }
                }
                class Hijo extends Padre {
                    void saludar() {
                        System.out.println("Hola desde Hijo");
                    }
                }
                public class Test {
                    public static void main(String[] args) {
                        Padre p = new Hijo();
                        p.saludar();
                    }
                }
    </enunciado>
    <A>
      Hola desde Padre
    </A>
    <B>
      Hola desde Hijo
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      No imprime nada
    </D>
    <respuesta_correcta explicacion="La salida es &quot;Hola desde Hijo&quot; porque el método `saludar()` es sobrescrito en la clase `Hijo`. Aunque la referencia es de tipo `Padre`, el objeto real es de tipo `Hijo`, por lo que se ejecuta el método de la clase `Hijo` debido al polimorfismo.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de estas clases implementa una estructura LIFO?
    </enunciado>
    <A>
      Array
    </A>
    <B>
      Stack
    </B>
    <C>
      ArrayList
    </C>
    <D>
      Queue
    </D>
    <respuesta_correcta explicacion="La clase `Stack` implementa una estructura LIFO (Last In, First Out), donde el último elemento en entrar es el primero en salir.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones sobre los arrays en Java es verdadera?
    </enunciado>
    <A>
      No se puede acceder a un array con un índice numérico
    </A>
    <B>
      Un array puede contener distintos tipos de datos
    </B>
    <C>
      Los arrays pueden cambiar de tamaño dinámicamente
    </C>
    <D>
      El tamaño del array es fijo una vez creado
    </D>
    <respuesta_correcta explicacion="En Java, el tamaño de un array es fijo una vez que se crea, son homogéneos y no puede cambiar dinámicamente.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el método adecuado para añadir un elemento a una ArrayList?
    </enunciado>
    <A>
      put()
    </A>
    <B>
      append()
    </B>
    <C>
      insert()
    </C>
    <D>
      add()
    </D>
    <respuesta_correcta explicacion="El método `add()` se utiliza para añadir elementos a una `ArrayList` en Java.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la forma correcta de declarar y crear un array de enteros con 10 elementos?
    </enunciado>
    <A>
      array = int[10];
    </A>
    <B>
      int[] array = new int[10];
    </B>
    <C>
      int array = new int[10];
    </C>
    <D>
      int array(10);
    </D>
    <respuesta_correcta explicacion="La forma correcta de declarar y crear un array de enteros con 10 elementos es `int[] array = new int[10];`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la interfaz que implementan todas las colas en Java?
    </enunciado>
    <A>
      Queue
    </A>
    <B>
      Deque
    </B>
    <C>
      Stack
    </C>
    <D>
      LinkedList
    </D>
    <respuesta_correcta explicacion="La interfaz `Queue` es implementada por todas las clases que representan colas en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede al ejecutar este código?
            interface A {
                void saludar();
            }
            class B implements A {
                public void saludar() {
                    System.out.println("Hola");
                }
            }
    </enunciado>
    <A>
      Error de compilación
    </A>
    <B>
      Imprime: null
    </B>
    <C>
      No imprime nada
    </C>
    <D>
      Imprime: Hola
    </D>
    <respuesta_correcta explicacion="La clase `B` implementa correctamente la interfaz `A` y sobrescribe el método `saludar()`. Al ejecutarlo, imprime &quot;Hola&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
            stack.push(10);
            stack.push(20);
            System.out.println(stack.peek());
    </enunciado>
    <A>
      20
    </A>
    <B>
      10
    </B>
    <C>
      30
    </C>
    <D>
      Error en compilación
    </D>
    <respuesta_correcta explicacion="El método `peek()` devuelve el último elemento añadido a la pila sin eliminarlo. En este caso, devuelve 20.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la sintaxis correcta para que una clase implemente una interfaz?
    </enunciado>
    <A>
      class MiClase implements MiInterfaz
    </A>
    <B>
      class MiClase extends MiInterfaz
    </B>
    <C>
      class MiClase : MiInterfaz
    </C>
    <D>
      class MiClase inherits MiInterfaz
    </D>
    <respuesta_correcta explicacion="La palabra clave `implements` se utiliza para que una clase implemente una interfaz en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es una característica de una clase abstracta?
    </enunciado>
    <A>
      Puede tener métodos abstractos y concretos
    </A>
    <B>
      Solo puede tener atributos estáticos
    </B>
    <C>
      Se puede instanciar directamente
    </C>
    <D>
      No puede tener métodos implementados
    </D>
    <respuesta_correcta explicacion="Una clase abstracta puede tener métodos abstractos (sin implementación) y métodos concretos (con implementación).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede al ejecutar este código?
            interface A {
                void saludar();
            }
            class B implements A {
                public void saludar() {
                    System.out.println("Hola");
                }
            }
    </enunciado>
    <A>
      Error de compilación
    </A>
    <B>
      Imprime: null
    </B>
    <C>
      No imprime nada
    </C>
    <D>
      Imprime: Hola
    </D>
    <respuesta_correcta explicacion="La clase `B` implementa correctamente la interfaz `A` y sobrescribe el método `saludar()`. Al ejecutarlo, imprime &quot;Hola&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
            stack.push(10);
            stack.push(20);
            System.out.println(stack.peek());
    </enunciado>
    <A>
      20
    </A>
    <B>
      10
    </B>
    <C>
      30
    </C>
    <D>
      Error en compilación
    </D>
    <respuesta_correcta explicacion="El método `peek()` devuelve el último elemento añadido a la pila sin eliminarlo. En este caso, devuelve 20.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la sintaxis correcta para que una clase implemente una interfaz?
    </enunciado>
    <A>
      class MiClase implements MiInterfaz
    </A>
    <B>
      class MiClase extends MiInterfaz
    </B>
    <C>
      class MiClase : MiInterfaz
    </C>
    <D>
      class MiClase inherits MiInterfaz
    </D>
    <respuesta_correcta explicacion="La palabra clave `implements` se utiliza para que una clase implemente una interfaz en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es una característica de una clase abstracta?
    </enunciado>
    <A>
      Puede tener métodos abstractos y concretos
    </A>
    <B>
      Solo puede tener atributos estáticos
    </B>
    <C>
      Se puede instanciar directamente
    </C>
    <D>
      No puede tener métodos implementados
    </D>
    <respuesta_correcta explicacion="Una clase abstracta puede tener métodos abstractos (sin implementación) y métodos concretos (con implementación).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            Queue&lt;Integer&gt; cola = new LinkedList&lt;&gt;();
            Stack&lt;Integer&gt; pila = new Stack&lt;&gt;();
            cola.add(1);
            cola.add(2);
            pila.push(cola.poll());
            pila.push(cola.poll());
            System.out.println(pila.pop());
    </enunciado>
    <A>
      3
    </A>
    <B>
      1
    </B>
    <C>
      null
    </C>
    <D>
      2
    </D>
    <respuesta_correcta explicacion="El método `poll()` elimina y devuelve el primer elemento de la cola. Se añaden 1 y 2 a la pila, y `pop()` elimina y devuelve el último elemento añadido, que es 2.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            Stack&lt;String&gt; historial = new Stack&lt;&gt;();
            historial.push("Escribir línea 1");
            historial.push("Escribir línea 2");
            historial.pop(); // deshacer
            System.out.println(historial.peek());
    </enunciado>
    <A>
      Escribir línea 2
    </A>
    <B>
      Escribir línea 1
    </B>
    <C>
      error
    </C>
    <D>
      null
    </D>
    <respuesta_correcta explicacion="El método `pop()` elimina el último elemento añadido (&quot;Escribir línea 2&quot;). Luego, `peek()` devuelve el elemento en la cima de la pila, que es &quot;Escribir línea 1&quot;.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            LinkedList&lt;Integer&gt; numeros = new LinkedList&lt;&gt;();
            numeros.addFirst(10);
            numeros.addLast(20);
            System.out.println(numeros.size());
    </enunciado>
    <A>
      Error de compilación
    </A>
    <B>
      2
    </B>
    <C>
      1
    </C>
    <D>
      10
    </D>
    <respuesta_correcta explicacion="Se añaden dos elementos a la lista (10 al principio y 20 al final). El método `size()` devuelve el número total de elementos, que es 2.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            Stack&lt;Integer&gt; pila = new Stack&lt;&gt;();
            Queue&lt;Integer&gt; cola = new LinkedList&lt;&gt;();
            pila.push(10);
            cola.add(20);
            System.out.println(pila.pop() + cola.peek());
    </enunciado>
    <A>
      1020
    </A>
    <B>
      10
    </B>
    <C>
      30
    </C>
    <D>
      20
    </D>
    <respuesta_correcta explicacion="`pop()` elimina y devuelve 10 de la pila, y `peek()` devuelve 20 de la cola sin eliminarlo. La suma es 30.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();
            Stack&lt;String&gt; pila = new Stack&lt;&gt;();
            lista.add("X");
            pila.push("Y");
            System.out.println(lista.get(0) + pila.peek());
    </enunciado>
    <A>
      X Y
    </A>
    <B>
      null
    </B>
    <C>
      XY
    </C>
    <D>
      YX
    </D>
    <respuesta_correcta explicacion="`get(0)` devuelve &quot;X&quot; de la lista, y `peek()` devuelve &quot;Y&quot; de la pila. La concatenación resulta en &quot;XY&quot;.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            Stack&lt;Integer&gt; pila = new Stack&lt;&gt;();
            pila.push(5);
            pila.push(10);
            pila.pop();
            System.out.println(pila.peek());
    </enunciado>
    <A>
      10
    </A>
    <B>
      5
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      null
    </D>
    <respuesta_correcta explicacion="El método `pop()` elimina el último elemento añadido (10). Luego, `peek()` devuelve el elemento en la cima de la pila, que es 5.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de LinkedList añade un elemento al principio de la lista?
    </enunciado>
    <A>
      add()
    </A>
    <B>
      insertFirst()
    </B>
    <C>
      push()
    </C>
    <D>
      addFirst()
    </D>
    <respuesta_correcta explicacion="El método `addFirst()` de LinkedList añade un elemento al principio de la lista.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método elimina el último elemento en una Stack?
    </enunciado>
    <A>
      getLast()
    </A>
    <B>
      peek()
    </B>
    <C>
      pop()
    </C>
    <D>
      removeLast()
    </D>
    <respuesta_correcta explicacion="El método `pop()` elimina y devuelve el último elemento añadido a la pila (LIFO).">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      abstract class Figura {
            abstract double area();
        }
        class Cuadrado extends Figura {
            // Falta el método area()
        }
    </enunciado>
    <A>
      equals()
    </A>
    <B>
      toString()
    </B>
    <C>
      area(), de lo contrario hay error
    </C>
    <D>
      Ninguno, es opcional
    </D>
    <respuesta_correcta explicacion="La clase `Cuadrado` debe implementar el método `area()` porque es abstracto en la clase `Figura`. Si no lo hace, la clase `Cuadrado` también debería declararse como abstracta; de lo contrario, se producirá un error de compilación.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se utiliza para ver el primer elemento de una Queue sin eliminarlo?
    </enunciado>
    <A>
      pop()
    </A>
    <B>
      front()
    </B>
    <C>
      poll()
    </C>
    <D>
      peek()
    </D>
    <respuesta_correcta explicacion="El método `peek()` devuelve el primer elemento de la cola sin eliminarlo.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
             LinkedList&lt;String&gt; lista = new LinkedList&lt;&gt;();
             Stack&lt;String&gt; pila = new Stack&lt;&gt;();
             lista.add("Java");
             pila.push("Collections");
             lista.add(pila.pop());
             System.out.println(lista);
    </enunciado>
    <A>
      [Java, Collections]
    </A>
    <B>
      [Collections]
    </B>
    <C>
      [Java]
    </C>
    <D>
      Error en tiempo de ejecución
    </D>
    <respuesta_correcta explicacion="El método `pop()` elimina y devuelve el último elemento añadido a la pila (&quot;Collections&quot;), que luego se añade a la lista. La salida es `[Java, Collections]`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
             ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();
             lista.add("A");
             lista.add("B");
             lista.add("C");
             System.out.println(lista.get(1));
    </enunciado>
    <A>
      C
    </A>
    <B>
      null
    </B>
    <C>
      B
    </C>
    <D>
      A
    </D>
    <respuesta_correcta explicacion="`get(1)` devuelve el elemento en la posición 1 de la lista, que es &quot;B&quot;.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
             ArrayList&lt;Integer&gt; numeros = new ArrayList&lt;&gt;();
             numeros.add(1);
             numeros.add(2);
             numeros.add(3);
             numeros.remove(1);
             System.out.println(numeros);
    </enunciado>
    <A>
      [1, 2]
    </A>
    <B>
      [3]
    </B>
    <C>
      [2, 3]
    </C>
    <D>
      [1, 3]
    </D>
    <respuesta_correcta explicacion="El método `remove(1)` elimina el elemento en la posición 1 (el número 2). La lista resultante es `[1, 3]`.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
             ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();
             LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;();
             lista.add("uno");
             linked.add("dos");
             System.out.println(lista.get(0) + "-" + linked.get(0));
    </enunciado>
    <A>
      uno-dos
    </A>
    <B>
      null-null
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      dos-uno
    </D>
    <respuesta_correcta explicacion="`get(0)` devuelve &quot;uno&quot; de la lista y &quot;dos&quot; del linked list. La salida es &quot;uno-dos&quot;.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede si accedes a un índice que no existe en un ArrayList?
    </enunciado>
    <A>
      Se lanza una excepción IndexOutOfBoundsException
    </A>
    <B>
      Se devuelve null
    </B>
    <C>
      Se elimina el último elemento
    </C>
    <D>
      Se ignora el acceso
    </D>
    <respuesta_correcta explicacion="Acceder a un índice fuera de rango en un ArrayList lanza una excepción `IndexOutOfBoundsException`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de estas sentencias crea correctamente un objeto de la clase `Alumno`?
    </enunciado>
    <A>
      Alumno alumno();
    </A>
    <B>
      new Alumno Alumno();
    </B>
    <C>
      Alumno = new Alumno();
    </C>
    <D>
      Alumno alumno = new Alumno();
    </D>
    <respuesta_correcta explicacion="La sintaxis correcta para crear un objeto en Java es `Clase nombreObjeto = new Clase();`. En este caso, `Alumno alumno = new Alumno();`.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprimirá el siguiente fragmento?
            int[][] matriz = {
                {1,2,3},{4,5,6}
            };
            System.out.println(matriz[1][2]);
    </enunciado>
    <A>
      4
    </A>
    <B>
      5
    </B>
    <C>
      2
    </C>
    <D>
      6
    </D>
    <respuesta_correcta explicacion="El elemento en la posición `matriz[1][2]` corresponde al valor 6, ya que está en la segunda fila y tercera columna.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprimirá este código?
            public static void imprime(int n) {
                n = 2 * n;
                System.out.println(n);
            }
            public static void main(String[] args) {
                int n = 10;
                imprime(n);
                System.out.println(n);
            }
    </enunciado>
    <A>
      20 y luego 10
    </A>
    <B>
      20 y luego 20
    </B>
    <C>
      10 y luego 10
    </C>
    <D>
      10 y luego 20
    </D>
    <respuesta_correcta explicacion="El valor de `n` dentro del método `imprime` es una copia del original, por lo que no afecta al valor de `n` en `main`. Se imprime 20 y luego 10.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de Scanner lee un número entero?
    </enunciado>
    <A>
      next()
    </A>
    <B>
      read()
    </B>
    <C>
      nextInt()
    </C>
    <D>
      nextLine()
    </D>
    <respuesta_correcta explicacion="El método `nextInt()` de la clase `Scanner` se utiliza para leer un número entero desde la entrada estándar.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de Stack devuelve el elemento del tope SIN eliminarlo?
    </enunciado>
    <A>
      pop()
    </A>
    <B>
      poll()
    </B>
    <C>
      push()
    </C>
    <D>
      peek()
    </D>
    <respuesta_correcta explicacion="El método `peek()` devuelve el elemento en la cima de la pila sin eliminarlo.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se ejecuta al arrancar una aplicación Java?
    </enunciado>
    <A>
      init()
    </A>
    <B>
      main()
    </B>
    <C>
      run()
    </C>
    <D>
      start()
    </D>
    <respuesta_correcta explicacion="El método `main()` es el punto de entrada de una aplicación Java. Debe estar definido como `public static void main(String[] args)`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué mostrará este código?
            int[] valores = new int[4];
            System.out.println(valores[1]);
    </enunciado>
    <A>
      0
    </A>
    <B>
      Error de compilación
    </B>
    <C>
      null
    </C>
    <D>
      1
    </D>
    <respuesta_correcta explicacion="En Java, los arrays de enteros se inicializan automáticamente con ceros. Por lo tanto, `valores[1]` imprime 0.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué muestra este código?
            ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();
            lista.add("A");
            lista.add("B");
            System.out.println(lista.get(1));
    </enunciado>
    <A>
      0
    </A>
    <B>
      Error en tiempo de ejecución
    </B>
    <C>
      A
    </C>
    <D>
      B
    </D>
    <respuesta_correcta explicacion="`get(1)` devuelve el elemento en la posición 1 de la lista, que es &quot;B&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué muestra este código?
            class Animal {
                void sonido() { System.out.println("Sonido genérico"); }
            }
            class Perro extends Animal {
                void sonido() { System.out.println("Ladrido"); }
            }
            Animal a = new Perro();
            a.sonido();
    </enunciado>
    <A>
      Ladrido
    </A>
    <B>
      Error de compilación
    </B>
    <C>
      No imprime nada
    </C>
    <D>
      Sonido genérico
    </D>
    <respuesta_correcta explicacion="El método `sonido()` es sobrescrito en la clase `Perro`. Aunque la referencia es de tipo `Animal`, el objeto real es de tipo `Perro`, por lo que se ejecuta el método de la clase `Perro` debido al polimorfismo.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué muestra este fragmento de código?
            public static int suma(int a, int b) {
                return a + b;
            }
            System.out.println(suma(2,3));
    </enunciado>
    <A>
      2
    </A>
    <B>
      3
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      5
    </D>
    <respuesta_correcta explicacion="El método `suma` devuelve la suma de los dos parámetros, que en este caso es 2 + 3 = 5.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué ocurre cuando un parámetro se pasa "por valor" en Java?
    </enunciado>
    <A>
      Se pasa la referencia al objeto original.
    </A>
    <B>
      El método puede cambiar el tipo de la variable.
    </B>
    <C>
      Se modifica el valor original automáticamente.
    </C>
    <D>
      Se copia el valor y no afecta al original.
    </D>
    <respuesta_correcta explicacion="En Java, los parámetros se pasan por valor. Esto significa que se copia el valor del argumento y los cambios realizados dentro del método no afectan al valor original.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué ocurre si un atributo es declarado como `private`?
    </enunciado>
    <A>
      Solo puede ser accedido desde métodos estáticos.
    </A>
    <B>
      Solo puede ser accedido desde dentro de su propia clase.
    </B>
    <C>
      Solo puede ser accedido directamente desde otras clases.
    </C>
    <D>
      Puede ser accedido libremente desde cualquier lugar.
    </D>
    <respuesta_correcta explicacion="El modificador `private` restringe el acceso a los atributos únicamente dentro de la clase donde se declaran.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué ocurre si un flujo no se cierra adecuadamente en Java?
    </enunciado>
    <A>
      Se lanza una excepción Checked automáticamente.
    </A>
    <B>
      El programa se detiene inmediatamente.
    </B>
    <C>
      Se elimina el archivo afectado.
    </C>
    <D>
      Los datos pueden no guardarse correctamente y hay fuga de recursos.
    </D>
    <respuesta_correcta explicacion="Si un flujo no se cierra, los datos pueden no guardarse correctamente y los recursos asociados, como archivos o memoria, no se liberan, lo que puede causar fugas de recursos.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué ocurre si una subclase quiere llamar al constructor de su superclase?
    </enunciado>
    <A>
      No es posible llamar al constructor de la superclase.
    </A>
    <B>
      Llama a super().
    </B>
    <C>
      Solo puede hacerlo dentro de métodos estáticos.
    </C>
    <D>
      Llama a this().
    </D>
    <respuesta_correcta explicacion="Para llamar al constructor de la superclase, se utiliza la palabra clave `super()` y debe ser la primera línea en el constructor de la subclase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave indica que un método en Java no devuelve ningún valor?
    </enunciado>
    <A>
      void
    </A>
    <B>
      null
    </B>
    <C>
      static
    </C>
    <D>
      return
    </D>
    <respuesta_correcta explicacion="La palabra clave `void` se utiliza para declarar que un método no devuelve ningún valor.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra reservada se utiliza para referirse al objeto actual dentro de sus propios métodos?
    </enunciado>
    <A>
      object
    </A>
    <B>
      self
    </B>
    <C>
      super
    </C>
    <D>
      this
    </D>
    <respuesta_correcta explicacion="La palabra clave `this` se utiliza para referirse al objeto actual dentro de sus propios métodos o constructores.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué realiza la sentencia `return` en un método?
    </enunciado>
    <A>
      Sale del método y devuelve un valor opcionalmente.
    </A>
    <B>
      Continúa con la siguiente instrucción.
    </B>
    <C>
      Salta entre casos de un switch.
    </C>
    <D>
      Finaliza un bucle.
    </D>
    <respuesta_correcta explicacion="La sentencia `return` finaliza la ejecución de un método y, opcionalmente, devuelve un valor al llamador.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué resultado muestra este código?
            Stack&lt;Integer&gt; pila = new Stack&lt;&gt;();
            pila.push(1);
            pila.push(2);
            pila.push(3);
            System.out.println(pila.peek());
    </enunciado>
    <A>
      Error
    </A>
    <B>
      1
    </B>
    <C>
      2
    </C>
    <D>
      3
    </D>
    <respuesta_correcta explicacion="El método `peek()` devuelve el último elemento añadido a la pila sin eliminarlo. En este caso, devuelve 3.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede si no se define ningún constructor en una clase?
    </enunciado>
    <A>
      Hay que llamar manualmente a un método init().
    </A>
    <B>
      Se crean todos los posibles constructores.
    </B>
    <C>
      El programa no compila.
    </C>
    <D>
      Java crea automáticamente un constructor por defecto.
    </D>
    <respuesta_correcta explicacion="Si no se define ningún constructor, Java crea automáticamente un constructor por defecto que no realiza ninguna acción específica.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de herencia permite Java directamente entre clases?
    </enunciado>
    <A>
      Circular
    </A>
    <B>
      Única
    </B>
    <C>
      Híbrida
    </C>
    <D>
      Múltiple
    </D>
    <respuesta_correcta explicacion="Java permite únicamente herencia simple entre clases, es decir, una clase solo puede heredar directamente de una única superclase.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor tendrá datos[2] tras ejecutar este código?
            int[] datos = {8, 10, 2, 3, 5};
    </enunciado>
    <A>
      8
    </A>
    <B>
      2
    </B>
    <C>
      5
    </C>
    <D>
      10
    </D>
    <respuesta_correcta explicacion="El índice 2 en el array `datos` corresponde al tercer elemento, que es 2.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes opciones es CORRECTA sobre Stack en Java?
    </enunciado>
    <A>
      No permite elementos duplicados.
    </A>
    <B>
      Es una implementación de FIFO.
    </B>
    <C>
      Se accede primero al primer elemento insertado.
    </C>
    <D>
      Se basa en el principio LIFO (Last In First Out).
    </D>
    <respuesta_correcta explicacion="La clase `Stack` en Java sigue el principio LIFO (Last In, First Out), donde el último elemento en entrar es el primero en salir.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de los siguientes métodos añade un elemento al final de un ArrayList?
    </enunciado>
    <A>
      insert()
    </A>
    <B>
      put()
    </B>
    <C>
      add()
    </C>
    <D>
      append()
    </D>
    <respuesta_correcta explicacion="El método `add()` se utiliza para añadir elementos al final de un `ArrayList` en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la diferencia principal entre while y do-while?
    </enunciado>
    <A>
      do-while siempre se ejecuta al menos una vez.
    </A>
    <B>
      do-while no necesita condición.
    </B>
    <C>
      while siempre se ejecuta al menos una vez.
    </C>
    <D>
      while es más rápido que do-while.
    </D>
    <respuesta_correcta explicacion="En un bucle `do-while`, el bloque de código se ejecuta al menos una vez antes de evaluar la condición.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué sirve un compilador en programación?
    </enunciado>
    <A>
      Para interpretar línea a línea un programa.
    </A>
    <B>
      Para ejecutar directamente el código fuente.
    </B>
    <C>
      Para transformar el código fuente en código máquina.
    </C>
    <D>
      Para depurar errores en el código fuente.
    </D>
    <respuesta_correcta explicacion="Un compilador traduce el código fuente escrito por el programador a código máquina que puede ser ejecutado por el procesador.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué afirmación es CORRECTA sobre las clases abstractas en Java?
    </enunciado>
    <A>
      Todos sus métodos deben ser estáticos.
    </A>
    <B>
      Pueden crear instancias directas.
    </B>
    <C>
      No se pueden instanciar, pero sí extender.
    </C>
    <D>
      Solo pueden contener métodos abstractos.
    </D>
    <respuesta_correcta explicacion="Las clases abstractas no se pueden instanciar directamente, pero pueden ser extendidas por otras clases. Además, pueden contener métodos abstractos y concretos.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase permite leer datos desde la consola de una manera sencilla?
    </enunciado>
    <A>
      Scanner
    </A>
    <B>
      BufferedReader
    </B>
    <C>
      JOptionPane
    </C>
    <D>
      System.out
    </D>
    <respuesta_correcta explicacion="La clase `Scanner` es ampliamente utilizada para leer datos desde la consola de manera sencilla en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se usa para leer caracteres de forma eficiente mediante búfer en Java?
    </enunciado>
    <A>
      OutputStreamWriter
    </A>
    <B>
      InputStreamReader
    </B>
    <C>
      PrintStream
    </C>
    <D>
      BufferedReader
    </D>
    <respuesta_correcta explicacion="`BufferedReader` se utiliza para leer caracteres de manera eficiente mediante un búfer, lo que mejora el rendimiento.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué define mejor un getter en una clase Java?
    </enunciado>
    <A>
      Un constructor con parámetros.
    </A>
    <B>
      Un atributo especial de la clase.
    </B>
    <C>
      Un método que modifica un atributo privado.
    </C>
    <D>
      Un método que devuelve el valor de un atributo privado.
    </D>
    <respuesta_correcta explicacion="Un getter es un método que permite acceder al valor de un atributo privado desde fuera de la clase.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué devuelve el método equals() de la clase Arrays?
    </enunciado>
    <A>
      True si dos arrays son iguales en tamaño y contenido.
    </A>
    <B>
      Una copia exacta de un array.
    </B>
    <C>
      El tamaño máximo permitido para un array.
    </C>
    <D>
      La suma de los elementos de un array.
    </D>
    <respuesta_correcta explicacion="El método `Arrays.equals()` devuelve `true` si dos arrays tienen el mismo tamaño y contenido, comparando elemento por elemento.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es el código fuente?
    </enunciado>
    <A>
      El compilador de Java.
    </A>
    <B>
      El programa en lenguaje máquina.
    </B>
    <C>
      El programa escrito por el programador en un lenguaje de alto nivel.
    </C>
    <D>
      El programa ejecutable.
    </D>
    <respuesta_correcta explicacion="El código fuente es el programa escrito por el programador en un lenguaje de alto nivel, como Java, antes de ser compilado.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es un array en Java?
    </enunciado>
    <A>
      Una colección de datos de tipos diferentes.
    </A>
    <B>
      Una colección de elementos del mismo tipo, con acceso mediante índices.
    </B>
    <C>
      Una estructura dinámica de datos.
    </C>
    <D>
      Una clase especial para almacenar objetos.
    </D>
    <respuesta_correcta explicacion="Un array en Java es una colección de elementos del mismo tipo, organizados en posiciones indexadas, comenzando desde 0.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es un ArrayList en Java?
    </enunciado>
    <A>
      Una colección de tamaño fijo.
    </A>
    <B>
      Un array estático que almacena datos primitivos.
    </B>
    <C>
      Una estructura que solo admite tipos numéricos.
    </C>
    <D>
      Una lista dinámica que puede crecer o decrecer en tamaño.
    </D>
    <respuesta_correcta explicacion="Un `ArrayList` es una lista dinámica en Java que puede cambiar de tamaño automáticamente al añadir o eliminar elementos.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué estructura de control ejecuta un bloque de instrucciones si una condición es verdadera?
    </enunciado>
    <A>
      do-while
    </A>
    <B>
      while
    </B>
    <C>
      if
    </C>
    <D>
      switch
    </D>
    <respuesta_correcta explicacion="La estructura `if` evalúa una condición y ejecuta un bloque de código solo si la condición es verdadera.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué estructura de datos utiliza una Queue?
    </enunciado>
    <A>
      Random Access
    </A>
    <B>
      FILO (First In Last Out)
    </B>
    <C>
      LIFO (Last In First Out)
    </C>
    <D>
      FIFO (First In First Out)
    </D>
    <respuesta_correcta explicacion="Una `Queue` utiliza la estructura FIFO (First In First Out), donde el primer elemento en entrar es el primero en salir.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace el método `poll()` en una Queue en Java?
    </enunciado>
    <A>
      Devuelve el último elemento sin eliminarlo.
    </A>
    <B>
      Añade un elemento al final de la cola.
    </B>
    <C>
      Reordena los elementos de la cola.
    </C>
    <D>
      Elimina y devuelve el primer elemento de la cola.
    </D>
    <respuesta_correcta explicacion="El método `poll()` elimina y devuelve el primer elemento de la cola. Si la cola está vacía, devuelve `null`.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace este código?
            int numero = 1;
            while (numero &lt;= 3) {
                System.out.println(numero);
                numero++;
            }
    </enunciado>
    <A>
      No imprime nada
    </A>
    <B>
      Imprime 1, 2, 3
    </B>
    <C>
      Imprime 0, 1, 2
    </C>
    <D>
      Imprime 1, 2
    </D>
    <respuesta_correcta explicacion="El bucle `while` imprime los valores de `numero` desde 1 hasta 3, incrementando en cada iteración.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace este método recursivo correctamente escrito?
            void imprimir(int x) {
                if (x &gt; 0) {
                    imprimir(x - 1);
                    System.out.println(x);
                }
            }
    </enunciado>
    <A>
      No imprime nada.
    </A>
    <B>
      Imprime del número x hacia 1.
    </B>
    <C>
      Imprime solo el número x.
    </C>
    <D>
      Imprime del 1 hasta x.
    </D>
    <respuesta_correcta explicacion="El método recursivo primero llama a sí mismo con `x - 1` hasta llegar a 0, y luego imprime los valores desde 1 hasta `x` en orden ascendente.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprimirá el siguiente código?
            Persona p = new Persona("Ana", "García", "555123");
            System.out.println(p.getNombre());
    </enunciado>
    <A>
      García
    </A>
    <B>
      Ana
    </B>
    <C>
      p
    </C>
    <D>
      555123
    </D>
    <respuesta_correcta explicacion="El método `getNombre()` devuelve el nombre del objeto `Persona`, que en este caso es &quot;Ana&quot;.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprimirá el siguiente fragmento de código?
            for (int i = 0; i &lt; 3; i++) {
                System.out.println(i);
            }
    </enunciado>
    <A>
      1, 2
    </A>
    <B>
      1, 2, 3
    </B>
    <C>
      0, 1, 2
    </C>
    <D>
      0, 1, 2, 3
    </D>
    <respuesta_correcta explicacion="El bucle `for` imprime los valores de `i` desde 0 hasta 2, ya que la condición es `i &lt; 3`.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones describe mejor el polimorfismo en Java?
    </enunciado>
    <A>
      La sobrecarga de operadores.
    </A>
    <B>
      La capacidad de una variable, una función o un objeto de tomar varias formas.
    </B>
    <C>
      La encapsulación de datos y métodos.
    </C>
    <D>
      La herencia de métodos de una clase padre.
    </D>
    <respuesta_correcta explicacion="El polimorfismo permite que una variable, función u objeto adopte múltiples formas, como cuando un método sobrescrito se ejecuta según el tipo real del objeto.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones es verdadera sobre el uso de la palabra clave super en Java?
    </enunciado>
    <A>
      Se usa para definir métodos abstractos.
    </A>
    <B>
      Se usa para evitar la sobrecarga de métodos.
    </B>
    <C>
      Se usa para declarar una variable como estática.
    </C>
    <D>
      Permite acceder a los métodos y variables de clase padre desde una subclase.
    </D>
    <respuesta_correcta explicacion="La palabra clave `super` se utiliza en una subclase para acceder a los métodos y variables de su clase padre.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el método para agregar un elemento a un ArrayList en Java?
    </enunciado>
    <A>
      add()
    </A>
    <B>
      addElement()
    </B>
    <C>
      addItem()
    </C>
    <D>
      insert()
    </D>
    <respuesta_correcta explicacion="El método `add()` se utiliza para agregar un elemento al final de un `ArrayList` en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el modificador de acceso más restrictivo en Java?
    </enunciado>
    <A>
      protected
    </A>
    <B>
      public
    </B>
    <C>
      private
    </C>
    <D>
      default
    </D>
    <respuesta_correcta explicacion="El modificador `private` es el más restrictivo en Java, ya que limita el acceso únicamente a la clase donde se declara.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el modificador de acceso predeterminado si no se especifica ninguno en Java?
    </enunciado>
    <A>
      default
    </A>
    <B>
      protected
    </B>
    <C>
      private
    </C>
    <D>
      public
    </D>
    <respuesta_correcta explicacion="El modificador de acceso predeterminado en Java se conoce como &quot;default&quot; (sin palabra clave explícita) y permite el acceso solo dentro del mismo paquete.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el propósito de la interfaz?
            interface Dibujable {
                void dibujar();
            }
            class Cuadro implements Dibujable {
                public void dibujar() {
                    System.out.println("Dibujando cuadro");
                }
            }
    </enunciado>
    <A>
      Crear objetos
    </A>
    <B>
      Definir un contrato que la clase debe cumplir
    </B>
    <C>
      Implementar herencia
    </C>
    <D>
      Guardar datos
    </D>
    <respuesta_correcta explicacion="El propósito de una interfaz es definir un contrato que las clases que la implementen deben cumplir, asegurando que implementen los métodos definidos en la interfaz.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la forma correcta de crear un ArrayList en Java?
    </enunciado>
    <A>
      ArrayList&lt;Integer&gt; list = new ArrayList&lt;String&gt;();
    </A>
    <B>
      ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    </B>
    <C>
      ArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();
    </C>
    <D>
      ArrayList&lt;int&gt; list = new ArrayList&lt;&gt;();
    </D>
    <respuesta_correcta explicacion="La forma correcta de crear un `ArrayList` es especificando el mismo tipo genérico en ambos lados, como `ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();`. Los tipos primitivos como `int` no son válidos, se debe usar su clase envolvente (`Integer`).">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes afirmaciones es correcta sobre las diferencias entre una clase abstracta y una interfaz en Java?
    </enunciado>
    <A>
      Una clase abstracta puede tener métodos con implementación, mientras que una interfaz solo puede tener métodos abstractos.
    </A>
    <B>
      Una clase abstracta no puede ser heredada, mientras que una interfaz sí.
    </B>
    <C>
      Una interfaz puede tener constructores, mientras que una clase abstracta no.
    </C>
    <D>
      Una interfaz puede tener variables de instancia, mientras que una clase abstracta no.
    </D>
    <respuesta_correcta explicacion="Una clase abstracta puede tener métodos con implementación y métodos abstractos. Desde Java 8, las interfaces también pueden tener métodos con implementación (default y static), pero históricamente solo contenían métodos abstractos.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del programa?
            public class Recursiva {
                public static int factorial(int n) {
                    if (n &lt;= 1) return 1;
                    return n * factorial(n - 1);
                }
                public static void main(String[] args) {
                    System.out.println(factorial(5));
                }
            }
    </enunciado>
    <A>
      120
    </A>
    <B>
      Error de compilación
    </B>
    <C>
      15
    </C>
    <D>
      5
    </D>
    <respuesta_correcta explicacion="El método `factorial` calcula el factorial de un número de forma recursiva. Para `factorial(5)`, el cálculo es 5 * 4 * 3 * 2 * 1, lo que da como resultado 120.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código recursivo al ser llamado con metodoRecursivo(4)?
            public class Main {
                public static void main(String[] args) {
                    System.out.println(metodoRecursivo(4));
                }
                public static int metodoRecursivo(int n) {
                    int resultado;
                    if (n == 1) {
                        resultado = 1;
                    } else {
                        resultado = n * metodoRecursivo(n - 1);
                    }
                    return resultado;
                }
            }
    </enunciado>
    <A>
      12
    </A>
    <B>
      24
    </B>
    <C>
      4
    </C>
    <D>
      1
    </D>
    <respuesta_correcta explicacion="El método `metodoRecursivo` calcula el factorial de un número de forma recursiva. Para `metodoRecursivo(4)`, el cálculo es 4 * 3 * 2 * 1, lo que da como resultado 24.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            public class Main {
                public static void main(String[] args) {
                    int x = 5;
                    int y = 10;
                    x = x + y;
                    y = x - y;
                    x = x - y;
                    System.out.println("x: " + x + ", y: " + y);
                }
            }
    </enunciado>
    <A>
      x: 0, y: 15
    </A>
    <B>
      x: 10, y: 5
    </B>
    <C>
      x: 5, y: 10
    </C>
    <D>
      x: 15, y: 0
    </D>
    <respuesta_correcta explicacion="El código intercambia los valores de `x` e `y` sin usar una variable temporal. Al final, `x` toma el valor original de `y` (10) y `y` toma el valor original de `x` (5).">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            String pattern = "a*b";
            String text = "aaaaab";
            boolean match = text.matches(pattern);
            System.out.println(match);
    </enunciado>
    <A>
      aaaaab
    </A>
    <B>
      false
    </B>
    <C>
      true
    </C>
    <D>
      Error de compilación
    </D>
    <respuesta_correcta explicacion="El método `matches` verifica si el texto coincide con el patrón. El patrón `&quot;a*b&quot;` significa &quot;cero o más 'a' seguidas de una 'b'&quot;. El texto `&quot;aaaaab&quot;` cumple con este patrón, por lo que el resultado es `true`.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código?
            public class Ciclo {
                public static void main(String[] args) {
                    for (int i = 1; i &lt;= 3; i++) {
                        System.out.print(i + " ");
                    }
                }
            }
    </enunciado>
    <A>
      Error
    </A>
    <B>
      3 2 1
    </B>
    <C>
      0 1 2
    </C>
    <D>
      1 2 3
    </D>
    <respuesta_correcta explicacion="El bucle `for` comienza en 1 y se ejecuta mientras `i` sea menor o igual a 3, incrementando `i` en cada iteración. La salida es &quot;1 2 3&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase en Java se utiliza para leer datos de un archivo de texto?
    </enunciado>
    <A>
      FileInputStream
    </A>
    <B>
      FileReader
    </B>
    <C>
      BufferedWriter
    </C>
    <D>
      FileWriter
    </D>
    <respuesta_correcta explicacion="La clase `FileReader` se utiliza para leer datos de un archivo de texto en Java, caracter por caracter.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué estructura de datos en Java permite almacenar pares de clave y valor?
    </enunciado>
    <A>
      a y b son correctas.
    </A>
    <B>
      HashMap
    </B>
    <C>
      ArrayList
    </C>
    <D>
      Ninguna es correcta
    </D>
    <respuesta_correcta explicacion="La estructura `HashMap` permite almacenar pares de clave y valor en Java, proporcionando acceso rápido a los valores mediante las claves.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace este código?
            public class Hilo extends Thread {
                public void run() {
                    System.out.println("Hilo ejecutándose");
                }
                public static void main(String[] args) {
                    Hilo h = new Hilo();
                    h.run();
                }
            }
    </enunciado>
    <A>
      Lanza error
    </A>
    <B>
      Ejecuta run() manualmente
    </B>
    <C>
      Crea una interfaz
    </C>
    <D>
      Ejecuta un hilo con start()
    </D>
    <respuesta_correcta explicacion="El método `run()` se ejecuta manualmente como un método normal, no como un hilo independiente. Para ejecutar un hilo, se debe usar el método `start()`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime el código?
            public class Contador {
                private static int cuenta = 0;
                public Contador() {
                    cuenta++;
                }
                public static int getCuenta() {
                    return cuenta;
                }
                public static void main(String[] args) {
                    new Contador();
                    new Contador();
                    System.out.println(Contador.getCuenta());
                }
            }
    </enunciado>
    <A>
      Error
    </A>
    <B>
      1
    </B>
    <C>
      2
    </C>
    <D>
      0
    </D>
    <respuesta_correcta explicacion="El atributo `cuenta` es estático, por lo que es compartido por todas las instancias de la clase. Cada vez que se crea un nuevo objeto `Contador`, el constructor incrementa `cuenta`. Al final, se han creado dos objetos, por lo que `cuenta` vale 2.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime el siguiente código?
            public class Main {
                public static void main(String[] args) {
                    String s = "hello";
                    String t = "world";
                    String u = s + t;
                    System.out.println(u.length());
                }
            }
    </enunciado>
    <A>
      11
    </A>
    <B>
      5
    </B>
    <C>
      10
    </C>
    <D>
      12
    </D>
    <respuesta_correcta explicacion="El código concatena las cadenas `&quot;hello&quot;` y `&quot;world&quot;`, formando `&quot;helloworld&quot;`. La longitud de esta cadena es 11, que es lo que imprime el método `length()`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime este código?
            public class Incremento {
                public static void main(String[] args) {
                    int a = 5;
                    System.out.println(++a);
                }
            }
    </enunciado>
    <A>
      6
    </A>
    <B>
      Error
    </B>
    <C>
      4
    </C>
    <D>
      5
    </D>
    <respuesta_correcta explicacion="El operador `++a` incrementa el valor de `a` antes de que se utilice en la expresión. Por lo tanto, `a` pasa de 5 a 6, y se imprime 6.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime este código?
            public class Suma {
                public static int suma(int[] numeros) {
                    int total = 0;
                    for (int i = 0; i &gt; numeros.length; i++) {
                        total += numeros[i];
                    }
                    return total;
                }
                public static void main(String[] args) {
                    int[] num = {1, 2, 3};
                    System.out.println(suma(num));
                }
            }
    </enunciado>
    <A>
      Error
    </A>
    <B>
      123
    </B>
    <C>
      6.0
    </C>
    <D>
      6
    </D>
    <respuesta_correcta explicacion="El método `suma` calcula la suma de los elementos del array `numeros`. En este caso, la suma de `{1, 2, 3}` es `1 + 2 + 3 = 6`, por lo que imprime `6`.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime este programa?
            import java.util.ArrayList;
            public class Lista {
                public static void main(String[] args) {
                    ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();
                    lista.add("uno");
                    lista.add("dos");
                    System.out.println(lista.get(0));
                }
            }
    </enunciado>
    <A>
      0
    </A>
    <B>
      Error
    </B>
    <C>
      dos
    </C>
    <D>
      uno
    </D>
    <respuesta_correcta explicacion="`get(0)` devuelve el primer elemento de la lista, que es &quot;uno&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime este programa?
            import java.util.HashMap;
            public class Mapa {
                public static void main(String[] args) {
                    HashMap&lt;String, Integer&gt; mapa = new HashMap&lt;&gt;();
                    mapa.put("clave", 100);
                    System.out.println(mapa.get("clave"));
                }
            }
    </enunciado>
    <A>
      100
    </A>
    <B>
      "clave"
    </B>
    <C>
      null
    </C>
    <D>
      Error
    </D>
    <respuesta_correcta explicacion="El método `put` agrega un par clave-valor al `HashMap`. El método `get(&quot;clave&quot;)` devuelve el valor asociado a la clave &quot;clave&quot;, que es `100`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué imprime este código?
            public class StringTest {
                public static void main(String[] args) {
                    String s1 = "Java";
                    String s2 = "Java";
                    System.out.println(s1 == s2);
                }
            }
    </enunciado>
    <A>
      Error
    </A>
    <B>
      true
    </B>
    <C>
      false
    </C>
    <D>
      null
    </D>
    <respuesta_correcta explicacion="En Java, las cadenas literales que tienen el mismo contenido se almacenan en el pool de cadenas, por lo que `s1` y `s2` apuntan al mismo objeto. Por lo tanto, `s1 == s2` devuelve `true`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué mensaje imprime este código?
            public class Excepcion {
                public static void main(String[] args) {
                    try {
                        int a = 5 / 0;
                    } catch (ArithmeticException e) {
                        System.out.println("Error aritmético");
                    }
                }
            }
    </enunciado>
    <A>
      Error aritmético
    </A>
    <B>
      Exception
    </B>
    <C>
      0
    </C>
    <D>
      5
    </D>
    <respuesta_correcta explicacion="El código lanza una excepción `ArithmeticException` debido a la división por cero. El bloque `catch` captura esta excepción y muestra el mensaje &quot;Error aritmético&quot;.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método de la clase String se usa para convertir todas las letras de una cadena a minúsculas?
    </enunciado>
    <A>
      toLowerCase()
    </A>
    <B>
      toLower()
    </B>
    <C>
      convertToLower()
    </C>
    <D>
      tolower()
    </D>
    <respuesta_correcta explicacion="El método `toLowerCase()` de la clase `String` convierte todas las letras de una cadena a minúsculas.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se usa para cerrar un archivo después de escribir en él usando la clase FileWriter?
    </enunciado>
    <A>
      end()
    </A>
    <B>
      close()
    </B>
    <C>
      finish()
    </C>
    <D>
      closeFile()
    </D>
    <respuesta_correcta explicacion="El método `close()` se utiliza para cerrar un archivo y liberar los recursos asociados después de escribir en él con la clase `FileWriter`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se utiliza para obtener la longitud de un array en Java?
    </enunciado>
    <A>
      length
    </A>
    <B>
      length()
    </B>
    <C>
      size()
    </C>
    <D>
      getLength()
    </D>
    <respuesta_correcta explicacion="En Java, los arrays tienen un atributo llamado `length` (sin paréntesis) que devuelve la cantidad de elementos en el array.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se utiliza para obtener un valor a partir de una clave en un HashMap en Java?
    </enunciado>
    <A>
      get()
    </A>
    <B>
      find()
    </B>
    <C>
      getValue()
    </C>
    <D>
      retrieve()
    </D>
    <respuesta_correcta explicacion="El método `get()` de la clase `HashMap` se utiliza para obtener el valor asociado a una clave específica.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se utiliza para definir una clase que no puede ser extendida?
    </enunciado>
    <A>
      final
    </A>
    <B>
      static
    </B>
    <C>
      abstract
    </C>
    <D>
      private
    </D>
    <respuesta_correcta explicacion="La palabra clave `final` se utiliza para declarar una clase que no puede ser extendida. Esto significa que no se pueden crear subclases a partir de ella.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se utiliza para implementar una interfaz en una clase en Java?
    </enunciado>
    <A>
      extends
    </A>
    <B>
      extend
    </B>
    <C>
      implements
    </C>
    <D>
      implement
    </D>
    <respuesta_correcta explicacion="La palabra clave `implements` se utiliza para que una clase implemente una interfaz en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué realiza este código?
            import java.io.*;
            public class Lectura {
                public static void main(String[] args) throws IOException {
                    BufferedReader br = new BufferedReader(new FileReader("datos.txt"));
                    String linea;
                    while ((linea = br.readLine()) != null) {
                        System.out.println(linea);
                    }
                    br.close();
                }
            }
    </enunciado>
    <A>
      Lee línea por línea un archivo de texto, e imprime por consola la línea.
    </A>
    <B>
      Borra un archivo
    </B>
    <C>
      Imprime una línea vacía
    </C>
    <D>
      Escribe datos en un archivo
    </D>
    <respuesta_correcta explicacion="El código utiliza `BufferedReader` para leer un archivo de texto línea por línea y las imprime en la consola. El método `readLine()` devuelve cada línea del archivo hasta que no haya más líneas (retorna `null`).">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué representa la clase Figura?
    </enunciado>
    <A>
      Una interfaz
    </A>
    <B>
      Una clase concreta
    </B>
    <C>
      Una excepción
    </C>
    <D>
      Una clase abstracta que sirve como base
    </D>
    <respuesta_correcta explicacion="La clase `Figura` es una clase abstracta que define un método abstracto `area()`. Sirve como base para que las clases derivadas, como `Circulo`, implementen el método `area()` según sus propias características.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué representa PI?
    </enunciado>
    <A>
      Una clase
    </A>
    <B>
      Una constante
    </B>
    <C>
      Una variable privada
    </C>
    <D>
      Un método
    </D>
    <respuesta_correcta explicacion="`PI` es una constante porque está declarada como `static final`, lo que significa que su valor no puede cambiar y pertenece a la clase en lugar de a una instancia.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué resultado imprime este código?
            public class Comparar {
                public static void main(String[] args) {
                    String a = "hola";
                    String b = new String("hola");
                    System.out.println(a.equals(b));
                }
            }
    </enunciado>
    <A>
      true
    </A>
    <B>
      Error
    </B>
    <C>
      false
    </C>
    <D>
      hola
    </D>
    <respuesta_correcta explicacion="El método `equals()` compara el contenido de las cadenas. Aunque `a` y `b` son diferentes objetos, tienen el mismo contenido (&quot;hola&quot;), por lo que `a.equals(b)` devuelve `true`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué salida produce este código?
            public class Persona {
                private String nombre;
                public Persona(String nombre) {
                    this.nombre = nombre;
                }
                public void saludar() {
                    System.out.println("Hola, soy " + nombre);
                }
                public static void main(String[] args) {
                    Persona p = new Persona("Ana");
                    p.saludar();
                }
            }
    </enunciado>
    <A>
      nombre
    </A>
    <B>
      Hola, soy Ana
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      Hola, soy null
    </D>
    <respuesta_correcta explicacion="El constructor de la clase `Persona` inicializa el atributo `nombre` con el valor &quot;Ana&quot;. Al llamar al método `saludar()`, se imprime &quot;Hola, soy Ana&quot;.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se imprime?
    </enunciado>
    <A>
      Error
    </A>
    <B>
      Constructor B\nConstructor A
    </B>
    <C>
      Solo Constructor B
    </C>
    <D>
      Constructor A\nConstructor B
    </D>
    <respuesta_correcta explicacion="Cuando se crea un objeto de la clase `B`, primero se ejecuta el constructor de la clase padre `A` y luego el constructor de la clase `B`. Por lo tanto, la salida es &quot;Constructor A\nConstructor B&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se imprime?
    </enunciado>
    <A>
      Sonido de animal
    </A>
    <B>
      Gato
    </B>
    <C>
      Error
    </C>
    <D>
      Miau
    </D>
    <respuesta_correcta explicacion="El método `sonido()` es sobrescrito en la clase `Gato`. Aunque la referencia es de tipo `Animal`, el objeto real es de tipo `Gato`, por lo que se ejecuta el método sobrescrito en la clase `Gato`, imprimiendo &quot;Miau&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se imprime?
    </enunciado>
    <A>
      Error
    </A>
    <B>
      Hola Mundo
    </B>
    <C>
      Hola
    </C>
    <D>
      Mundo
    </D>
    <respuesta_correcta explicacion="El método `substring(5)` devuelve la subcadena que comienza en el índice 5 (basado en 0) hasta el final de la cadena. En este caso, imprime &quot;Mundo&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor se imprime?
    </enunciado>
    <A>
      3
    </A>
    <B>
      1
    </B>
    <C>
      2
    </C>
    <D>
      Error
    </D>
    <respuesta_correcta explicacion="El índice 2 en el array `numeros` corresponde al tercer elemento, que es 3. Por lo tanto, se imprime 3.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es la recursividad en programación?
    </enunciado>
    <A>
      Un método que se llama a sí mismo.
    </A>
    <B>
      Una técnica para sortear excepciones.
    </B>
    <C>
      Una variable que cambia su valor automáticamente.
    </C>
    <D>
      Un bucle que se repite indefinidamente.
    </D>
    <respuesta_correcta explicacion="La recursividad es una técnica en programación donde un método se llama a sí mismo para resolver un problema dividiéndolo en subproblemas más pequeños.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida?
    </enunciado>
    <A>
      Error
    </A>
    <B>
      3 2 1
    </B>
    <C>
      0 1 2
    </C>
    <D>
      1 2 3
    </D>
    <respuesta_correcta explicacion="El bucle `for` comienza en 1 y se ejecuta mientras `i` sea menor o igual a 3, incrementando `i` en cada iteración. La salida es &quot;1 2 3&quot;.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la primera fase del ciclo de vida del software?
    </enunciado>
    <A>
      Pruebas
    </A>
    <B>
      Mantenimiento
    </B>
    <C>
      Análisis de requisitos
    </C>
    <D>
      Implementación
    </D>
    <respuesta_correcta explicacion="La primera fase del ciclo de vida del software es el análisis de requisitos, donde se identifican las necesidades y expectativas del cliente para el sistema.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de dato debe tener una variable para almacenar el valor de una letra?
    </enunciado>
    <A>
      boolean
    </A>
    <B>
      double
    </B>
    <C>
      int
    </C>
    <D>
      char
    </D>
    <respuesta_correcta explicacion="El tipo de dato `char` se utiliza para almacenar un único carácter, como una letra.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de dato en Java se usa para representar valores decimales?
    </enunciado>
    <A>
      char
    </A>
    <B>
      boolean
    </B>
    <C>
      double
    </C>
    <D>
      int
    </D>
    <respuesta_correcta explicacion="El tipo de dato `double` se utiliza para representar números decimales en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la convención para nombrar una variable en Java?
    </enunciado>
    <A>
      Puede comenzar con un número
    </A>
    <B>
      Debe contener espacios entre palabras
    </B>
    <C>
      Siempre debe estar en mayúsculas
    </C>
    <D>
      Comienza con una letra minúscula y usa camelCase
    </D>
    <respuesta_correcta explicacion="La convención en Java es que los nombres de las variables comiencen con una letra minúscula y usen camelCase para separar palabras.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes opciones es un tipo de dato primitivo en Java?
    </enunciado>
    <A>
      String
    </A>
    <B>
      Integer
    </B>
    <C>
      char
    </C>
    <D>
      Array
    </D>
    <respuesta_correcta explicacion="`char` es un tipo de dato primitivo en Java que se utiliza para representar un único carácter.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué se usa la palabra clave final en Java?
    </enunciado>
    <A>
      Para iniciar un bucle
    </A>
    <B>
      Para definir una constante
    </B>
    <C>
      Para declarar un tipo de dato entero
    </C>
    <D>
      Para cerrar una clase
    </D>
    <respuesta_correcta explicacion="La palabra clave `final` se utiliza para declarar constantes en Java, es decir, valores que no pueden cambiar después de ser inicializados.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor puede almacenar un dato de tipo boolean en Java?
    </enunciado>
    <A>
      true o false
    </A>
    <B>
      Solo caracteres ASCII
    </B>
    <C>
      Cualquier número entero
    </C>
    <D>
      Cualquier valor de texto
    </D>
    <respuesta_correcta explicacion="Un dato de tipo `boolean` en Java solo puede almacenar los valores `true` o `false`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el operador correcto para realizar una multiplicación en Java?
    </enunciado>
    <A>
      &lt;
    </A>
    <B>
      /
    </B>
    <C>
      *
    </C>
    <D>
      %
    </D>
    <respuesta_correcta explicacion="El operador `*` se utiliza para realizar multiplicaciones en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es el "casteo" en Java?
    </enunciado>
    <A>
      Crear una nueva clase
    </A>
    <B>
      Cambiar el nombre de una variable
    </B>
    <C>
      Convertir un tipo de dato en otro
    </C>
    <D>
      Ejecutar un programa
    </D>
    <respuesta_correcta explicacion="El &quot;casteo&quot; en Java se refiere a convertir un tipo de dato en otro, ya sea de forma implícita o explícita.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el valor de la variable resultado después de esta operación? `int resultado = 10 / 3;`
    </enunciado>
    <A>
      0
    </A>
    <B>
      3
    </B>
    <C>
      10
    </C>
    <D>
      3.33
    </D>
    <respuesta_correcta explicacion="En Java, la división entre enteros devuelve un resultado entero. Por lo tanto, `10 / 3` da como resultado `3`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la función de System.out.println en Java?
    </enunciado>
    <A>
      Define una variable
    </A>
    <B>
      Ejecuta el programa
    </B>
    <C>
      Almacena datos en la memoria
    </C>
    <D>
      Imprime texto en la consola y luego inserta una nueva línea
    </D>
    <respuesta_correcta explicacion="`System.out.println` se utiliza para imprimir texto en la consola y, al finalizar, inserta automáticamente una nueva línea.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes opciones es un ejemplo de ejercicio práctico de entrada y salida de datos en Java?
    </enunciado>
    <A>
      Definir una variable sin mostrarla en pantalla
    </A>
    <B>
      Imprimir "Hola, mundo!"
    </B>
    <C>
      Declarar una clase sin métodos
    </C>
    <D>
      Calcular el promedio de tres números ingresados por el usuario
    </D>
    <respuesta_correcta explicacion="Un ejercicio práctico de entrada y salida de datos en Java podría ser calcular el promedio de tres números ingresados por el usuario, ya que implica leer datos y mostrar resultados.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué resultado genera el siguiente código? `System.out.println("Hola, mundo!");`
    </enunciado>
    <A>
      Imprime "Hola, mundo!" en la consola
    </A>
    <B>
      Lanza un error de compilación
    </B>
    <C>
      Almacena "Hola, mundo!" en una variable
    </C>
    <D>
      No hace nada
    </D>
    <respuesta_correcta explicacion="El código `System.out.println(&quot;Hola, mundo!&quot;);` imprime el texto &quot;Hola, mundo!&quot; en la consola y luego inserta una nueva línea.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Para qué se usa la clase Scanner en Java?
    </enunciado>
    <A>
      Para leer datos de entrada desde la consola
    </A>
    <B>
      Para imprimir texto en la consola
    </B>
    <C>
      Para crear nuevos métodos
    </C>
    <D>
      Para realizar operaciones matemáticas complejas
    </D>
    <respuesta_correcta explicacion="La clase `Scanner` se utiliza para leer datos de entrada desde la consola, como números, cadenas o caracteres.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes líneas de código es correcta para crear un objeto Scanner?
    </enunciado>
    <A>
      Scanner entrada = Scanner(System.out);
    </A>
    <B>
      Scanner entrada = new Scanner(System.in);
    </B>
    <C>
      entrada Scanner = new (System.in);
    </C>
    <D>
      Scanner entrada = Scanner();
    </D>
    <respuesta_correcta explicacion="La forma correcta de crear un objeto `Scanner` es `Scanner entrada = new Scanner(System.in);`, donde `System.in` representa la entrada estándar (teclado).">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se usa para leer una cadena de texto ingresada por el usuario con Scanner?
    </enunciado>
    <A>
      nextDouble()
    </A>
    <B>
      nextInt()
    </B>
    <C>
      nextLine()
    </C>
    <D>
      nextChar()
    </D>
    <respuesta_correcta explicacion="El método `nextLine()` de la clase `Scanner` se utiliza para leer una línea completa de texto ingresada por el usuario.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el propósito de System.out.print en comparación con System.out.println?
    </enunciado>
    <A>
      Imprime texto en mayúsculas automáticamente
    </A>
    <B>
      Solo imprime números
    </B>
    <C>
      Imprime texto sin añadir una nueva línea al final
    </C>
    <D>
      Almacena datos en una variable
    </D>
    <respuesta_correcta explicacion="`System.out.print` imprime texto en la consola sin añadir una nueva línea al final, a diferencia de `System.out.println` que sí lo hace.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cómo se puede capturar un número entero ingresado por el usuario en la consola usando Scanner?
    </enunciado>
    <A>
      entrada.nextDouble();
    </A>
    <B>
      entrada.nextInt();
    </B>
    <C>
      entrada.readInt();
    </C>
    <D>
      entrada.nextLine();
    </D>
    <respuesta_correcta explicacion="El método `nextInt()` de la clase `Scanner` se utiliza para capturar un número entero ingresado por el usuario.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué ocurrirá si el usuario ingresa un valor no numérico cuando se espera un número entero con nextInt()?
    </enunciado>
    <A>
      Se lanza una excepción InputMismatchException
    </A>
    <B>
      Se ignora el valor ingresado
    </B>
    <C>
      Se produce un error de compilación
    </C>
    <D>
      Se captura el valor sin problemas
    </D>
    <respuesta_correcta explicacion="Si el usuario ingresa un valor no numérico cuando se espera un número entero con `nextInt()`, se lanza una excepción `InputMismatchException`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida del siguiente código? `System.out.print("Java "); System.out.print("es"); System.out.println("genial!");`
    </enunciado>
    <A>
      genial!
    </A>
    <B>
      Java es genial!
    </B>
    <C>
      Java es genial!
    </C>
    <D>
      Java es genial!
    </D>
    <respuesta_correcta explicacion="El código imprime &quot;Java es genial!&quot; en una sola línea. `System.out.print` no añade una nueva línea, mientras que `System.out.println` sí lo hace al final.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el resultado de la expresión 10 % 3 en Java?
    </enunciado>
    <A>
      1
    </A>
    <B>
      0
    </B>
    <C>
      10
    </C>
    <D>
      3
    </D>
    <respuesta_correcta explicacion="El operador `%` devuelve el residuo de la división. En este caso, `10 % 3` da como resultado `1`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace el operador % en Java?
    </enunciado>
    <A>
      Compara dos valores
    </A>
    <B>
      Suma dos números
    </B>
    <C>
      Multiplica dos números
    </C>
    <D>
      Devuelve el residuo de una división
    </D>
    <respuesta_correcta explicacion="El operador `%` en Java devuelve el residuo de una división entre dos números.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué hace el operador += en Java?
    </enunciado>
    <A>
      Asigna un valor absoluto a una variable
    </A>
    <B>
      Resta un valor a una variable
    </B>
    <C>
      Suma un valor a una variable y asigna el resultado a esa misma variable
    </C>
    <D>
      Multiplica dos valores
    </D>
    <respuesta_correcta explicacion="El operador `+=` suma un valor a una variable y asigna el resultado a esa misma variable. Por ejemplo, `x += 5` es equivalente a `x = x + 5`.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si x = 5, ¿cuál es el valor de x después de ejecutar x++?
    </enunciado>
    <A>
      6
    </A>
    <B>
      4
    </B>
    <C>
      7
    </C>
    <D>
      5
    </D>
    <respuesta_correcta explicacion="El operador `x++` incrementa el valor de `x` en 1 después de usar su valor actual. Por lo tanto, si `x = 5`, después de `x++`, el valor de `x` será `6`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la diferencia entre x++ y ++x en Java?
    </enunciado>
    <A>
      No hay diferencia
    </A>
    <B>
      x++ siempre es más rápido
    </B>
    <C>
      x++ incrementa después de usar el valor, mientras que ++x incrementa antes de usar el valor
    </C>
    <D>
      ++x es solo para valores negativos
    </D>
    <respuesta_correcta explicacion="El operador `x++` incrementa el valor de `x` después de usarlo, mientras que `++x` incrementa el valor de `x` antes de usarlo.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué operador se usa para verificar si dos valores son iguales en una expresión lógica?
    </enunciado>
    <A>
      !=
    </A>
    <B>
      ==
    </B>
    <C>
      +=
    </C>
    <D>
      =
    </D>
    <respuesta_correcta explicacion="El operador `==` se utiliza para comparar si dos valores son iguales en una expresión lógica.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor tiene la variable resultado después de la siguiente operación? `int resultado = 20 / 4 * 2 + 3;`
    </enunciado>
    <A>
      15
    </A>
    <B>
      13
    </B>
    <C>
      10
    </C>
    <D>
      11
    </D>
    <respuesta_correcta explicacion="La operación se evalúa como `20 / 4 = 5`, luego `5 * 2 = 10`, y finalmente `10 + 3 = 13`. Por lo tanto, el valor de `resultado` es `13`.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de los siguientes operadores se usa para negar una expresión booleana?
    </enunciado>
    <A>
      &lt;&lt;
    </A>
    <B>
      %
    </B>
    <C>
      ||
    </C>
    <D>
      !
    </D>
    <respuesta_correcta explicacion="El operador `!` se utiliza para negar una expresión booleana, invirtiendo su valor.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Si `x = 10`, ¿qué resultado tiene `x -= 3;`?
    </enunciado>
    <A>
      x = 7
    </A>
    <B>
      x = 3
    </B>
    <C>
      x = 13
    </C>
    <D>
      x = 10
    </D>
    <respuesta_correcta explicacion="La operación `x -= 3` es equivalente a `x = x - 3`. Si `x` comienza con el valor `10`, el resultado será `7`.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué valor tiene la expresión `true || false` en Java?
    </enunciado>
    <A>
      null
    </A>
    <B>
      false
    </B>
    <C>
      true
    </C>
    <D>
      No se puede determinar
    </D>
    <respuesta_correcta explicacion="La expresión `true || false` evalúa a `true` porque el operador `||` (OR lógico) devuelve `true` si al menos una de las condiciones es verdadera.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es un algoritmo?
    </enunciado>
    <A>
      Una secuencia de instrucciones para resolver un problema
    </A>
    <B>
      Un conjunto de variables
    </B>
    <C>
      Un lenguaje de programación
    </C>
    <D>
      Un tipo de bucle en programación
    </D>
    <respuesta_correcta explicacion="Un algoritmo es una secuencia de pasos o instrucciones diseñadas para resolver un problema o realizar una tarea específica.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de estos ejemplos representa la conversión de pseudocódigo en código Java? Pseudocódigo: "Iniciar -&lt;definir variable x = 10 -&lt; mostrar x -&lt; Fin"
    </enunciado>
    <A>
      System.out.println(x);
    </A>
    <B>
      variable x
    </B>
    <C>
      int x = 10; System.out.println(x);
    </C>
    <D>
      print(x)
    </D>
    <respuesta_correcta explicacion="El pseudocódigo se traduce a `int x = 10; System.out.println(x);` en Java, donde se define una variable y se imprime su valor.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes opciones describe mejor un pseudocódigo?
    </enunciado>
    <A>
      Texto sin estructura
    </A>
    <B>
      Código en lenguaje Java
    </B>
    <C>
      Un diagrama de flujo
    </C>
    <D>
      Representación simplificada y detallada de los pasos de un algoritmo
    </D>
    <respuesta_correcta explicacion="El pseudocódigo es una representación simplificada y detallada de los pasos de un algoritmo, escrita en un lenguaje natural o semiformal.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes estructuras es común en un pseudocódigo?
    </enunciado>
    <A>
      if-else, for, while
    </A>
    <B>
      HTML tags
    </B>
    <C>
      Start, Process, End
    </C>
    <D>
      public static void
    </D>
    <respuesta_correcta explicacion="En pseudocódigo, las estructuras comunes incluyen &quot;Start&quot;, &quot;Process&quot; y &quot;End&quot; para representar el inicio, el proceso y el final de un algoritmo.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué es lo primero que se debe hacer antes de escribir un algoritmo en Java?
    </enunciado>
    <A>
      Configurar una base de datos
    </A>
    <B>
      Escribir un pseudocódigo para planificar los pasos
    </B>
    <C>
      Traducir el algoritmo a otro idioma
    </C>
    <D>
      Ejecutar el código
    </D>
    <respuesta_correcta explicacion="Escribir un pseudocódigo ayuda a planificar la lógica del algoritmo antes de implementarlo en un lenguaje de programación como Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la función del pseudocódigo en el desarrollo de un algoritmo?
    </enunciado>
    <A>
      Ayudar a los desarrolladores a visualizar la lógica antes de programar
    </A>
    <B>
      Evitar escribir código
    </B>
    <C>
      Hacer el código final más rápido
    </C>
    <D>
      Crear gráficos en tiempo real
    </D>
    <respuesta_correcta explicacion="El pseudocódigo permite a los desarrolladores visualizar y estructurar la lógica de un algoritmo antes de implementarlo en un lenguaje de programación.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué estructura de control de flujo se usa para tomar decisiones en Java?
    </enunciado>
    <A>
      if-else
    </A>
    <B>
      while
    </B>
    <C>
      switch
    </C>
    <D>
      for
    </D>
    <respuesta_correcta explicacion="La estructura `if-else` se utiliza para tomar decisiones en Java, ejecutando diferentes bloques de código según se cumpla o no una condición.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de los siguientes es un ejemplo de pseudocódigo para sumar dos números y mostrar el resultado?
    </enunciado>
    <A>
      Sumar dos números y mostrar el resultado
    </A>
    <B>
      Inicio -&lt; a = 5, b = 3 -&lt; c = a + b -&lt; Mostrar c -&lt; Fin
    </B>
    <C>
      if a + b then print c
    </C>
    <D>
      int a = 5; int b = 3; int c = a + b; System.out.println(c);
    </D>
    <respuesta_correcta explicacion="El pseudocódigo correcto es: &quot;Inicio -&lt; a = 5, b = 3 -&lt; c = a + b -&lt; Mostrar c -&lt; Fin&quot;, ya que describe los pasos de forma clara y estructurada.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      Al convertir un algoritmo en código Java, ¿cuál es el paso principal?
    </enunciado>
    <A>
      Cambiar todos los nombres de las variables
    </A>
    <B>
      Crear una interfaz de usuario
    </B>
    <C>
      Dividir el código en múltiples clases
    </C>
    <D>
      Traducir el pseudocódigo a instrucciones de Java utilizando sintaxis correcta
    </D>
    <respuesta_correcta explicacion="El paso principal al convertir un algoritmo en código Java es traducir el pseudocódigo a instrucciones de Java utilizando la sintaxis correcta.">
      D
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes es una práctica común en ejercicios de lógica básica en Java?
    </enunciado>
    <A>
      Definir solo variables estáticas
    </A>
    <B>
      Crear clases abstractas
    </B>
    <C>
      Utilizar estructuras condicionales y bucles para resolver problemas simples
    </C>
    <D>
      No usar métodos en absoluto
    </D>
    <respuesta_correcta explicacion="En ejercicios de lógica básica en Java, es común utilizar estructuras condicionales y bucles para resolver problemas simples, ya que permiten controlar el flujo del programa.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra clave se usa para heredar una clase en Java?
    </enunciado>
    <A>
      this
    </A>
    <B>
      extends
    </B>
    <C>
      implements
    </C>
    <D>
      inherit
    </D>
    <respuesta_correcta explicacion="La palabra clave 'extends' permite heredar una clase en Java, lo que significa que la nueva clase adquiere propiedades y métodos de la clase padre.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el tipo de dato utilizado para representar números decimales en Java?
    </enunciado>
    <A>
      int
    </A>
    <B>
      float
    </B>
    <C>
      boolean
    </C>
    <D>
      char
    </D>
    <respuesta_correcta explicacion="El tipo 'float' se usa en Java para almacenar números decimales de precisión simple.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de estas NO es una estructura de control en Java?
    </enunciado>
    <A>
      for
    </A>
    <B>
      switch
    </B>
    <C>
      repeat
    </C>
    <D>
      while
    </D>
    <respuesta_correcta explicacion="Java no tiene la estructura 'repeat'; las estructuras de control válidas incluyen 'for', 'while', y 'switch'.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método se ejecuta primero al iniciar un programa en Java?
    </enunciado>
    <A>
      start()
    </A>
    <B>
      run()
    </B>
    <C>
      main()
    </C>
    <D>
      init()
    </D>
    <respuesta_correcta explicacion="El método 'main()' es el punto de entrada de cualquier programa Java y se ejecuta primero al iniciar.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué significa JVM?
    </enunciado>
    <A>
      Java Virtual Machine
    </A>
    <B>
      Java Variable Memory
    </B>
    <C>
      Java Visual Mode
    </C>
    <D>
      Java Version Manager
    </D>
    <respuesta_correcta explicacion="JVM significa 'Java Virtual Machine', que es la máquina virtual que ejecuta programas Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es la salida de: System.out.println(3 + "4")?
    </enunciado>
    <A>
      7
    </A>
    <B>
      34
    </B>
    <C>
      Error
    </C>
    <D>
      43
    </D>
    <respuesta_correcta explicacion="En Java, concatenar un número con una cadena convierte el número a cadena, por lo que la salida es '34'.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué operador se usa para comparar dos valores en Java?
    </enunciado>
    <A>
      =
    </A>
    <B>
      ==
    </B>
    <C>
      !=
    </C>
    <D>
      equals
    </D>
    <respuesta_correcta explicacion="El operador '==' se utiliza para comparar si dos valores primitivos son iguales en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué estructura se utiliza para capturar errores en Java?
    </enunciado>
    <A>
      if-else
    </A>
    <B>
      try-catch
    </B>
    <C>
      switch
    </C>
    <D>
      do-while
    </D>
    <respuesta_correcta explicacion="La estructura 'try-catch' se utiliza para manejar excepciones y errores en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el modificador de acceso más restrictivo en Java?
    </enunciado>
    <A>
      private
    </A>
    <B>
      public
    </B>
    <C>
      protected
    </C>
    <D>
      default
    </D>
    <respuesta_correcta explicacion="El modificador 'private' es el más restrictivo, ya que solo permite el acceso dentro de la misma clase.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de estos NO es un tipo de dato primitivo en Java?
    </enunciado>
    <A>
      char
    </A>
    <B>
      String
    </B>
    <C>
      int
    </C>
    <D>
      boolean
    </D>
    <respuesta_correcta explicacion="'String' no es un tipo de dato primitivo en Java; es un objeto de la clase String.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué instrucción se usa para salir de un bucle en Java?
    </enunciado>
    <A>
      stop
    </A>
    <B>
      exit
    </B>
    <C>
      break
    </C>
    <D>
      return
    </D>
    <respuesta_correcta explicacion="La instrucción 'break' se utiliza para salir anticipadamente de un bucle en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué tipo de dato se usa para valores verdadero/falso en Java?
    </enunciado>
    <A>
      boolean
    </A>
    <B>
      int
    </B>
    <C>
      byte
    </C>
    <D>
      double
    </D>
    <respuesta_correcta explicacion="El tipo de dato 'boolean' se usa para representar valores verdadero o falso en Java.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra se utiliza para crear una instancia de clase en Java?
    </enunciado>
    <A>
      define
    </A>
    <B>
      init
    </B>
    <C>
      new
    </C>
    <D>
      create
    </D>
    <respuesta_correcta explicacion="La palabra 'new' se usa para crear una nueva instancia de una clase en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué paquete se importa para usar la clase ArrayList en Java?
    </enunciado>
    <A>
      java.utils
    </A>
    <B>
      java.list
    </B>
    <C>
      java.util
    </C>
    <D>
      java.collection
    </D>
    <respuesta_correcta explicacion="El paquete correcto para ArrayList es 'java.util'.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué significa POO en Java?
    </enunciado>
    <A>
      Programación Ordenada y Optimizada
    </A>
    <B>
      Programación Orientada a Objetos
    </B>
    <C>
      Procesamiento Óptimo de Objetos
    </C>
    <D>
      Programa Organizado de Objetos
    </D>
    <respuesta_correcta explicacion="POO significa 'Programación Orientada a Objetos', un paradigma central en Java.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el valor por defecto de un boolean en Java?
    </enunciado>
    <A>
      true
    </A>
    <B>
      false
    </B>
    <C>
      null
    </C>
    <D>
      0
    </D>
    <respuesta_correcta explicacion="El valor por defecto de un boolean en Java es 'false'.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál es el símbolo del operador OR lógico en Java?
    </enunciado>
    <A>
      &amp;&amp;
    </A>
    <B>
      !
    </B>
    <C>
      ||
    </C>
    <D>
      &amp;
    </D>
    <respuesta_correcta explicacion="El símbolo '||' representa el operador OR lógico en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué clase se usa para mostrar datos por consola en Java?
    </enunciado>
    <A>
      Scanner
    </A>
    <B>
      System
    </B>
    <C>
      System.out
    </C>
    <D>
      Console
    </D>
    <respuesta_correcta explicacion="'System.out' se usa para imprimir datos en la consola en Java.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Cuál de las siguientes es una interfaz en Java?
    </enunciado>
    <A>
      ArrayList
    </A>
    <B>
      Runnable
    </B>
    <C>
      Math
    </C>
    <D>
      StringBuilder
    </D>
    <respuesta_correcta explicacion="'Runnable' es una interfaz que define un solo método run(), usada para la ejecución de hilos.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué palabra reservada impide que una clase sea heredada en Java?
    </enunciado>
    <A>
      abstract
    </A>
    <B>
      final
    </B>
    <C>
      static
    </C>
    <D>
      const
    </D>
    <respuesta_correcta explicacion="La palabra clave 'final' evita que una clase pueda ser heredada.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué método convierte una cadena en un entero en Java?
    </enunciado>
    <A>
      parseInt()
    </A>
    <B>
      toInt()
    </B>
    <C>
      int()
    </C>
    <D>
      valueOfInt()
    </D>
    <respuesta_correcta explicacion="El método 'parseInt()' de la clase Integer convierte una cadena en un valor entero.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se imprime al ejecutar el siguiente código?
            public class Sobrecarga {
                void mostrar(int a) {
                    System.out.println("int");
                }
                void mostrar(double a) {
                    System.out.println("double");
                }
                public static void main(String[] args) {
                    Sobrecarga s = new Sobrecarga();
                    s.mostrar(5);
                }
            }
    </enunciado>
    <A>
      int
    </A>
    <B>
      double
    </B>
    <C>
      Error de compilación
    </C>
    <D>
      No imprime nada
    </D>
    <respuesta_correcta explicacion="El método `mostrar(int a)` es llamado porque el argumento `5` es un entero. Aunque hay una versión sobrecargada para `double`, Java elige la coincidencia exacta si está disponible.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se imprime al ejecutar el siguiente código?
            interface Animal {
                void sonido();
            }
            class Perro implements Animal {
                public void sonido() {
                    System.out.println("Guau");
                }
                void ladrar() {
                    System.out.println("El perro ladra");
                }
            }
            public class Test {
                public static void main(String[] args) {
                    Animal a = new Perro();
                    a.sonido();
                    // a.ladrar();  // Línea comentada
                }
            }
    </enunciado>
    <A>
      Guau
    </A>
    <B>
      El perro ladra
    </B>
    <C>
      Guau seguido de El perro ladra
    </C>
    <D>
      Error de compilación
    </D>
    <respuesta_correcta explicacion="El método `sonido()` se ejecuta e imprime &quot;Guau&quot;. Aunque el objeto es de tipo `Perro`, está referenciado como `Animal`, por lo que no se puede acceder directamente al método `ladrar()` sin hacer un casting. La línea que haría eso está comentada, por lo que no hay error.">
      A
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué se imprime al ejecutar el siguiente código?
            public class Prioridad {
                public static void main(String[] args) {
                    int a = 5;
                    int b = 10;
                    int c = a++ + --b;
                    System.out.println(c);
                }
            }
    </enunciado>
    <A>
      15
    </A>
    <B>
      14
    </B>
    <C>
      16
    </C>
    <D>
      13
    </D>
    <respuesta_correcta explicacion="Primero se evalúa `--b` (predecremento), bajando `b` a 9, y luego `a++` (postincremento), usando 5 antes de incrementarlo a 6. La suma es 5 + 9 = 14.">
      B
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      ¿Qué sucede al ejecutar este código?
            public class Excepcion {
                public static void main(String[] args) {
                    try {
                        int x = 10 / 0;
                        System.out.println("Resultado: " + x);
                    } catch (ArithmeticException e) {
                        System.out.println("Error aritmético");
                    } finally {
                        System.out.println("Finalizado");
                    }
                }
            }
    </enunciado>
    <A>
      Resultado: 0
    </A>
    <B>
      Error aritmético
    </B>
    <C>
      Error aritmético seguido de Finalizado
    </C>
    <D>
      Solo Finalizado
    </D>
    <respuesta_correcta explicacion="Se produce una excepción de tipo `ArithmeticException` por la división entre cero. El bloque `catch` imprime &quot;Error aritmético&quot;, y el bloque `finally` siempre se ejecuta, imprimiendo &quot;Finalizado&quot;.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En el siguiente código, ¿qué método falta para que la clase compile correctamente?

            abstract class Figura {
                abstract double area();
            }
            class Circulo extends Figura {
                double radio;
                Circulo(double radio) {
                    this.radio = radio;
                }
                // Falta el método area()
            }
    </enunciado>
    <A>
      equals()
    </A>
    <B>
      toString()
    </B>
    <C>
      area(), de lo contrario hay error
    </C>
    <D>
      Ninguno, es opcional
    </D>
    <respuesta_correcta explicacion="La clase `Circulo` debe implementar el método `area()` porque es abstracto en la clase `Figura`. Si no lo hace, la clase `Circulo` también debería declararse como abstracta; de lo contrario, se producirá un error de compilación.">
      C
    </respuesta_correcta>
  </pregunta>
  <pregunta>
    <enunciado>
      En el siguiente código, ¿qué método falta para que la clase compile correctamente?

                abstract class Figura {
                    abstract double area();
                }
                class Cuadrado extends Figura {
                    // Falta el método area()
                }
    </enunciado>
    <A>
      Ninguno, es opcional
    </A>
    <B>
      toString
    </B>
    <C>
      area(), de lo contrario hay error
    </C>
    <D>
      equals
    </D>
    <respuesta_correcta explicacion="La clase `Cuadrado` debe implementar el método `area()` porque está declarado como abstracto en la clase `Figura`. Si no lo implementa, la clase `Cuadrado` también debería ser abstracta; de lo contrario, se producirá un error de compilación.">
      C
    </respuesta_correcta>
  </pregunta>
</documento>