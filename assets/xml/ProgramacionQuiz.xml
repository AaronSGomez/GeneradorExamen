<documento><pregunta><enunciado>¿Qué clase se utiliza para leer datos desde consola?</enunciado><A>InputReader</A><B>Scanner</B><C>ConsoleReader</C><D>BufferReader</D><respuesta_correcta explicacion="Scanner es la clase comúnmente usada para leer datos desde consola en Java.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué palabra clave se utiliza para declarar una constante en Java?</enunciado><A>const</A><B>final</B><C>static</C><D>constant</D><respuesta_correcta explicacion="La palabra 'final' se utiliza para declarar constantes en Java.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el tipo de datos para números enteros más pequeño en Java?</enunciado><A>byte</A><B>short</B><C>int</C><D>long</D><respuesta_correcta explicacion="El tipo 'byte' usa solo 1 byte de memoria y va de -128 a 127.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el valor predeterminado de un boolean en Java?</enunciado><A>true</A><B>null</B><C>false</C><D>0</D><respuesta_correcta explicacion="En Java, las variables boolean por defecto se inicializan como false.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué operador se utiliza para comparar igualdad en Java?</enunciado><A>=</A><B>==</B><C>equals</C><D>!=</D><respuesta_correcta explicacion="'==' se usa para comparar valores primitivos. Para objetos, se recomienda usar equals().">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes no es una palabra reservada en Java?</enunciado><A>static</A><B>try</B><C>new</C><D>define</D><respuesta_correcta explicacion="'define' no es una palabra reservada en Java, aunque lo es en otros lenguajes como C.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué clase se utiliza para leer datos desde consola?</enunciado><A>InputReader</A><B>Scanner</B><C>ConsoleReader</C><D>BufferReader</D><respuesta_correcta explicacion="Scanner es la clase comúnmente usada para leer datos desde consola en Java.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes estructuras es una clase contenedora?</enunciado><A>Array</A><B>List</B><C>int</C><D>char</D><respuesta_correcta explicacion="List es una interfaz de colección que representa una lista ordenada de elementos.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la salida de System.out.println(3 + "4")?</enunciado><A>7</A><B>34</B><C>Error</C><D>"7"</D><respuesta_correcta explicacion="Se concatena 3 con el String &quot;4&quot;, dando como resultado &quot;34&quot;.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué significa que Java sea un lenguaje fuertemente tipado?</enunciado><A>Que se puede cambiar el tipo de una variable libremente.</A><B>Que se deben declarar todos los tipos de datos.</B><C>Que es sensible a mayúsculas.</C><D>Que no se pueden usar tipos primitivos.</D><respuesta_correcta explicacion="En Java todos los tipos deben ser declarados explícitamente y no se permite el cambio de tipo implícito en la mayoría de los casos.">B</respuesta_correcta></pregunta><pregunta><enunciado>Los operadores lógicos operan con valores booleanos, resultando:</enunciado><A>Valores enteros.</A><B>Valores enteros y booleanos.</B><C>Otros tipos de valores.</C><D>Solo valores booleanos.</D><respuesta_correcta explicacion="Los operadores lógicos trabajan únicamente con valores booleanos (true o false).">D</respuesta_correcta></pregunta><pregunta><enunciado>La evaluación de una expresión relacional puede generar un valor de tipo:</enunciado><A>Entero</A><B>Real</B><C>Booleano</C><D>Todos los anteriores</D><respuesta_correcta explicacion="Las expresiones relacionales devuelven un valor booleano (true o false).">C</respuesta_correcta></pregunta><pregunta><enunciado>La expresión 3==3 &amp;&amp; 2&lt;3 &amp;&amp; 1!=2 resulta:</enunciado><A>Cierto</A><B>Falso</B><C>No se puede evaluar</C><D>No genera un booleano, ya que la expresión es aritmética</D><respuesta_correcta explicacion="Todas las comparaciones son verdaderas, por tanto el resultado es true (cierto).">A</respuesta_correcta></pregunta><pregunta><enunciado>La siguiente expresión, donde interviene la variable booleana a: 3!=3 || a || 1&lt;2, resulta:</enunciado><A>Dependerá del valor a</A><B>Cierto</B><C>Falso</C><D>No se puede evaluar</D><respuesta_correcta explicacion="Aunque 3!=3 es falso, 1&amp;;2 es verdadero, por lo que el resultado es true (corto circuito lógico).">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el valor de la variable x después de ejecutar el siguiente código en Java?
            int x = 5;
            x += 3;</enunciado><A>5</A><B>3</B><C>8</C><D>15</D><respuesta_correcta explicacion="El operador += suma el valor de la derecha al de la izquierda: x = 5 + 3 = 8.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el resultado de la siguiente expresión lógica en Java?
            (4 &gt; 3) &amp;&amp; (2 &lt; 5)</enunciado><A>true</A><B>false</B><C>4</C><D>Error de compilación</D><respuesta_correcta explicacion="Ambas comparaciones son verdaderas, por lo tanto el resultado del operador &amp;&amp; también es true.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el valor de `resultado` después de ejecutar este código?
            int a = 10;
            int b = 4;
            int resultado = a % b;</enunciado><A>0</A><B>2</B><C>4</C><D>6</D><respuesta_correcta explicacion="El operador % devuelve el residuo de la división: 10 % 4 = 2.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el valor de `resultado` después de ejecutar este código?
            int a = 10;
            int b = 4;
            int resultado = a % b;</enunciado><A>0</A><B>2</B><C>4</C><D>6</D><respuesta_correcta explicacion="El operador % devuelve el residuo de la división: 10 % 4 = 2.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué imprimirá este código Java?
            int x = 3;
            if(x == 3) {
            System.out.println("Hola");
            }</enunciado><A>Hola</A><B>Nada</B><C>Error de compilación</C><D>3</D><respuesta_correcta explicacion="La condición x == 3 es verdadera, así que se ejecuta el bloque y se imprime &quot;Hola&quot;.">A</respuesta_correcta></pregunta><pregunta><enunciado>Elige los valores de las variables enteras (a, b y c) que permiten que la evaluación de la siguiente expresión sea cierta: a&lt;b &amp;&amp; b!=c &amp;&amp; b&lt;=c:</enunciado><A>a = 1, b = 1, c = 2</A><B>a = 2, b = 1, c = 2</B><C>a = 1, b = 2, c = 2</C><D>a = 1, b = 2, c = 3</D><respuesta_correcta explicacion="1&lt;2 (true), 2!=3 (true), 2&lt;=3 (true). Esta es la única opción que cumple todas las condiciones.">D</respuesta_correcta></pregunta><pregunta><enunciado>El bloque de instrucciones de una sentencia if se ejecutará:</enunciado><A>Siempre</A><B>Nunca</B><C>Dependerá de la evaluación de la expresión utilizada</C><D>Todas las respuestas anteriores son correctas</D><respuesta_correcta explicacion="Solo se ejecuta si la condición del if se evalúa como true.">C</respuesta_correcta></pregunta><pregunta><enunciado>En una sentencia if-else los bloques de instrucciones (bloque true y bloque false) pueden ejecutarse:</enunciado><A>Simultáneamente</A><B>Es posible, dependiendo de la condición utilizada, que no se ejecute ninguno</B><C>Siempre se ejecutará al menos uno y son excluyentes</C><D>Todas las anteriores son incorrectas</D><respuesta_correcta explicacion="En un if-else siempre se ejecuta uno de los dos bloques, pero nunca ambos.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué valor toma la variable a en la siguiente expresión: a = 1&lt;2 ? 3 : 4?</enunciado><A>1</A><B>2</B><C>3</C><D>4</D><respuesta_correcta explicacion="Como 1&lt;2 es true, se ejecuta el primer valor: 3.">C</respuesta_correcta></pregunta><pregunta><enunciado>La cláusula default en la sentencia switch es:</enunciado><A>Obligatoria y tiene que ser la última que aparezca</A><B>Obligatoria, pero puede aparecer en cualquier lugar</B><C>Opcional y tiene que ser la última que aparezca</C><D>Opcional y puede usarse en cualquier lugar</D><respuesta_correcta explicacion="default es opcional y puede colocarse en cualquier lugar del switch.">D</respuesta_correcta></pregunta><pregunta><enunciado>Realiza una traza del siguiente fragmento de código y selecciona el valor que toma finalmente la variable a:
            a = 0;
            switch (a + 1) {
            case 0:
            a = 2;
            case 1:
            a = 3;
            case 2:
            a++;
            break;
            case 3:
            a--;
            break;
            }</enunciado><A>a = 2.</A><B>a= 3.</B><C>a = null;</C><D>a = 4;</D><respuesta_correcta explicacion="a comienza con el valor 0. Al evaluar switch (a + 1), el resultado es 1, por lo que entra en el case 1. y continua por la ausencia de break. suma 1 y sale resultado a = 4">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el operador lógico 'AND' en Java?</enunciado><A>&amp;</A><B>&amp;&amp;</B><C>and</C><D>||</D><respuesta_correcta explicacion="En Java '&amp;&amp;' es el operador lógico AND que evalúa condiciones booleanas.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción se usa para ejecutar código solo si una condición es verdadera?</enunciado><A>while</A><B>for</B><C>if</C><D>switch</D><respuesta_correcta explicacion="'if' evalúa condiciones booleanas para decidir si ejecutar un bloque de código.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un bucle do-while se ejecutará, como mínimo:</enunciado><A>Cero veces</A><B>Una vez</B><C>Infinitas veces</C><D>Ninguna de las opciones anteriores es correcta</D><respuesta_correcta explicacion="El bucle do-while ejecuta primero el bloque de código y luego evalúa la condición. Por tanto, se ejecuta al menos una vez.">B</respuesta_correcta></pregunta><pregunta><enunciado>El uso de llaves para encerrar el bloque de instrucciones de un bucle:</enunciado><A>Es siempre opcional</A><B>Es opcional si el bloque está formado por una única instrucción</B><C>En cualquier caso, su uso es obligatorio</C><D>El programador decide su uso</D><respuesta_correcta explicacion="Si el bucle contiene solo una instrucción, las llaves son opcionales, aunque su uso es recomendable para claridad.">B</respuesta_correcta></pregunta><pregunta><enunciado>La instrucción que permite detener completamente las iteraciones de un bucle es:</enunciado><A>stop</A><B>break</B><C>continue</C><D>finish</D><respuesta_correcta explicacion="La instrucción `break` finaliza inmediatamente la ejecución del bucle en curso.">B</respuesta_correcta></pregunta><pregunta><enunciado>En un bucle for, la inicialización, condición e incremento son:</enunciado><A>Todos obligatorios</A><B>Todos opcionales</B><C>La inicialización siempre es obligatoria</C><D>La condición siempre es obligatoria</D><respuesta_correcta explicacion="Técnicamente, los tres componentes del bucle for son opcionales en Java, aunque se usan por claridad y control.">B</respuesta_correcta></pregunta><pregunta><enunciado>En el caso de que una función devuelva un valor, ¿cuál es la recomendación con respecto a la instrucción return?</enunciado><A>Utilizar tantos como hagan falta</A><B>Emplear tantos como hagan falta, pero siempre que se encuentren en bloques de instrucciones distintas</B><C>Usar solo uno</C><D>Utilizar solo uno, que será siempre la primera instrucción de la función</D><respuesta_correcta explicacion="Usar un solo `return` mejora la legibilidad del código y facilita el mantenimiento y la depuración.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuáles de las siguientes operaciones se pueden implementar fácilmente mediante funciones recursivas?</enunciado><A>an = a × an-1</A><B>esPar(n) = esImpar(n − 1) y esImpar(n) = esPar(n − 1)</B><C>suma(a, b) = suma(a + 1, b − 1)</C><D>Todas las respuestas anteriores son correctas</D><respuesta_correcta explicacion="Todas estas definiciones son recursivas y pueden implementarse eficazmente con funciones recursivas.">D</respuesta_correcta></pregunta><pregunta><enunciado>En los identificadores de las funciones, al igual que en los de las variables, se recomienda utilizar la siguiente nomenclatura:</enunciado><A>suma_notas_alumnos()</A><B>sumanotasalumnos()</B><C>SumaNotasAlumnos()</C><D>sumaNotasAlumnos()</D><respuesta_correcta explicacion="La convención de Java para nombres de métodos es camelCase: se empieza en minúscula y cada palabra adicional inicia con mayúscula.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué palabra clave define un método que no devuelve valor?</enunciado><A>void</A><B>null</B><C>return</C><D>static</D><respuesta_correcta explicacion="'void' se utiliza para indicar que un método no retorna ningún valor.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo se llama un método dentro de una clase en Java?</enunciado><A>función</A><B>subrutina</B><C>método</C><D>operador</D><respuesta_correcta explicacion="En Java, una función que está dentro de una clase se denomina 'método'.">C</respuesta_correcta></pregunta><pregunta><enunciado>Los parámetros en la llamada a una función en Java pueden ser opcionales si:</enunciado><A>Todos los parámetros son del mismo tipo</A><B>Todos los parámetros son de distinto tipo</B><C>Nunca pueden ser opcionales</C><D>Siempre que el tipo devuelto no sea void</D><respuesta_correcta explicacion="En Java, no existen parámetros opcionales de forma directa. Hay que simularlo con sobrecarga de métodos.">C</respuesta_correcta></pregunta><pregunta><enunciado>Una variable local (declarada dentro de una función) puede usarse:</enunciado><A>En cualquier lugar del código</A><B>Solo dentro de main()</B><C>Solo en la función donde se ha declarado</C><D>Ninguna de las opciones anteriores es correcta</D><respuesta_correcta explicacion="Las variables locales solo existen dentro del bloque donde fueron declaradas.">C</respuesta_correcta></pregunta><pregunta><enunciado>El tipo devuelto de todas las funciones definidas en nuestro programa tiene que ser siempre:</enunciado><A>int</A><B>double</B><C>void</C><D>Ninguna de las opciones anteriores es correcta</D><respuesta_correcta explicacion="El tipo de retorno puede ser cualquiera, no solo los mencionados. Incluso pueden devolver objetos o listas.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción permite a una función devolver un valor?</enunciado><A>value</A><B>return</B><C>static</C><D>function</D><respuesta_correcta explicacion="'return' es la instrucción que se utiliza para devolver un valor desde una función.">B</respuesta_correcta></pregunta><pregunta><enunciado>La forma de distinguir entre dos o más funciones sobrecargadas es:</enunciado><A>Mediante su nombre</A><B>Mediante el tipo devuelto</B><C>Mediante el nombre de sus parámetros</C><D>Mediante su lista de parámetros: número o tipos</D><respuesta_correcta explicacion="Java permite la sobrecarga si cambian el número o tipo de los parámetros, no el nombre ni el tipo de retorno.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la definición de una función recursiva?</enunciado><A>Es aquella que se invoca desde dentro de su propio bloque de instrucciones</A><B>Es aquella cuyo nombre permite la sobrecarga y además realiza alguna comprobación mediante if</B><C>Es aquella cuyo bloque de instrucciones utiliza alguna sentencia if (lo que llamamos caso base)</C><D>Es aquella que genera un bucle infinito</D><respuesta_correcta explicacion="Una función recursiva es aquella que se llama a sí misma dentro de su propia definición.">A</respuesta_correcta></pregunta><pregunta><enunciado>El paso de parámetros a una función en Java es siempre:</enunciado><A>Un paso de parámetros por copia</A><B>Un paso de parámetros por desplazamiento</B><C>Un paso de parámetros recursivo</C><D>Un paso de parámetros funcional</D><respuesta_correcta explicacion="En Java, los tipos primitivos se pasan por valor (copia). En objetos se pasa una copia de la referencia.">A</respuesta_correcta></pregunta><pregunta><enunciado>La comparación del contenido (los elementos) de dos tablas se realiza utilizando:</enunciado><A>Arrays.compare()</A><B>El operador ==</B><C>Arrays.equals()</C><D>Arrays.same()</D><respuesta_correcta explicacion="El método `Arrays.equals()` compara el contenido de dos arrays elemento por elemento. El operador `==` compara referencias, no contenido.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué condición tiene que cumplir una tabla para que podamos realizar búsquedas dicotómicas en ella?</enunciado><A>Que esté ordenada</A><B>Que esté ordenada y sea una tabla de enteros</B><C>Que no esté ordenada</C><D>No importa si la tabla está ordenada, lo realmente importante es que sea de algún tipo numérico</D><respuesta_correcta explicacion="La búsqueda binaria o dicotómica solo es válida si el array está previamente ordenado. No importa el tipo de datos.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la principal diferencia entre Arrays.copyOf() y System.arraycopy()?</enunciado><A>No existe diferencia alguna, ambos métodos son idénticos</A><B>Arrays.copyOf() copia mientras System.arraycopy() copia y compara</B><C>Arrays.copyOf() copia entre tablas existentes mientras System.arraycopy() crea una nueva tabla y copia en ella</C><D>Arrays.copyOf() crea una nueva tabla y copia en ella mientras System.arraycopy() solo copia entre tablas ya creadas</D><respuesta_correcta explicacion="`Arrays.copyOf()` crea automáticamente un nuevo array y copia los elementos. `System.arraycopy()` copia entre arrays ya existentes.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo se declara un array de enteros en Java?</enunciado><A>int array = new int[];</A><B>int[] array;</B><C>int array[] = {};</C><D>array int = new array();</D><respuesta_correcta explicacion="La forma correcta de declarar un array en Java es `int[] nombreArray;`, con el tipo seguido por corchetes.">B</respuesta_correcta></pregunta><pregunta><enunciado>Una tabla puede almacenar datos de distintos tipos, como por ejemplo enteros, booleanos, reales, etcétera:</enunciado><A>Cierto, las tablas siempre pueden almacenar datos de distintos tipos</A><B>Falso, las tablas solo pueden almacenar datos de un único tipo</B><C>Puede almacenar datos de distintos tipos siempre que estos sean numéricos</C><D>Puede almacenar datos de distintos tipos siempre que la longitud de los datos sea idéntica</D><respuesta_correcta explicacion="En Java, los arrays son homogéneos: todos los elementos deben ser del mismo tipo.">B</respuesta_correcta></pregunta><pregunta><enunciado>En Java, la numeración de los índices que determina la identificación de cada elemento de una tabla comienza en:</enunciado><A>Cero</A><B>Uno</B><C>Depende del tipo de dato de la tabla</C><D>Es configurable por el usuario</D><respuesta_correcta explicacion="Los arrays en Java comienzan siempre en el índice 0.">A</respuesta_correcta></pregunta><pregunta><enunciado>Si en una tabla de 10 elementos utilizamos el elemento con índice 11 (que se encuentra fuera de rango):</enunciado><A>Al salir del rango de la longitud, Java redimensiona la tabla de forma automática</A><B>No es posible y produce un error</B><C>Las tablas tienen un comportamiento circular y utilizar el índice 11 es idéntico a utilizar el índice 1</C><D>Ninguna de las anteriores respuestas es cierta</D><respuesta_correcta explicacion="Acceder a un índice fuera del rango produce una excepción `ArrayIndexOutOfBoundsException`.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué método de la clase Arrays permite realizar una búsqueda dicotómica en una tabla?</enunciado><A>Arrays.search()</A><B>Arrays.find()</B><C>Arrays.binarySearch()</C><D>Cualquiera de los métodos anteriores realiza una búsqueda</D><respuesta_correcta explicacion="El método `Arrays.binarySearch()` realiza una búsqueda binaria, pero solo si el array está previamente ordenado.">C</respuesta_correcta></pregunta><pregunta><enunciado>Con respecto a las tablas, el operador new:</enunciado><A>Destruye, crea y redimensiona tablas</A><B>Destruye y crea tablas</B><C>Crea tablas</C><D>Destruye las tablas</D><respuesta_correcta explicacion="El operador `new` se usa para crear nuevas instancias de arrays, no para destruir.">C</respuesta_correcta></pregunta><pregunta><enunciado>La forma de invocar al recolector de basura es:</enunciado><A>Mediante System.garbageCollector()</A><B>Mediante el operador new</B><C>Mediante Arrays.garbageCollector()</C><D>Ninguna de las anteriores respuestas es correcta</D><respuesta_correcta explicacion="El recolector de basura puede sugerirse con `System.gc()`, pero no se garantiza su ejecución inmediata.">D</respuesta_correcta></pregunta><pregunta><enunciado>La forma de conocer la longitud de una tabla t es mediante:</enunciado><A>t.size</A><B>t.elements</B><C>t.length</C><D>Arrays.size(t)</D><respuesta_correcta explicacion="En Java, la propiedad `length` permite conocer el tamaño de un array.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el índice del primer elemento de un array en Java?</enunciado><A>0</A><B>1</B><C>-1</C><D>depende</D><respuesta_correcta explicacion="Los arrays en Java siempre comienzan en el índice 0.">A</respuesta_correcta></pregunta><pregunta><enunciado>La forma de concatenar dos cadenas es mediante:</enunciado><A>El operador +</A><B>El operador +=</B><C>El método concat()</C><D>Todas permiten concatenar cadenas</D><respuesta_correcta explicacion="En Java puedes concatenar cadenas usando `+`, `+=` o `concat()`; todas son válidas para unir Strings.">D</respuesta_correcta></pregunta><pregunta><enunciado>El método que permite eliminar los caracteres blancos del principio y el final de una cadena es:</enunciado><A>isWhiteSpace()</A><B>deleteWhiteSpace()</B><C>strip()</C><D>stripLeading()</D><respuesta_correcta explicacion="`strip()` elimina los espacios en blanco al inicio y al final de la cadena, incluido soporte para Unicode.">C</respuesta_correcta></pregunta><pregunta><enunciado>Existe una relación entre las cadenas (clase String) y las tablas de caracteres (char[]). ¿Qué métodos permiten convertir un String en un char[]?</enunciado><A>toCharArray()</A><B>valueOf()</B><C>convertString()</C><D>empty()</D><respuesta_correcta explicacion="`toCharArray()` convierte una cadena String en un array de caracteres (char[]).">A</respuesta_correcta></pregunta><pregunta><enunciado>En Java, al igual que en otros muchos lenguajes de programación, las secuencias de escape se escriben mediante:</enunciado><A>Dos puntos (:)</A><B>El carácter U mayúscula (U)</B><C>El carácter u minúscula (u)</C><D>Una barra invertida (\)</D><respuesta_correcta explicacion="Las secuencias de escape en Java usan la barra invertida `\`, como en `\n`, `\t`, etc.">D</respuesta_correcta></pregunta><pregunta><enunciado>La clase Character se encuentra ubicada en el paquete:</enunciado><A>java.util</A><B>java.character</B><C>java.lang</C><D>java.unicode</D><respuesta_correcta explicacion="La clase `Character` pertenece al paquete `java.lang`, que se importa automáticamente.">C</respuesta_correcta></pregunta><pregunta><enunciado>La aritmética de caracteres permite que exista una fuerte relación entre el tipo char y el tipo int. Sabiendo que el carácter ‘a’ tiene una representación numérica de 0x61, ¿cómo conseguiremos mostrar el carácter ‘i’ por consola, a partir de la siguiente variable?
            int codepoint = 0x61;</enunciado><A>System.out.println((char)(codepoint + '8'));</A><B>System.out.println((char)(codepoint - '8'));</B><C>System.out.println((char)(codepoint - 8));</C><D>System.out.println((char)(codepoint + 8));</D><respuesta_correcta explicacion="'a' (0x61) más 8 en valor decimal nos da 'i'. El casting `(char)` convierte el valor numérico en carácter.">D</respuesta_correcta></pregunta><pregunta><enunciado>Marca la opción que devuelve true:</enunciado><A>Character.isLetter('2');</A><B>Character.isUpperCase('2');</B><C>Character.isLowerCase('2');</C><D>Character.isLetterOrDigit('2');</D><respuesta_correcta explicacion="'2' no es letra, pero sí es dígito. `isLetterOrDigit()` devuelve true si el carácter es letra o número.">D</respuesta_correcta></pregunta><pregunta><enunciado>Señala qué opción es cierta:</enunciado><A>‘a’ es un carácter</A><B>‘a’ es una cadena de caracteres</B><C>“a” es un carácter</C><D>Todas las opciones anteriores son ciertas</D><respuesta_correcta explicacion="'a' entre comillas simples es un `char`. &quot;a&quot; (comillas dobles) es un String, por lo tanto no es un carácter.">A</respuesta_correcta></pregunta><pregunta><enunciado>La forma correcta de comparar alfabéticamente dos cadenas es mediante:</enunciado><A>El operador ==</A><B>El método equal() de String</B><C>El método equal() de Character</C><D>Todas permiten comparar dos cadenas</D><respuesta_correcta explicacion="En realidad, el método correcto es `equals()` de la clase String, no `equal()` ni el operador `==`.">B</respuesta_correcta></pregunta><pregunta><enunciado>La forma de extraer el cuarto carácter de la cadena contenida en la variable cad es mediante:</enunciado><A>cad.indexOf(3)</A><B>cad.charAt(3)</B><C>cad.position(3)</C><D>cad.extract(3)</D><respuesta_correcta explicacion="`charAt(3)` accede al carácter en la posición 4, ya que los índices comienzan en 0.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué clase se utiliza para trabajar con cadenas en Java?</enunciado><A>char</A><B>Character</B><C>String</C><D>Text</D><respuesta_correcta explicacion="La clase `String` permite manipular secuencias de texto en Java.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el método para obtener la longitud de una cadena?</enunciado><A>length()</A><B>size()</B><C>getLength()</C><D>count()</D><respuesta_correcta explicacion="`length()` devuelve el número de caracteres que tiene un objeto `String`.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué palabra clave se usa para definir una clase en Java?</enunciado><A>object</A><B>define</B><C>class</C><D>type</D><respuesta_correcta explicacion="La palabra clave `class` se utiliza para declarar una nueva clase en Java.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué tipo de método se llama sin necesidad de crear una instancia?</enunciado><A>privado</A><B>void</B><C>abstracto</C><D>estático</D><respuesta_correcta explicacion="Los métodos `static` se pueden invocar directamente desde la clase, sin necesidad de crear un objeto.">D</respuesta_correcta></pregunta><pregunta><enunciado>Dos clases se consideran vecinas siempre y cuando:</enunciado><A>Sean visibles</A><B>Ambas dispongan del mismo número de constructores</B><C>Pertenezcan al mismo paquete</C><D>Todo lo anterior ha de cumplirse para que dos clases sean vecinas</D><respuesta_correcta explicacion="Las clases se consideran vecinas si pertenecen al mismo paquete.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un miembro cuyo modificador de acceso es private será visible desde:</enunciado><A>Todas las clases vecinas</A><B>Todas las clases externas</B><C>Es indistinto el paquete, pero será visible siempre que se importe la clase que lo contiene</C><D>Ninguna de las respuestas anteriores</D><respuesta_correcta explicacion="Los miembros `private` solo son accesibles dentro de la clase donde se declaran.">D</respuesta_correcta></pregunta><pregunta><enunciado>Si desde un constructor queremos invocar a otro constructor de la misma clase, tendremos que usar:</enunciado><A>set()</A><B>get()</B><C>this()</C><D>this.</D><respuesta_correcta explicacion="`this()` se utiliza para llamar a otro constructor de la misma clase.">C</respuesta_correcta></pregunta><pregunta><enunciado>Si por error dejamos un objeto sin ninguna referencia, siempre podremos volver a referenciarlo mediante:</enunciado><A>La referencia this</A><B>La referencia null</B><C>Utilizando new</C><D>Es imposible</D><respuesta_correcta explicacion="Si no existen referencias a un objeto, este es elegible para recolección de basura y no puede ser accedido nuevamente.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué hace el operador new?</enunciado><A>Construye un objeto, invoca al constructor y devuelve su referencia</A><B>Construye un objeto, comprueba que su clase esté importada y devuelve su referencia</B><C>Busca en la memoria un objeto del mismo tipo, invoca al constructor y devuelve su referencia</C><D>Busca en memoria un objeto del mismo tipo y devuelve su referencia</D><respuesta_correcta explicacion="El operador `new` crea una nueva instancia de una clase e invoca su constructor.">A</respuesta_correcta></pregunta><pregunta><enunciado>Cuando hablamos de miembros de una clase, nos estamos refiriendo a:</enunciado><A>Todos los atributos</A><B>Todos los métodos</B><C>Todos los atributos y métodos, indistintamente de los modificadores de acceso utilizados</C><D>Todos los atributos y métodos que son visibles por sus clases vecinas</D><respuesta_correcta explicacion="Se consideran miembros todos los atributos y métodos definidos en una clase.">C</respuesta_correcta></pregunta><pregunta><enunciado>En la definición de una clase, los únicos modificadores de acceso que se pueden utilizar son:</enunciado><A>public</A><B>public y el modificador de acceso por defecto</B><C>public, el modificador de acceso por defecto y private</C><D>El modificador class</D><respuesta_correcta explicacion="Una clase en Java puede ser `public` o tener acceso por defecto (sin modificador). `private` no se permite para clases top-level.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué diferencia un atributo estático definido en una clase de otro que no lo es?</enunciado><A>El atributo estático es visible por todas las clases vecinas, mientras que el no estático solo será visible para las clases que usen importación</A><B>Solo existe una copia del atributo estático en la clase, mientras que el atributo no estático tendrá una copia en cada uno de los objetos</B><C>Existe una copia del atributo estático en todos y cada uno de los objetos, mientras que del atributo no estático solo existe una copia en la clase</C><D>Ambos disponen de copias en cada objeto, pero el atributo no estático es accesible mediante la clase y el no estático es accesible mediante los objetos</D><respuesta_correcta explicacion="Los atributos estáticos pertenecen a la clase y solo hay una copia compartida, mientras que los no estáticos son propios de cada objeto.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué efecto tienen las siguientes líneas de código?
            Cliente c;
            c.nombre = "Pepita";</enunciado><A>Inicializa el atributo nombre de Cliente con el valor «Pepita»</A><B>Invoca al constructor y posteriormente asigna el valor «Pepita» al atributo nombre, siempre y cuando este sea público</B><C>Si el atributo nombre es público, se le asigna un valor, pero si el atributo es privado, producirá un error</C><D>Siempre produce un error</D><respuesta_correcta explicacion="`Cliente c;` declara una referencia pero no crea un objeto. No se puede acceder a atributos sin instanciar con `new`.">D</respuesta_correcta></pregunta><pregunta><enunciado>La ocultación de atributos puede definirse como:</enunciado><A>El proceso en el que un atributo pasa de ser público a privado</A><B>El proceso en el que se define una variable local (en un método) con el mismo identificador que un atributo</B><C>El proceso en el que un atributo estático deja de serlo</C><D>Todas las respuestas anteriores son correctas</D><respuesta_correcta explicacion="La ocultación ocurre cuando una variable local tiene el mismo nombre que un atributo de clase, ocultándolo dentro de su bloque.">B</respuesta_correcta></pregunta><pregunta><enunciado>La selección dinámica de métodos:</enunciado><A>Se produce cuando una variable cambia de valor durante la ejecución de un programa</A><B>Es el cambio de tipo de una variable en tiempo de ejecución</B><C>Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución</C><D>Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución</D><respuesta_correcta explicacion="Esto se llama polimorfismo. Se ejecuta el método correspondiente al tipo real del objeto, no al tipo de la variable.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?</enunciado><A>Sirve para llamar al constructor de la superclase</A><B>Sirve para invocar un método escrito más arriba en el código</B><C>Sirve para llamar a cualquier método de la superclase</C><D>Sirve para hacer referencia a un atributo de la superclase</D><respuesta_correcta explicacion="`super()` se usa para invocar explícitamente al constructor de la superclase desde una subclase.">A</respuesta_correcta></pregunta><pregunta><enunciado>Sobre una subclase es correcto afirmar que:</enunciado><A>Tiene menos atributos que su superclase</A><B>Tiene menos miembros que su superclase</B><C>Hereda los miembros no privados de su superclase</C><D>Hereda todos los miembros de su superclase</D><respuesta_correcta explicacion="Una subclase hereda los miembros públicos y protegidos, pero no los privados.">C</respuesta_correcta></pregunta><pregunta><enunciado>En relación con las clases abstractas es correcto señalar que:</enunciado><A>Implementan todos sus métodos</A><B>No implementan ningún método</B><C>No tienen atributos</C><D>Tienen algún método abstracto</D><respuesta_correcta explicacion="Las clases abstractas pueden tener métodos implementados, pero deben incluir al menos un método abstracto.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿En qué consiste la sustitución u overriding?</enunciado><A>En sustituir un método heredado por otro implementado en la propia clase</A><B>En sustituir un atributo por otro del mismo nombre</B><C>En sustituir una clase por una subclase</C><D>En sustituir un valor de una variable por otro</D><respuesta_correcta explicacion="Overriding es redefinir un método heredado en la subclase, respetando su firma.">A</respuesta_correcta></pregunta><pregunta><enunciado>Sobre la clase Object es cierto indicar que:</enunciado><A>Es abstracta</A><B>Hereda de todas las demás</B><C>Tiene todos sus métodos abstractos</C><D>Es superclase de todas las demás clases</D><respuesta_correcta explicacion="Todas las clases en Java heredan directa o indirectamente de `Object`.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?</enunciado><A>Hay que implementarlo, ya que es abstracto</A><B>Sirve para comparar solo objetos de la clase Object</B><C>Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase</C><D>No hay que implementarlo, ya que se hereda de Object</D><respuesta_correcta explicacion="Aunque `equals()` está implementado en `Object`, conviene sobreescribirlo para personalizar la comparación.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?</enunciado><A>Sirve para mostrar la información que nos interesa de un objeto</A><B>Convierte automáticamente un objeto en una cadena</B><C>Encadena varios objetos</C><D>Es un método abstracto de Object que tenemos que implementar</D><respuesta_correcta explicacion="`toString()` devuelve una representación textual del objeto. Se puede sobrescribir para personalizarla.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?</enunciado><A>Convierte los objetos en clases</A><B>Obtiene la clase a la que pertenece un objeto</B><C>Obtiene la superclase de una clase</C><D>Obtiene una clase a partir de su nombre</D><respuesta_correcta explicacion="`getClass()` devuelve un objeto de tipo `Class` que representa la clase real del objeto.">B</respuesta_correcta></pregunta><pregunta><enunciado>Una clase puede heredar:</enunciado><A>De una clase</A><B>De dos clases</B><C>De todas las clases que queramos</C><D>Solo de la clase Object</D><respuesta_correcta explicacion="Java solo permite herencia simple: una clase puede heredar de una única superclase.&#xA;            ¿Cuál es la palabra clave para heredar una clase?&#xA;            a) inherits&#xA;            b) extends&#xA;            c) super&#xA;            d) base&#xA;            Respuesta correcta: b&#xA;            'extends' se usa para heredar una clase en Java.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué método se usa para llamar al constructor de la superclase?</enunciado><A>super()</A><B>parent()</B><C>base()</C><D>this()</D><respuesta_correcta explicacion="'super()' se usa para llamar al constructor de la clase base.">A</respuesta_correcta></pregunta><pregunta><enunciado>Sobre una subclase es correcto afirmar que:</enunciado><A>Tiene menos atributos que su superclase.</A><B>Tiene menos miembros que su superclase.</B><C>Hereda los miembros no privados de su superclase.</C><D>Hereda todos los miembros de su superclase.</D><respuesta_correcta explicacion="Una subclase hereda los miembros públicos y protegidos de su superclase, no los privados.">C</respuesta_correcta></pregunta><pregunta><enunciado>En relación con las clases abstractas es correcto señalar que:</enunciado><A>Implementan todos sus métodos.</A><B>No implementan ningún método.</B><C>No tienen atributos.</C><D>Tienen algún método abstracto.</D><respuesta_correcta explicacion="Las clases abstractas pueden tener métodos implementados y atributos, pero deben tener al menos un método abstracto.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿En qué consiste la sustitución u overriding?</enunciado><A>En sustituir un método heredado por otro implementado en la propia clase.</A><B>En sustituir un atributo por otro del mismo nombre.</B><C>En sustituir una clase por una subclase.</C><D>En sustituir un valor de una variable por otro.</D><respuesta_correcta explicacion="Overriding es redefinir un método heredado en una subclase con una nueva implementación.">A</respuesta_correcta></pregunta><pregunta><enunciado>Sobre la clase Object es cierto indicar que:</enunciado><A>Es abstracta.</A><B>Hereda de todas las demás.</B><C>Tiene todos sus métodos abstractos.</C><D>Es superclase de todas las demás clases.</D><respuesta_correcta explicacion="Object es la superclase de todas las clases en Java.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?</enunciado><A>Hay que implementarlo, ya que es abstracto.</A><B>Sirve para comparar solo objetos de la clase Object.</B><C>Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase.</C><D>No hay que implementarlo, ya que se hereda de Object.</D><respuesta_correcta explicacion="Se hereda de Object, pero se recomienda sobrescribirlo para una comparación personalizada.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?</enunciado><A>Sirve para mostrar la información que nos interesa de un objeto.</A><B>Convierte automáticamente un objeto en una cadena.</B><C>Encadena varios objetos.</C><D>Es un método abstracto de Object que tenemos que implementar.</D><respuesta_correcta explicacion="toString() sirve para devolver una representación textual personalizada de un objeto.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?</enunciado><A>Convierte los objetos en clases.</A><B>Obtiene la clase a la que pertenece un objeto.</B><C>Obtiene la superclase de una clase.</C><D>Obtiene una clase a partir de su nombre.</D><respuesta_correcta explicacion="getClass() devuelve la clase real del objeto en tiempo de ejecución.">B</respuesta_correcta></pregunta><pregunta><enunciado>Una clase puede heredar:</enunciado><A>De una clase.</A><B>De dos clases.</B><C>De todas las clases que queramos.</C><D>Solo de la clase Object.</D><respuesta_correcta explicacion="En Java solo se permite heredar de una única clase (herencia simple).">A</respuesta_correcta></pregunta><pregunta><enunciado>La selección dinámica de métodos:</enunciado><A>Se produce cuando una variable cambia de valor durante la ejecución de un programa.</A><B>Es el cambio de tipo de una variable en tiempo de ejecución.</B><C>Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución.</C><D>Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución.</D><respuesta_correcta explicacion="Esto es polimorfismo: permite ejecutar la versión del método correspondiente al tipo real del objeto.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?</enunciado><A>Sirve para llamar al constructor de la superclase.</A><B>Sirve para invocar un método escrito más arriba en el código.</B><C>Sirve para llamar a cualquier método de la superclase.</C><D>Sirve para hacer referencia a un atributo de la superclase.</D><respuesta_correcta explicacion="super() se usa para llamar al constructor de la clase base desde una subclase.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el tipo de retorno del método main en Java?</enunciado><A>void</A><B>int</B><C>String</C><D>boolean</D><respuesta_correcta explicacion="El método main debe ser public static void main(String[] args), por eso retorna void.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué palabra clave se utiliza para heredar una clase en Java?</enunciado><A>this</A><B>extends</B><C>implements</C><D>instanceof</D><respuesta_correcta explicacion="La palabra clave 'extends' se utiliza para heredar de una clase base.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué estructura se usa para seleccionar múltiples opciones en Java?</enunciado><A>if</A><B>for</B><C>switch</C><D>while</D><respuesta_correcta explicacion="La estructura 'switch' permite seleccionar múltiples casos según el valor de una expresión.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el valor predeterminado de un boolean en Java?</enunciado><A>true</A><B>null</B><C>false</C><D>0</D><respuesta_correcta explicacion="En Java, las variables boolean por defecto se inicializan como false.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué operador se utiliza para comparar igualdad en Java?</enunciado><A>=</A><B>==</B><C>equals</C><D>!=</D><respuesta_correcta explicacion="'==' se usa para comparar valores primitivos. Para objetos, se recomienda usar equals().">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes no es una palabra reservada en Java?</enunciado><A>static</A><B>try</B><C>new</C><D>define</D><respuesta_correcta explicacion="'define' no es una palabra reservada en Java, aunque lo es en otros lenguajes como C.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué clase se utiliza para leer datos desde la consola?</enunciado><A>InputReader</A><B>Scanner</B><C>ConsoleReader</C><D>BufferReader</D><respuesta_correcta explicacion="Scanner es la clase comúnmente usada para leer datos desde consola en Java.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes estructuras es una clase contenedora?</enunciado><A>Array</A><B>List</B><C>int</C><D>char</D><respuesta_correcta explicacion="List es una interfaz de colección que representa una lista ordenada de elementos.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la salida de System.out.println(3 + "4")?</enunciado><A>7</A><B>34</B><C>Error</C><D>"7"</D><respuesta_correcta explicacion="Se concatena 3 con el String &quot;4&quot;, dando como resultado &quot;34&quot;.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué significa que Java sea un lenguaje fuertemente tipado?</enunciado><A>Que se puede cambiar el tipo de una variable libremente.</A><B>Que se deben declarar todos los tipos de datos.</B><C>Que es sensible a mayúsculas.</C><D>Que no se pueden usar tipos primitivos.</D><respuesta_correcta explicacion="En Java todos los tipos deben ser declarados explícitamente y no se permite el cambio de tipo implícito en la mayoría de los casos.">B</respuesta_correcta></pregunta><pregunta><enunciado>Una interfaz sirve para:</enunciado><A>Almacenar datos numéricos.</A><B>Definir una serie de funcionalidades que se implementarán en las clases.</B><C>Heredar de una clase abstracta.</C><D>Implementar los métodos abstractos de una clase abstracta.</D><respuesta_correcta explicacion="Las interfaces definen un contrato que debe implementarse en las clases.">B</respuesta_correcta></pregunta><pregunta><enunciado>Una interfaz puede heredar de:</enunciado><A>Una clase.</A><B>Nada. Las interfaces no pueden heredar.</B><C>Una o más interfaces.</C><D>Una cadena.</D><respuesta_correcta explicacion="En Java, una interfaz puede heredar de múltiples interfaces.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un método declarado, pero no implementado, en una interfaz se llama:</enunciado><A>Método estático.</A><B>Método abstracto.</B><C>Método de cabecera.</C><D>Método público.</D><respuesta_correcta explicacion="Son métodos abstractos porque no tienen cuerpo, solo la firma.">B</respuesta_correcta></pregunta><pregunta><enunciado>En una interfaz se pueden definir:</enunciado><A>Sólo atributos.</A><B>Sólo métodos abstractos.</B><C>Atributos, métodos abstractos y métodos no abstractos.</C><D>Solo métodos públicos.</D><respuesta_correcta explicacion="Desde Java 8, una interfaz puede contener métodos default y estáticos, además de constantes.">C</respuesta_correcta></pregunta><pregunta><enunciado>El criterio de orden natural en una clase es:</enunciado><A>El criterio más lógico.</A><B>El criterio implementado en el método compareTo().</B><C>El criterio más ecológico.</C><D>El criterio implementado en la interfaz Comparator.</D><respuesta_correcta explicacion="El método compareTo() define el orden natural cuando una clase implementa Comparable.">B</respuesta_correcta></pregunta><pregunta><enunciado>La interfaz Comparator se implementa en:</enunciado><A>Una clase que queremos ordenar.</A><B>Una clase que queremos comparar con otra.</B><C>Una clase cuyos objetos queremos usar para comparar objetos.</C><D>Un array.</D><respuesta_correcta explicacion="Comparator es una interfaz funcional que define objetos que comparan otros objetos.">C</respuesta_correcta></pregunta><pregunta><enunciado>El método compare() es invocado por:</enunciado><A>Un objeto que queremos comparar.</A><B>Una clase que implementa la interfaz Comparator.</B><C>Una clase que implementa la interfaz Comparable.</C><D>Un objeto de una clase que implementa Comparator.</D><respuesta_correcta explicacion="El método compare() pertenece a la interfaz Comparator, y se invoca desde un objeto que implementa esta interfaz para comparar dos objetos.">D</respuesta_correcta></pregunta><pregunta><enunciado>Una excepción en Java:</enunciado><A>Se produce cuando un disco está defectuoso.</A><B>Es un valor único de una variable.</B><C>Se arroja al sistema cuando se produce una condición anómala durante la ejecución de un programa.</C><D>Tiene lugar cuando un código es sintácticamente incorrecto.</D><respuesta_correcta explicacion="Las excepciones son condiciones anómalas que ocurren durante la ejecución del programa.">C</respuesta_correcta></pregunta><pregunta><enunciado>Una excepción comprobada es:</enunciado><A>Una excepción que hemos reparado.</A><B>Una excepción que no detiene la ejecución del programa.</B><C>Una excepción previsible, que el propio compilador nos obliga a gestionar.</C><D>Una excepción muy conocida.</D><respuesta_correcta explicacion="Son aquellas que el compilador fuerza a capturar o declarar con `throws`.">C</respuesta_correcta></pregunta><pregunta><enunciado>Cuando llegamos al final de un flujo de entrada de tipo FileReader, el método read():</enunciado><A>Muestra el mensaje: End of File</A><B>Devuelve null.</B><C>Produce una excepción EOFException</C><D>Devuelve −1.</D><respuesta_correcta explicacion="`read()` devuelve -1 cuando se llega al final del archivo.">D</respuesta_correcta></pregunta><pregunta><enunciado>La palabra reservada finally:</enunciado><A>Termina la ejecución de un programa.</A><B>Termina la ejecución de un método, forzando el return.</B><C>En una estructura try-catch, fuerza la ejecución de su bloque antes de que se ejecute una sentencia return e independientemente de si se produce o no una excepción.</C><D>Indica el final de un método.</D><respuesta_correcta explicacion="`finally` siempre se ejecuta, ocurra o no una excepción.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un flujo de tipo BufferedReader:</enunciado><A>Crea un archivo de texto con búfer.</A><B>Solo sirve para leer cadenas de caracteres.</B><C>Nos permite acceder a archivos binarios.</C><D>Accede a un archivo de texto para lectura con búfer.</D><respuesta_correcta explicacion="Se usa para leer texto de manera eficiente, línea por línea.">D</respuesta_correcta></pregunta><pregunta><enunciado>La clase Scanner:</enunciado><A>Solo permite leer texto de cualquier flujo de texto.</A><B>Permite digitalizar imágenes.</B><C>Permite leer y analizar texto de cualquier flujo de entrada de texto.</C><D>Solo nos permite leer de la consola.</D><respuesta_correcta explicacion="Scanner puede leer de consola, archivos, cadenas, etc.">C</respuesta_correcta></pregunta><pregunta><enunciado>Para cambiar de línea al escribir en el flujo salida de tipo BufferedWriter debemos ejecutar:</enunciado><A>salida.write(“\n”)</A><B>salida.write(“\r\n”)</B><C>salida.write(“newLine”)</C><D>salida.newLine()</D><respuesta_correcta explicacion="`BufferedWriter.newLine()` agrega una nueva línea de forma segura y portátil.">D</respuesta_correcta></pregunta><pregunta><enunciado>Nos tenemos que asegurar de que todos los flujos abiertos deben cerrarse antes de que termine la aplicación...</enunciado><A>Porque se quedarían abiertos hasta que se apague el ordenador.</A><B>Porque otra aplicación podría alterarlos.</B><C>Porque se deben liberar los recursos asociados, como los archivos. Además, podrían quedar caracteres del búfer sin escribir.</C><D>Porque se pueden borrar datos de un archivo.</D><respuesta_correcta explicacion="Cerrar los flujos garantiza que los datos se escriben correctamente y se libera memoria.">C</respuesta_correcta></pregunta><pregunta><enunciado>Los flujos se cierran:</enunciado><A>Con el método close().</A><B>Apagando el ordenador.</B><C>Abortando el programa.</C><D>Con el método cerrar().</D><respuesta_correcta explicacion="`close()` es el método estándar para cerrar flujos en Java.">A</respuesta_correcta></pregunta><pregunta><enunciado>Apertura de flujos con recursos:</enunciado><A>Consiste en abrir flujos asociados con varios archivos a la vez.</A><B>Es abrir archivos recurriendo a una tabla.</B><C>Es una nueva forma de abrir flujos en Java, que permite prescindir del cierre explícito de los archivos y del método close().</C><D>Consiste en abrir flujos sin peligro de que se produzcan excepciones.</D><respuesta_correcta explicacion="Java 7 introdujo `try-with-resources`, que cierra automáticamente los recursos.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Para qué sirve la clase File en Java?</enunciado><A>Para crear interfaces gráficas.</A><B>Para manipular rutas, archivos y directorios.</B><C>Para leer y escribir ficheros de texto.</C><D>Para cifrar ficheros.</D><respuesta_correcta explicacion="La clase `File` permite manejar rutas, comprobar existencia de archivos, crear o borrar ficheros y directorios.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué método se utiliza para comprobar si un archivo existe?</enunciado><A>existsFile()</A><B>isAvailable()</B><C>exists()</C><D>fileFound()</D><respuesta_correcta explicacion="El método `exists()` de la clase `File` retorna true si el archivo o carpeta existe.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué clase se usa para escribir texto en un archivo?</enunciado><A>FileReader</A><B>File</B><C>FileWriter</C><D>FileInputStream</D><respuesta_correcta explicacion="`FileWriter` se usa para escribir caracteres en un archivo.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Con qué clase combinamos BufferedWriter para mejorar el rendimiento al escribir archivos?</enunciado><A>Scanner</A><B>File</B><C>FileWriter</C><D>InputStream</D><respuesta_correcta explicacion="`BufferedWriter` se usa junto con `FileWriter` para mejorar el rendimiento mediante búfer de escritura.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué diferencia hay entre FileWriter y FileOutputStream?</enunciado><A>FileWriter escribe bytes, FileOutputStream caracteres.</A><B>FileWriter trabaja con texto, FileOutputStream con bytes.</B><C>Ambas son iguales.</C><D>FileWriter solo sirve para leer archivos.</D><respuesta_correcta explicacion="`FileWriter` es para texto (caracteres) y `FileOutputStream` para datos binarios (bytes).">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué clase se utiliza para leer objetos guardados en un archivo binario?</enunciado><A>ObjectOutputStream</A><B>DataInputStream</B><C>ObjectInputStream</C><D>FileReader</D><respuesta_correcta explicacion="`ObjectInputStream` se usa para leer objetos previamente serializados con `ObjectOutputStream`.">C</respuesta_correcta></pregunta><pregunta><enunciado>Para que un objeto pueda guardarse en un archivo binario, su clase debe:</enunciado><A>Extender la clase File.</A><B>Implementar la interfaz Serializable.</B><C>Usar anotaciones específicas.</C><D>Ser pública.</D><respuesta_correcta explicacion="La interfaz `Serializable` marca que los objetos de esa clase se pueden guardar como secuencia de bytes.">B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el propósito de try-with-resources?</enunciado><A>Evitar errores de compilación.</A><B>Declarar múltiples métodos en una clase.</B><C>Manejar múltiples excepciones.</C><D>Cerrar automáticamente los recursos abiertos como flujos.</D><respuesta_correcta explicacion="Es una forma segura de manejar recursos que necesitan cerrarse automáticamente.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué clase permite leer archivos binarios byte a byte?</enunciado><A>FileInputStream</A><B>BufferedReader</B><C>Scanner</C><D>PrintWriter</D><respuesta_correcta explicacion="`FileInputStream` permite acceder a los archivos binarios como flujo de bytes.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Los ficheros binarios se diferencian de los de texto en que...?</enunciado><A>Solo tienen ceros y unos.</A><B>Sirven tanto para escribir como para leer.</B><C>No sirven para guardar texto.</C><D>Permiten guardar todo tipo de datos, incluidos datos primitivos y objetos.</D><respuesta_correcta explicacion="Los archivos binarios permiten guardar datos primitivos y objetos, no solo texto plano.">D</respuesta_correcta></pregunta><pregunta><enunciado>Si queremos guardar una cadena de caracteres en un flujo binario de tipo ObjectOutputStream, usaremos:</enunciado><A>writeString().</A><B>writeChar().</B><C>writeObject().</C><D>Nada, no se puede.</D><respuesta_correcta explicacion="Con writeObject() puedes guardar cualquier objeto, incluyendo String, si implementa Serializable.">C</respuesta_correcta></pregunta><pregunta><enunciado>Para guardar una tabla del tipo int[] en un fichero binario con ObjectOutputStream, usaremos:</enunciado><A>writeInt().</A><B>writeArrayInt().</B><C>readObject().</C><D>writeObject().</D><respuesta_correcta explicacion="Las tablas también son objetos en Java, así que deben guardarse con writeObject().">D</respuesta_correcta></pregunta><pregunta><enunciado>Si queremos leer una tabla de cadenas de caracteres de un flujo ObjectInputStream, escribiremos:</enunciado><A>String[] tabla = (String[]) entrada.readObject();</A><B>String tabla = (String) entrada.readObject();</B><C>String[] tabla = entrada.readObject();</C><D>String[] tabla = (Object).readObject();</D><respuesta_correcta explicacion="Hay que hacer un casting correcto al tipo deseado (String[]), porque readObject() devuelve un Object.">A</respuesta_correcta></pregunta><pregunta><enunciado>Un flujo de tipo ObjectInputStream permite leer de:</enunciado><A>Cualquier archivo de Windows.</A><B>Archivos de imagen con extensión JPG.</B><C>Archivos creados con un flujo ObjectOutputStream.</C><D>Archivos creados con un flujo BufferedReader.</D><respuesta_correcta explicacion="Solo puede leer archivos binarios serializados previamente con ObjectOutputStream.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un flujo de tipo ObjectInputStream permite acceder a:</enunciado><A>Solo archivos del disco duro.</A><B>Cualquier fuente de datos primitivos u objetos de Java.</B><C>Únicamente a conexiones de red.</C><D>Solo nos permite leer de la consola.</D><respuesta_correcta explicacion="Puede leer datos desde archivos, sockets u otros flujos, siempre que el contenido sea compatible.">B</respuesta_correcta></pregunta><pregunta><enunciado>Si guardamos una cadena de caracteres usando ObjectOutputStream, podemos leerla directamente del archivo:</enunciado><A>Usando un procesador de texto.</A><B>Usando un editor de texto.</B><C>Usando una hoja de cálculo.</C><D>Usando un flujo ObjectInputStream.</D><respuesta_correcta explicacion="Los datos binarios solo se pueden leer correctamente desde Java mediante ObjectInputStream.">D</respuesta_correcta></pregunta><pregunta><enunciado>Si guardamos una serie de objetos con ObjectOutputStream, los recuperaremos:</enunciado><A>En el mismo orden en que se guardaron.</A><B>En orden inverso.</B><C>En un orden aleatorio.</C><D>Nunca se pueden recuperar.</D><respuesta_correcta explicacion="La serialización conserva el orden de escritura, y deben recuperarse en el mismo orden.">A</respuesta_correcta></pregunta><pregunta><enunciado>Los flujos binarios se cierran:</enunciado><A>Con el método close().</A><B>Apagando el ordenador.</B><C>Abortando el programa.</C><D>Con el método cerrar().</D><respuesta_correcta explicacion="Como en otros flujos, close() es el método correcto para liberar recursos.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Hay que cerrar los flujos binarios?</enunciado><A>Siempre.</A><B>Una vez al día.</B><C>Solo si no se han abierto con una estructura try-catch con recursos.</C><D>Nunca.</D><respuesta_correcta explicacion="Es una buena práctica cerrar siempre los flujos para liberar recursos y evitar pérdida de datos.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué es Collection?</enunciado><A>Una interfaz.</A><B>Una clase.</B><C>Un sistema operativo.</C><D>Un método.</D><respuesta_correcta explicacion="Collection es una interfaz raíz del marco de colecciones de Java que agrupa tipos como List, Set y Queue.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Para qué sirven los tipos genéricos?</enunciado><A>Usar objetos de la clase Object.</A><B>Usar variables primitivas.</B><C>Usar tipos parametrizados.</C><D>No tener que usar ningún tipo.</D><respuesta_correcta explicacion="Los genéricos permiten definir estructuras con tipos de datos específicos, aumentando la seguridad y evitando conversiones.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Para qué sirve una lista?</enunciado><A>Guardar datos primitivos.</A><B>Guardar datos que no se pueden repetir.</B><C>No tener que ordenar un conjunto de datos.</C><D>Guardar, de forma dinámica, datos que se pueden repetir y ordenar.</D><respuesta_correcta explicacion="Las listas (List) permiten almacenar datos en orden y con posibles repeticiones.">D</respuesta_correcta></pregunta><pregunta><enunciado>Un conjunto es una colección de elementos:</enunciado><A>Que no admiten orden.</A><B>Que admiten repeticiones.</B><C>Que no se pueden alterar.</C><D>Cuyo criterio fundamental es el de pertenecer al conjunto.</D><respuesta_correcta explicacion="Un conjunto (Set) se define por la pertenencia, sin duplicados.">D</respuesta_correcta></pregunta><pregunta><enunciado>ArrayList y LinkedList se diferencian:</enunciado><A>En el número de elementos.</A><B>En el rendimiento.</B><C>En el orden de los elementos.</C><D>En nada.</D><respuesta_correcta explicacion="ArrayList tiene mejor acceso aleatorio, LinkedList es mejor para inserciones o eliminaciones frecuentes.">B</respuesta_correcta></pregunta><pregunta><enunciado>Los métodos de la interfaz Set:</enunciado><A>Son los mismos que los de List.</A><B>Son los mismos que los de Collection.</B><C>Son implementados en la clase ArrayList.</C><D>Esta interfaz no tiene métodos.</D><respuesta_correcta explicacion="Set hereda de Collection, por lo tanto, sus métodos básicos son los mismos.">B</respuesta_correcta></pregunta><pregunta><enunciado>Si la variable a referencia un objeto ArrayList, la expresión new TreeSet(a):</enunciado><A>Devuelve un conjunto ordenado con los elementos de a.</A><B>Es incorrecta.</B><C>Devuelve una lista ordenada.</C><D>Devuelve una tabla.</D><respuesta_correcta explicacion="TreeSet ordena automáticamente los elementos del ArrayList que se le pasa.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué es Collections?</enunciado><A>Una clase cuyos objetos están repetidos.</A><B>Una interfaz de la que heredan todas las colecciones.</B><C>Una clase con métodos estáticos que sirven para gestionar colecciones.</C><D>Nada, le sobra la 's'.</D><respuesta_correcta explicacion="Collections es una clase utilitaria con métodos estáticos como sort(), reverse(), etc.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un mapa en Java es:</enunciado><A>Un gráfico con las relaciones de herencia entre interfaces.</A><B>Una colección.</B><C>Una representación de los datos por pantalla.</C><D>Una estructura dinámica cuyos elementos son parejas clave-valor.</D><respuesta_correcta explicacion="Los mapas (Map) almacenan datos en pares clave-valor.">D</respuesta_correcta></pregunta><pregunta><enunciado>Si queremos cambiar el valor de una entrada en un mapa, usaremos el método:</enunciado><A>put().</A><B>set().</B><C>add().</C><D>insert().</D><respuesta_correcta explicacion="put(clave, nuevoValor) actualiza o inserta una nueva entrada en el mapa.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué es Collection?</enunciado><A>Una interfaz.</A><B>Una clase.</B><C>Un sistema operativo.</C><D>Un método.</D><respuesta_correcta explicacion="Collection es una interfaz raíz del marco de colecciones de Java que agrupa tipos como List, Set y Queue.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Para qué sirven los tipos genéricos?</enunciado><A>Usar objetos de la clase Object.</A><B>Usar variables primitivas.</B><C>Usar tipos parametrizados.</C><D>No tener que usar ningún tipo.</D><respuesta_correcta explicacion="Los genéricos permiten definir estructuras con tipos de datos específicos, aumentando la seguridad y evitando conversiones.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Para qué sirve una lista?</enunciado><A>Guardar datos primitivos.</A><B>Guardar datos que no se pueden repetir.</B><C>No tener que ordenar un conjunto de datos.</C><D>Guardar, de forma dinámica, datos que se pueden repetir y ordenar.</D><respuesta_correcta explicacion="Las listas (List) permiten almacenar datos en orden y con posibles repeticiones.">D</respuesta_correcta></pregunta><pregunta><enunciado>Un conjunto es una colección de elementos:</enunciado><A>Que no admiten orden.</A><B>Que admiten repeticiones.</B><C>Que no se pueden alterar.</C><D>Cuyo criterio fundamental es el de pertenecer al conjunto.</D><respuesta_correcta explicacion="Un conjunto (Set) se define por la pertenencia, sin duplicados.">D</respuesta_correcta></pregunta><pregunta><enunciado>ArrayList y LinkedList se diferencian:</enunciado><A>En el número de elementos.</A><B>En el rendimiento.</B><C>En el orden de los elementos.</C><D>En nada.</D><respuesta_correcta explicacion="ArrayList tiene mejor acceso aleatorio, LinkedList es mejor para inserciones o eliminaciones frecuentes.">B</respuesta_correcta></pregunta><pregunta><enunciado>Los métodos de la interfaz Set:</enunciado><A>Son los mismos que los de List.</A><B>Son los mismos que los de Collection.</B><C>Son implementados en la clase ArrayList.</C><D>Esta interfaz no tiene métodos.</D><respuesta_correcta explicacion="Set hereda de Collection, por lo tanto, sus métodos básicos son los mismos.">B</respuesta_correcta></pregunta><pregunta><enunciado>Si la variable a referencia un objeto ArrayList, la expresión new TreeSet(a):</enunciado><A>Devuelve un conjunto ordenado con los elementos de a.</A><B>Es incorrecta.</B><C>Devuelve una lista ordenada.</C><D>Devuelve una tabla.</D><respuesta_correcta explicacion="TreeSet ordena automáticamente los elementos del ArrayList que se le pasa.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué es Collections?</enunciado><A>Una clase cuyos objetos están repetidos.</A><B>Una interfaz de la que heredan todas las colecciones.</B><C>Una clase con métodos estáticos que sirven para gestionar colecciones.</C><D>Nada, le sobra la 's'.</D><respuesta_correcta explicacion="Collections es una clase utilitaria con métodos estáticos como sort(), reverse(), etc.">C</respuesta_correcta></pregunta><pregunta><enunciado>Un mapa en Java es:</enunciado><A>Un gráfico con las relaciones de herencia entre interfaces.</A><B>Una colección.</B><C>Una representación de los datos por pantalla.</C><D>Una estructura dinámica cuyos elementos son parejas clave-valor.</D><respuesta_correcta explicacion="Los mapas (Map) almacenan datos en pares clave-valor.">D</respuesta_correcta></pregunta><pregunta><enunciado>Si queremos cambiar el valor de una entrada en un mapa, usaremos el método:</enunciado><A>put().</A><B>set().</B><C>add().</C><D>insert().</D><respuesta_correcta explicacion="put(clave, nuevoValor) actualiza o inserta una nueva entrada en el mapa.">A</respuesta_correcta></pregunta><pregunta><enunciado>Sobre una subclase es correcto afirmar que:</enunciado><A>Tiene menos atributos que su superclase.</A><B>Tiene menos miembros que su superclase.</B><C>Hereda los miembros no privados de su superclase.</C><D>Hereda todos los miembros de su superclase.</D><respuesta_correcta explicacion="Una subclase hereda los miembros públicos y protegidos de su superclase, no los privados.">C</respuesta_correcta></pregunta><pregunta><enunciado>En relación con las clases abstractas es correcto señalar que:</enunciado><A>Implementan todos sus métodos.</A><B>No implementan ningún método.</B><C>No tienen atributos.</C><D>Tienen algún método abstracto.</D><respuesta_correcta explicacion="Las clases abstractas pueden tener métodos implementados y atributos, pero deben tener al menos un método abstracto.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿En qué consiste la sustitución u overriding?</enunciado><A>En sustituir un método heredado por otro implementado en la propia clase.</A><B>En sustituir un atributo por otro del mismo nombre.</B><C>En sustituir una clase por una subclase.</C><D>En sustituir un valor de una variable por otro.</D><respuesta_correcta explicacion="Overriding es redefinir un método heredado en una subclase con una nueva implementación.">A</respuesta_correcta></pregunta><pregunta><enunciado>Sobre la clase Object es cierto indicar que:</enunciado><A>Es abstracta.</A><B>Hereda de todas las demás.</B><C>Tiene todos sus métodos abstractos.</C><D>Es superclase de todas las demás clases.</D><respuesta_correcta explicacion="Object es la superclase de todas las clases en Java.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método equals() es correcta?</enunciado><A>Hay que implementarlo, ya que es abstracto.</A><B>Sirve para comparar solo objetos de la clase Object.</B><C>Se hereda de Object, pero debemos reimplementarlo al definirlo en una clase.</C><D>No hay que implementarlo, ya que se hereda de Object.</D><respuesta_correcta explicacion="Se hereda de Object, pero se recomienda sobrescribirlo para una comparación personalizada.">C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método toString() es correcta?</enunciado><A>Sirve para mostrar la información que nos interesa de un objeto.</A><B>Convierte automáticamente un objeto en una cadena.</B><C>Encadena varios objetos.</C><D>Es un método abstracto de Object que tenemos que implementar.</D><respuesta_correcta explicacion="toString() sirve para devolver una representación textual personalizada de un objeto.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método getClass() es correcta?</enunciado><A>Convierte los objetos en clases.</A><B>Obtiene la clase a la que pertenece un objeto.</B><C>Obtiene la superclase de una clase.</C><D>Obtiene una clase a partir de su nombre.</D><respuesta_correcta explicacion="getClass() devuelve la clase real del objeto en tiempo de ejecución.">B</respuesta_correcta></pregunta><pregunta><enunciado>Una clase puede heredar:</enunciado><A>De una clase.</A><B>De dos clases.</B><C>De todas las clases que queramos.</C><D>Solo de la clase Object.</D><respuesta_correcta explicacion="En Java solo se permite heredar de una única clase (herencia simple).">A</respuesta_correcta></pregunta><pregunta><enunciado>La selección dinámica de métodos:</enunciado><A>Se produce cuando una variable cambia de valor durante la ejecución de un programa.</A><B>Es el cambio de tipo de una variable en tiempo de ejecución.</B><C>Es la asignación de un mismo objeto a más de una variable en tiempo de ejecución.</C><D>Es la ejecución de distintas implementaciones de un mismo método, asignando objetos de distintas clases a una misma variable, en tiempo de ejecución.</D><respuesta_correcta explicacion="Esto es polimorfismo: permite ejecutar la versión del método correspondiente al tipo real del objeto.">D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes afirmaciones sobre el método super() es correcta?</enunciado><A>Sirve para llamar al constructor de la superclase.</A><B>Sirve para invocar un método escrito más arriba en el código.</B><C>Sirve para llamar a cualquier método de la superclase.</C><D>Sirve para hacer referencia a un atributo de la superclase.</D><respuesta_correcta explicacion="super() se usa para llamar al constructor de la clase base desde una subclase.">A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el tipo de retorno del método main en Java?</enunciado><A>void</A><B>int</B><C>String</C><D>boolean</D><respuesta_correcta explicacion="El método main debe ser public static void main(String[] args), por eso retorna void.">A</respuesta_correcta></pregunta></documento>