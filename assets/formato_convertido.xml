<documento><pregunta><enunciado>¿Cómo se denomina el tipo de atributo que representa "Teléfono"?</enunciado><A>Multievaluado</A><B>Multivalor</B><C>De alto valor</C><D>Multivaluado</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Según este diagrama ¿Qué campos contendrá la tabla "Ingeniero"?</enunciado><A>Ninguno</A><B>IdEmpleado, Especialidad, AñosExperiencia</B><C>IdEmpleado, Especialidad, AñosExperiencia, Nombre, Dirección, Fechanacimiento, Salario, Puesto</C><D>Especialidad, AñosExperiencia</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Tal y como se muestra la imagen, ¿Cuántos teléfonos puede tener un cliente?</enunciado><A>Ninguna de las anteriores</A><B>1</B><C>Indefinidos</C><D>10</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo se lleva a cabo el paso a tablas del atributo teléfono?</enunciado><A>Se crea una tabla con los atributos (IDTELÉFONO, TELÉFONO)</A><B>Se añade como clave foránea de tabla Cliente</B><C>Se crea una tabla con los atributos ((FK)IDCLIENTE, TELÉFONO)</C><D>Se reservan 10 columnas (Teléfono1, Teléfono2, ...) en la tabla Cliente</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Según este diagrama un empleado puede ser arquitecto y administrativo a la vez?</enunciado><A>No, porque solo un Dios y un gato (porque es gato y araña) puede ser dos cosas a la vez.</A><B>Sí claro.</B><C>No, porque es una generalización disjunta.</C><D>Depende.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Por qué hay un atributo rodeado de una línea discontinua en este diagrama?</enunciado><A>Es un atributo calculado</A><B>Ninguna de las anteriores</B><C>Queda bonito</C><D>Es un atributo multivaluado</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo pasaría a tablas el atributo antigüedad?</enunciado><A>Las tablas no existen, son los padres</A><B>No se pueden incluir campos con símbolos como ¨</B><C>No se pasa a tablas por que se calculará cada vez que se consulte</C><D>Se crea una nueva tabla Antigüedad_Camarero((FK)idCamarero, Antigüedad)</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Detectas algún problema en este diagrama?</enunciado><A>Faltan relaciones</A><B>No</B><C>idCamarero no puede ser clave primaria</C><D>No hay un campo que nos permita calcular "antigüedad"</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo se calcula "antigüedad"?</enunciado><A>Se pide al usuario cada vez que se necesita</A><B>Hay que guardar un "TimeStamp" cuando se registre el camarero, y se resta la fecha actual cada vez
                que se consulta.</B><C>Todas las bases de datos del mundo están interconectadas y se busca el dato en ellas</C><D>En base a la fecha de incorporación</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo pasamos a tablas el atributo "F. Inicio"?</enunciado><A>Se crea una tabla Autores_Cursos((FK)CodigoEmpleado, (FK)CodigoCurso, F.Inicio)</A><B>No se pasa a tablas</B><C>Se incorpora a la tabla Empleados</C><D>Se incorpora a la tabla Cursos</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>En la tabla Camarero_Emite_Ticket, que se genera con la relación "Emite", ¿Cuál será la clave primaria?</enunciado><A>(FK)IDCAMARERO</A><B>((FK)IDCAMARERO, (FK)IDTICKET)</B><C>(FK)IDTICKET</C><D>idEmite</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué tipo de entidad es "Línea Ticket"?</enunciado><A>Entidad débil</A><B>Entidad floja</B><C>Entidad multivaluada</C><D>Entidad normal</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál será la clave de Línea Ticket?</enunciado><A>idLinea</A><B>NumLinea, idLinea</B><C>NumTicket, NumLinea</C><D>NumTicket</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Un médico puede atender a varios pacientes, y un paciente puede ser atendido por varios médicos. ¿Cuál es la
            cardinalidad?</enunciado><A>uno a uno</A><B>muchos a muchos</B><C>muchos a uno</C><D>uno a muchos</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción SQL crea una tabla llamada 'Empleado'?</enunciado><A>ADD TABLE Empleado (id INT, nombre VARCHAR(100));</A><B>NEW TABLE Empleado (id INT, nombre VARCHAR(100));</B><C>ALTER TABLE Empleado ADD COLUMN (id INT, nombre VARCHAR(100));</C><D>CREATE TABLE Empleado (id INT, nombre VARCHAR(100));</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la manera correcta de añadir una columna a una tabla existente usando SQL?</enunciado><A>CREATE TABLE Empleado ADD edad INT;</A><B>ALTER TABLE Empleado ADD COLUMN edad INT;</B><C>ADD COLUMN edad INT IN Empleado;</C><D>UPDATE TABLE Empleado ADD edad INT;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué cláusula indica que una columna no puede tener valores repetidos?</enunciado><A>PRIMARY KEY</A><B>CHECK</B><C>UNIQUE</C><D>DEFAULT</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál opción permite establecer automáticamente valores numéricos incrementales en una columna?</enunciado><A>AUTONUMBER</A><B>AUTOINCREMENTAL</B><C>AUTO_INCREMENT</C><D>AUTO_NUM</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo definirías una columna con valores por defecto usando SQL?</enunciado><A>Telefono VARCHAR(15) AUTO 'Desconocido'</A><B>Telefono VARCHAR(15) SET 'Desconocido'</B><C>Telefono VARCHAR(15) DEFAULT 'Desconocido'</C><D>Telefono VARCHAR(15) VALUE 'Desconocido'</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción SQL eliminaría la columna 'Telefono' de la tabla 'Empleado'?</enunciado><A>ALTER TABLE Empleado DROP COLUMN Telefono;</A><B>ALTER TABLE Empleado REMOVE Telefono;</B><C>ALTER TABLE Empleado DELETE COLUMN Telefono;</C><D>DROP COLUMN Telefono FROM Empleado;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué restricción asegura que una columna nunca contenga valores nulos?</enunciado><A>DEFAULT</A><B>NOT NULL</B><C>CHECK</C><D>UNIQUE</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de estas instrucciones crea correctamente una clave primaria compuesta en SQL?</enunciado><A>PRIMARY(id_empleado, id_proyecto)</A><B>SET PRIMARY KEY(id_empleado, id_proyecto)</B><C>PRIMARY KEY(id_empleado, id_proyecto)</C><D>PRIMARY KEY COMPOSED(id_empleado, id_proyecto)</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia SQL modificaría el tipo de dato de la columna 'salario' a DECIMAL(12,2)?</enunciado><A>ALTER TABLE empleados MODIFY COLUMN salario DECIMAL(12,2);</A><B>ALTER TABLE empleados UPDATE salario DECIMAL(12,2);</B><C>ALTER salario COLUMN DECIMAL(12,2);</C><D>CHANGE COLUMN salario DECIMAL(12,2);</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes instrucciones SQL añade una restricción UNIQUE sobre la columna 'Email'?</enunciado><A>ALTER TABLE empleados ADD CONSTRAINT UNIQUE (Email);</A><B>ALTER TABLE empleados ADD COLUMN UNIQUE Email;</B><C>ALTER empleados TABLE UNIQUE Email;</C><D>SET UNIQUE Email ON empleados;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta devuelve todos los empleados ordenados por salario descendente?</enunciado><A>SELECT * FROM empleados ORDER salario DESC;</A><B>SELECT salario DESC FROM empleados;</B><C>SELECT * FROM empleados SORT salario DESC;</C><D>SELECT * FROM empleados ORDER BY salario DESC;</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué función SQL usarías para contar el número total de empleados en una tabla?</enunciado><A>COUNT()</A><B>TOTAL()</B><C>SUM()</C><D>AVG()</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta calcula el salario promedio de todos los empleados?</enunciado><A>SELECT SUM(salario) FROM empleados;</A><B>SELECT AVG(salario) FROM empleados;</B><C>SELECT TOTAL(salario) FROM empleados;</C><D>SELECT COUNT(salario) FROM empleados;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia SQL devuelve cuántos empleados hay por cada departamento?</enunciado><A>SELECT departamento, COUNT(*) FROM empleados GROUP BY departamento;</A><B>SELECT departamento, SUM(*) FROM empleados;</B><C>SELECT departamento, COUNT(*) FROM empleados GROUP BY salario;</C><D>SELECT departamento, COUNT(*) FROM empleados ORDER BY departamento;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción SQL devuelve todos los empleados cuyo salario es superior a 3000?</enunciado><A>SELECT nombre FROM empleados HAVING salario &amp;gt; 3000;</A><B>SELECT nombre FROM empleados SALARIO &amp;gt; 3000;</B><C>SELECT nombre FROM empleados ORDER BY salario &amp;gt; 3000;</C><D>SELECT nombre FROM empleados WHERE salario &amp;gt; 3000;</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué consulta devuelve los empleados que tienen un salario superior al salario promedio general de la
            empresa?</enunciado><A>SELECT nombre FROM empleados WHERE salario &amp;gt; AVG(salario);</A><B>SELECT nombre FROM empleados HAVING salario &amp;gt; AVG(salario);</B><C>SELECT nombre FROM empleados WHERE salario &amp;gt; (SELECT AVG(salario) FROM empleados);</C><D>SELECT AVG(salario) FROM empleados WHERE salario &amp;gt; promedio;</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué cláusula se utiliza para filtrar resultados agrupados por condiciones específicas?</enunciado><A>HAVING</A><B>GROUP BY</B><C>ORDER BY</C><D>WHERE</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué consulta obtiene los departamentos cuyo salario promedio supera los 4000 euros?</enunciado><A>SELECT departamento FROM empleados WHERE AVG(salario) &amp;gt; 4000;</A><B>SELECT departamento, AVG(salario) FROM empleados;</B><C>SELECT departamento FROM empleados GROUP BY departamento HAVING AVG(salario) &amp;gt; 4000;</C><D>SELECT departamento FROM empleados GROUP BY departamento WHERE AVG(salario) &amp;gt; 4000;</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta obtiene los empleados junto con sus departamentos (considerando que todos tienen departamento
            asignado)?</enunciado><A>SELECT empleados.nombre, departamentos.nombre FROM empleados RIGHT JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</A><B>SELECT empleados.nombre, departamentos.nombre FROM empleados JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</B><C>SELECT empleados.nombre, departamentos.nombre FROM empleados OUTER JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</C><D>SELECT empleados.nombre, departamentos.nombre FROM empleados LEFT JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta obtiene los empleados que NO están asignados a ningún proyecto (empleados sin asignación)?</enunciado><A>SELECT empleados.nombre FROM empleados JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado WHERE asignaciones.id_empleado IS NULL;</A><B>SELECT empleados.nombre FROM empleados LEFT JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado WHERE asignaciones.id_empleado IS NULL;</B><C>SELECT empleados.nombre FROM empleados JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado;</C><D>SELECT empleados.nombre FROM empleados RIGHT JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta</enunciado><A>Las relaciones pueden tener atributos.</A><B>Los atributos pertenecen exclusivamente a las entidades.</B><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿En una BBDD, con qué formato guardarías la fecha de nacimiento de un alumno?</enunciado><A>dd-mm-aaaa</A><B>aaaa/mm/dd</B><C>aaaa-mm-dd</C><D>dd/mm/aaaa</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>El dominio es:</enunciado><A>El conjunto de valores posibles que puede tener un atributo.</A><B>El conjunto de ocurrencias posibles que puede tener una relación.</B><C>El conjunto de ocurrencias posibles que puede tener una entidad.</C><D>Ninguna es correcta.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>Para una ocurrencia de una entidad cada ocurrencia sólo puede tomar un valor.</A><B>Ninguna es correcta.</B><C>Para una ocurrencia de una entidad cada atributo sólo puede tomar un valor.</C><D>Para una ocurrencia de un atributo cada atributo sólo puede tomar un valor.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>La inconsistencia puede provocar redundancia.</A><B>La inconsistencia provoca redundancia.</B><C>La redundancia puede provocar inconsistencia.</C><D>La redundancia provoca inconsistencia.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Tenemos la entidad A y la entidad B y existe una relación entre A y B con cardinalidad 1:1. Esto
            quiere decir:</enunciado><A>Que una ocurrencia de la entidad B sólo puede estar relacionada con una ocurrencia de la entidad
                A.</A><B>Que una ocurrencia de la entidad A sólo puede estar relacionada con una ocurrencia de la entidad
                B.</B><C>Que una ocurrencia de la entidad A sólo puede estar relacionada con una ocurrencia de la entidad
                B y viceversa.</C><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Tenemos una entidad A y una entidad B, y existe una relación entre A y B con cardinalidad N:M. Si la
            relación tiene un atributo, ¿dónde hay que incluir el atributo de la relación al realizar el paso a tablas?</enunciado><A>En la tabla A.</A><B>En la tabla B.</B><C>Puedo elegir en la tabla A o en la tabla B indistintamente.</C><D>En la tercera tabla que se genera.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En un diagrama de entidad-relación (DER) debe haber:</enunciado><A>Entidades, atributos, atributos identificadores principales, relaciones y cardinalidades.</A><B>Entidades, atributos identificadores principales, relaciones y cardinalidades.</B><C>Entidades débiles, atributos, atributos identificadores candidatos, relaciones y
                cardinalidades.</C><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Si tenemos siete AIC (atributo identificador candidato) y elegimos uno de ellos como AIP (atributo
            identificador principal) ¿cuántos AIA (atributo identificador alternativo) tendríamos?:</enunciado><A>Siete.</A><B>Seis.</B><C>Ocho.</C><D>Ninguna es correcta.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Tenemos la entidad A y la entidad B y existe una relación entre A y B con cardinalidad 1:N. Esto
            quiere decir:</enunciado><A>Que una ocurrencia de la entidad A puede estar relacionada con varias ocurrencias de la entidad
                B, mientras que varias ocurrencias de la entidad B sólo pueden estar relacionadas con una ocurrencia de
                la entidad A.</A><B>Que una ocurrencia de la entidad A puede estar relacionada con varias ocurrencias de la entidad
                B, mientras que una ocurrencia de la entidad B puede estar relacionada con varias ocurrencias de la
                entidad A.</B><C>Que una ocurrencia de la entidad A puede estar relacionada con varias ocurrencias de la entidad
                B, mientras que una ocurrencia de la entidad B sólo puede estar relacionada con una ocurrencia de la
                entidad A.</C><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>En relación a los sistemas gestores de bases de datos:</enunciado><A>Son lo mismo que las bases de datos.</A><B>Son el componente hardware de las bases de datos.</B><C>Suponen una interfaz entre las aplicaciones y los datos.</C><D>Suponen una interfaz entre las aplicaciones y el sistema operativo.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Los metadatos registran el comportamiento de la información almacenada en:</enunciado><A>Las tablas del administrador.</A><B>El diccionario de datos de los usuarios.</B><C>Los servidores remotos.</C><D>Las bases de datos.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>El control de la concurrencia es el mecanismo que:</enunciado><A>Describe los datos y las relaciones entre ellos.</A><B>Garantiza el acceso simultáneo a los datos.</B><C>Gestiona los accesos autorizados y el control de restricciones.</C><D>Permite consultar y transformar los datos y añadir nuevos.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Algunos comandos SQL para la manipulación de los datos son:</enunciado><A>DELETE, INSERT y UPDATE.</A><B>SELECT, ALTER, DROP y CREATE.</B><C>CREATE, ALTER y DROP.</C><D>SELECT, DELETE, INSERT, UPDATE y REVOKE.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>En cuanto al ciclo de vida en las bases de datos, el orden de sus fases principales es:</enunciado><A>Definición, planificación, análisis de requisitos, diseño de la aplicación, diseño de la base de
                datos, implementación, prueba y mantenimiento.</A><B>Definición, análisis de requisitos, diseño de la aplicación, diseño de la base de datos,
                implementación, prototipado, prueba y mantenimiento.</B><C>Planificación, definición, análisis de requisitos, diseño de la aplicación, diseño de la base de
                datos, implementación y mantenimiento.</C><D>Definición, análisis de requisitos, diseño de la base de datos, diseño de la aplicación,
                prototipado, implementación, prueba y mantenimiento.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Con respecto al fichero /etc/shadow, ¿cuál de las respuestas no es correcta?</enunciado><A>Contiene cada una de las contraseñas cifradas, pero pueden estar sin cifrar.</A><B>Se puede indicar el número de días sin poder cambiar la contraseña.</B><C>Se puede indicar el número de días antes del vencimiento de la contraseña.</C><D>Se puede indicar el número de días a partir de los cuales se debe cambiar la contraseña.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>En cuanto a los sistemas de soporte a decisiones:</enunciado><A>No son sistemas de información para su procesamiento, almacenamiento y flujo.</A><B>Son sistemas de información para su procesamiento y almacenamiento.</B><C>Son lo mismo que los almacenes de datos o Data Warehouse.</C><D>No hacen uso de los almacenes de datos o Data Warehouse.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>En relación a los sistemas transaccionales:</enunciado><A>OLAP es un ejemplo de ellos.</A><B>Los sistemas DDS son un ejemplo de ellos.</B><C>También son conocidos como almacenes de datos.</C><D>OLTP es un ejemplo de ellos.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el objetivo de la minería de datos?</enunciado><A>Establecer las estructuras relacionales necesarias para las grandes bases de datos.</A><B>Cruzar los datos con distintos niveles de agregación en bases de datos multidimensionales.</B><C>Buscar reglas y estructuras a partir de los datos almacenados en almacenes de datos.</C><D>Recolectar masivamente los datos y procesarlos en tiempo real.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>La característica más importante de los Big Data es:</enunciado><A>Supone una colección de almacenes de datos para la búsqueda de patrones.</A><B>El procesamiento de la información disponible en los grandes almacenes de datos se proyecta en
                tiempo real.</B><C>Es la colección de muchas bases de datos relacionales.</C><D>Es una base de datos NoSQL para el análisis de datos en la toma de decisiones.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Si un atributo tiene propiedades que almacenar, este se considera:</enunciado><A>Atributo multivaluado.</A><B>Un tipo de interrelación con un atributo.</B><C>Un tipo de entidad.</C><D>Un atributo principal.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>En relación a los atributos secundarios:</enunciado><A>Es lo mismo que un atributo principal.</A><B>Identifica unívocamente a cada entidad.</B><C>No identifica unívocamente cada entidad, ya que puede ser opcional.</C><D>Se usará para relacionar las entidades de dos tipos de entidad.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Si se desea almacenar la o las tarjetas bancarias que usa un cliente en las compras de un sitio
            web:</enunciado><A>Se añadirá el atributo simple tarjeta al tipo de entidad Cliente.</A><B>Se añadirá el atributo compuesto tarjeta al tipo de entidad Cliente.</B><C>Se añadirá el atributo principal tarjeta al tipo de entidad Cliente.</C><D>Se añadirá el atributo multivaluado tarjeta al tipo de entidad Cliente.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En las relaciones N:M las cardinalidades de los dos tipos de entidad que unen son:</enunciado><A>(0,1),(1,1),(1,n) o (2,n).</A><B>(0,1),(1,1) o (1,n).</B><C>(0,n),(1,n) o (x,n).</C><D>(0,n) o (1,n).</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>En cuanto a las relaciones ternarias:</enunciado><A>Siempre tienen su representación con dos interrelaciones binarias sin que por ello se pierda
                semántica.</A><B>No siempre tienen su representación con dos interrelaciones binarias conservando la semántica.</B><C>La cardinalidad mínima y máxima en uno de los tipos de entidad son 1 y n, respectivamente.</C><D>Siempre se deben convertir en un tipo de entidad.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Si se quiere cerrar el dominio del atributo color, ¿cuál es la mejor forma?</enunciado><A>Añadirlo como atributo no nulo.</A><B>Añadirlo como atributo secundario.</B><C>Añadirlo como una interrelación con un tipo de entidad llamado Color.</C><D>Añadirlo como un atributo primario llamado color y un tipo de entidad llamado Color.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Los atributos en las interrelaciones:</enunciado><A>Pueden participar como parte del atributo principal.</A><B>No se debe añadir a las que son de multiplicidad 1:N.</B><C>Siempre son temporales y forman parte del identificador de la interrelación.</C><D>Se añade al tipo de entidad de mayor cardinalidad.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>En las relaciones reflexivas siempre se debe añadir en el otro extremo la cardinalidad mínima y
            máxima con los valores:</enunciado><A>(1,1) y (1,n).</A><B>(0,1) y (1,n).</B><C>(0,1) y (0,n).</C><D>(0,1), (1,1), (0,n).</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Los tipos de entidad débiles por identificación, ¿para qué se diseñan?</enunciado><A>Identificar la entidad regular con el código secuencial de la débil.</A><B>Identificar la entidad débil con el código secuencial de la regular.</B><C>Identificar la entidad regular y la entidad débil con un código secuencial.</C><D>Identificar la entidad débil usando el identificador de la regular de la que depende.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En las relaciones de generalización total exclusiva:</enunciado><A>Los subtipos tienen cardinalidad (0,1) y heredan el campo tipo del supertipo.</A><B>Solo se indican sus propiedades particulares.</B><C>Los subtipos tienen cardinalidad (1,1) y solo se debe indicar el atributo principal del
                supertipo.</C><D>Los subtipos heredan todos los atributos del supertipo y es necesario indicar el atributo
                principal y sus propiedades particulares.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Los atributos principales tienen la restricción:</enunciado><A>Primary key, Unique, Not Null y Foreign key.</A><B>Primary key, Not Null y Foreign key.</B><C>Primary key, Unique y Not Null.</C><D>Unique, Not Null y Foreign key</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>En relación a la restricción de clave ajena F:</enunciado><A>Apuntan a otras claves ajenas de otras tablas y solo se obtienen de transformar una relación 1:1,
                1:N o N:M.</A><B>Apuntan a otras claves primarias de otras tablas y solo se obtienen de transformar una relación
                N:M.</B><C>Apuntan a otras claves primarias de otras tablas y solo se obtienen de transformar una relación
                1:1, 1:N o N:M.</C><D>Apuntan a otras claves primarias de otras tablas y se obtienen de transformar una relación 1:1,
                1:N, N:M, interrelación débil y generalizaciones.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Las relaciones 1:1 con cardinalidades (0,1) y (1,1) en los extremos se transforman del modo:</enunciado><A>Se añade la clave primaria de la que tenga cardinalidades (0,1) a la de (1,1) como clave
                primaria.</A><B>Se añade la clave primaria de la que tenga cardinalidades (0,1) a la de (1,1) como clave ajena.</B><C>Se añade la clave primaria de la que tenga cardinalidades (1,1) a la de (0,1) como clave
                primaria.</C><D>Se añade la clave primaria de la que tenga cardinalidades (1,1) a la de (0,1) como clave ajena.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En las relaciones 1:N con cardinalidades (1,1) y (0,n) en los extremos:</enunciado><A>Se añade la clave primaria de la que tenga cardinalidades (1,1) a la de (0,n) como clave ajena
                puesta a nulos.</A><B>Se añade la clave primaria de la que tenga cardinalidades (0,n) a la de (1,1) como clave ajena
                puesta a no nulos.</B><C>Se añade la clave primaria de la que tenga cardinalidades (1,1) a la de (0,n) como clave ajena
                puesta a no nulos.</C><D>Se añade la clave primaria de la que tenga cardinalidades (1,1) a la de (0,n) como clave primaria
                puesta a nulos.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>En las relaciones N:M con cardinalidades (1,n) en ambos extremos:</enunciado><A>Se añade la clave primaria como clave primaria y ajena de una de ellas a la otra.</A><B>Se crea una nueva relación con una clave primaria compuesta por el atributo principal del tipo de
                entidad que se elija y como clave ajena que apunta al otro tipo de entidad.</B><C>Se crea una nueva relación con clave primaria los dos atributos principales de los tipos de
                entidad que unen y cada uno como clave ajena.</C><D>Se crea una relación con clave primaria los dos atributos principales y con una clave ajena que
                apunta a ambos.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>En las interrelaciones N:M con atributos no puestos a P:</enunciado><A>Se crea una nueva relación, donde su clave primaria se forma con los atributos principales de los
                tipos de entidad que unen, y se añade una clave ajena con los atributos no puesto a P.</A><B>Los atributos que no son principales se propagan a uno de los dos tipos de entidad y se crea una
                nueva relación con los atributos principales que son principales y ajenos.</B><C>Los atributos principales de los dos tipos de entidad más los atributos de la relación forman los
                atributos principales de la nueva relación.</C><D>Se crea una relación con clave primaria formada por los atributos principales de los dos tipos de
                entidad y se añaden los atributos no principales como atributos normales.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En las interrelaciones N:M con atributos principales:</enunciado><A>Se crea una nueva relación con clave primaria, la formada por los dos atributos principales de
                los tipos de entidad que unen, y con clave ajena, la formada por los atributos no principales.</A><B>Se propaga los atributos no principales a uno de los dos tipos de entidad y se crea una nueva
                relación con los atributos principales que son claves ajenas.</B><C>Se crea una relación con los atributos principales, los de los tipos de entidad que une, y los
                atributos principales de la interrelación.</C><D>Se crea una relación donde la clave primaria está compuesta por los atributos principales de los
                tipos de entidad que une y se añaden los atributos principales como atributos normales.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Una interrelación reflexiva 1:N se transforma:</enunciado><A>Añadiendo el atributo principal de la relación como clave ajena que permite valores nulos.</A><B>Añadiendo el atributo principal de la relación como clave ajena que no permite valores nulos.</B><C>Creando una nueva relación con atributo principal y clave ajena que apunta a la relación
                original.</C><D>Creando una nueva relación con atributo principal, el de la relación original.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Un subtipo de un tipo de entidad supertipo se transforma:</enunciado><A>Transformándolo como relación con clave primaria la del supertipo y añadiendo el discriminador
                del supertipo como clave ajena que apunta a él.</A><B>Transformándolo como relación con clave primaria y clave ajena, la del supertipo, y añadiendo el
                discriminador del supertipo.</B><C>Transformándolo como relación con clave primaria y clave ajena, la del supertipo, y apuntando al
                subtipo.</C><D>Transformándolo como relación con clave primaria y clave ajena, la del supertipo, y apuntando al
                supertipo.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Con respecto a la normalización:</enunciado><A>Una tabla está en primera forma normal cuando sus atributos contienen valores atómicos.</A><B>Una tabla está en segunda forma normal cuando todos los atributos que forman parte de la clave
                primaria tienen dependencias completas con respecto a todas las claves existentes en el esquema.</B><C>Una tabla está en tercera forma normal si cada atributo que participa en la clave primaria no
                depende transitivamente de esta.</C><D>Una tabla está en segunda forma normal cuando todos los atributos que no forman parte de la clave
                primaria no tienen dependencias completas con respecto a todas las claves existentes en el esquema.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Para crear la tabla Departamento(P·CodDept, Nombre) en el espacio de tabla datos, se ejecutará:</enunciado><A>CREATE TABLE Departamento(CodDept NUMBER(2) PRIMARY KEY, Nombre VARCHAR2(20) NOT NULL) TABLESPACE
                Datos;</A><B>CREATE TABLE Departamento(CodDept NUMBER(2) PRIMARY KEY, Nombre VARCHAR2(20) NOT NULL TABLESPACE
                Datos);</B><C>CREATE TABLE Departamento(CodDept NUMBER(2) PRIMARY KEY, Nombre VARCHAR2(20) NOT NULL, TABLESPACE
                Datos);</C><D>CREATE TABLE Departamento(CodDept NUMBER(2) PRIMARY KEY, Nombre VARCHAR2(20) NOT NULL) Datos;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Para definir una restricción de clave primaria con nombre pk_prof en la definición de la columna
            CodProf NUMBER(4) se escribe:</enunciado><A>CodProf NUMBER(4) pk_prof PRIMARY KEY</A><B>CodProf NUMBER(4) CONSTRAINT pk_prof PRIMARY KEY</B><C>CodProf NUMBER(4) CONSTRAINT PRIMARY KEY(pk_prof)</C><D>CodProf NUMBER(4) PRIMARY KEY(pk_prof)</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Para definir la restricción de clave primaria de una tabla con nombre pk_hab que tiene dos columnas
            CodHotel y secuencia como campo clave, se escribe:</enunciado><A>CONSTRAINT pk_hab PRIMARY KEY(CodHotel), PRIMARY KEY(secuencia)</A><B>CONSTRAINT PRIMARY KEY(pk_hab), PRIMARY KEY(CodHotel, secuencia)</B><C>PRIMARY KEY(pk_hab), PRIMARY KEY(CodHotel, secuencia)</C><D>CONSTRAINT pk_hab PRIMARY KEY(CodHotel, secuencia)</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Para definir una restricción de clave foránea llamada fk_prof_dep hacia la columna CodDept de la
            tabla Departamento con borrado puesto a nulos, se escribe:</enunciado><A>CONSTRAINT fk_prof_dep FOREIGN KEY(CodDept) REFERENCES Departamento (CodDepT) ON DELETE SET
                NULL</A><B>FOREIGN KEY(fk_prof_dep) REFERERENCES Departamento(CodDepT) ON DELETE SET NULL</B><C>CONSTRAINT fk_prof_dep FOREIGN KEY(CodDept) REFERENCE Departamento DELETE SET NULL</C><D>CONSTRAINT FOREIGN KEY(CodDept) REFERENCES Departamento(fk_prof_dep) DELETE SET NUL</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Para añadir una columna planta NUMBER(2) a la tabla Departamento y su validación para que esté entre
            1 y 23, se debe ejecutar:</enunciado><A>ALTER TABLE Departamento ADD Planta NUMBER(2) CHECK(Planta BETWEEN 1 AND 23);</A><B>UPDATE Departamento SET Planta NUMBER(2) CHECK(Planta&gt;=1 AND&gt;=23);</B><C>ALTER TABLE Departamento ADD Planta NUMBER(2) CHECK(Planta&gt;=1 AND&gt;=23);</C><D>UPDATE Departamento ADD Planta NUMBER(2) CHECK(Planta BETWEEN 1 AND 23);</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Para eliminar la tabla Departamento y las restricciones asociadas a estas se ejecuta:</enunciado><A>DELETE TABLE Departamento CONSTRAINT;</A><B>DROP Departamento CONSTRAINT;</B><C>DROP TABLE Departamento CASCADE CONSTRAINTS;</C><D>DROP TABLE Departamento ON DELETE CASCADE CONSTRAINTS;</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Para insertar un registro en la tabla Departamento(P·CodDept, Nombre, N·Planta), se debe ejecutar:</enunciado><A>INSERT Departamento(CodDep,Nombre) VALUES (1,'Informática');</A><B>INSERT Departamento VALUES (1,'Informática');</B><C>INSERT INTO Departamento(CodDep,Nombre) VALUES (1,'Informática');</C><D>INSERT Departamento VALUES (1,'Informática',NULL);</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Para cambiar el segundo apellido en la tabla Empleado(P·dni, Nombre, prApellido, N·sgApellido), se
            ejecutará:</enunciado><A>ALTER Empleado sgApellido='Palacios' WHERE dni=34567891;</A><B>ALTER Empleado SET sgApellido='Palacios' WHERE dni=34567891;</B><C>ALTER TABLE Empleado SET sgApellido='Palacios' WHERE dni=34567891;</C><D>UPDATE Empleado SET sgApellido='Palacios' WHERE dni=34567891;</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes cláusula STORAGE está bien escrita?</enunciado><A>STORAGE(INIT 10M NEXT 15M NEXT 30)</A><B>STORAGE(INITIAL 10M NEXT 15M PCTINCREASE 30)</B><C>STORAGE(10M, 15M,30)</C><D>STORAGE(INIT 10M NEXT 15M PCTINCREASE 30)</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Para declarar un número de 7 cifras enteras y 4 decimales usando el tipo de datos NUMBER, la
            declaración será:</enunciado><A>NUMBER(4,7)</A><B>NUMBER(7,4)</B><C>NUMBER(3,11)</C><D>NUMBER(11,3)</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>La sentencia CREATE TABLE pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</A><B>Ninguna es correcta.</B><C>La sentencia CREATE TABLE no pertenece al DDL ni al DML.</C><D>La sentencia CREATE TABLE pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>Ninguna es correcta.</A><B>La sentencia CREATE no pertenece al DDL ni al DML.</B><C>La sentencia CREATE pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</C><D>La sentencia CREATE pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>Ninguna es correcta.</A><B>La sentencia CREATE DATABASE pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</B><C>La sentencia CREATE DATABASE pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</C><D>La sentencia CREATE DATABASE no pertenece al DDL ni al DML.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>La sentencia UPDATE no pertenece al DDL ni al DML.</A><B>Ninguna es correcta.</B><C>La sentencia UPDATE pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</C><D>La sentencia UPDATE pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>La sentencia DELETE pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</A><B>La sentencia DELETE pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</B><C>La sentencia DELETE no pertenece al DDL ni al DML.</C><D>Ninguna es correcta.</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Queremos eliminar la columna sueldo de la tabla empleados. ¿Qué query sería la correcta?</enunciado><A>ALTER TABLE empleados DELETE sueldo;</A><B>DROP COLUMN sueldo FROM empleados;</B><C>ALTER TABLE empleados DROP sueldo;</C><D>Ninguna de las anteriores.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>La sentencia INSERT pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</A><B>La sentencia INSERT pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</B><C>La sentencia INSERT no pertenece al DDL ni al DML.</C><D>Ninguna es correcta.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Si tenemos creada la tabla empleados y ya tenemos 10 filas con información insertada en la misma, al
            ejecutar la query ALTER TABLE empleados ADD COLUMN sueldo FLOAT(7,2) UNSIGNED NOT NULL AFTER apellidos;</enunciado><A>La información del campo sueldo en todas las filas será 0.00</A><B>La información del campo sueldo en todas las filas será NULL.</B><C>La información del campo sueldo en todas las filas estará vacía.</C><D>Ninguna es correcta.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Si queremos eliminar las columnas observaciones y departamento de la tabla empleados, debemos
            ejecutar la siguiente query:</enunciado><A>ALTER TABLE empleados DROP observaciones, DROP departamento;</A><B>ALTER TABLE empleados DROP observaciones, departamento;</B><C>ALTER TABLE empleados DROP observaciones AND departamento;</C><D>Ninguna es correcta.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Marca la respuesta correcta:</enunciado><A>La sentencia ALTER TABLE pertenece al DDL (Lenguaje de DEFINICIÓN de Datos).</A><B>La sentencia ALTER TABLE no pertenece al DDL ni al DML.</B><C>La sentencia ALTER TABLE pertenece al DML (Lenguaje de MANIPULACIÓN de Datos).</C><D>Ninguna es correcta.</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>La consulta Mostrar el dni sin repetir de los profesores que imparten la asignatura con código clave
            3...</enunciado><A>SELECT dni FROM Profesor WHERE CodAsig=3;</A><B>SELECT DISTINTC dni FROM Profesor WHERE CodAsig=3;</B><C>SELECT dni FROM Imparte WHERE CodAsig=3;</C><D>SELECT DISTINTC dni FROM Imparte WHERE CodAsig=3;</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Usando el producto cartesiano para implementar la consulta Mostrar el código de las asignaturas
            impartidas por profesores del departamento con código 4...</enunciado><A>SELECT CodAsig FROM Asignatura A, Imparte I, Profesor P WHERE A.CodAsig=I. CodAsig AND
                I.dni=P.dni AND CodDep=4;</A><B>SELECT CodAsig FROM Asignatura A, Imparte I, Profesor P, Departamento WHERE A.CodAsig=I.CodAsig
                AND I.dni=P.dni AND CodDep=4;</B><C>SELECT CodAsig FROM Asignatura A, Imparte I WHERE A.CodAsig=I.CodAsig AND CodDep=4;</C><D>SELECT CodAsig FROM Asignatura A, Imparte I, Profesor P WHERE CodDep=4;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Usando el predicado JOIN ON, para implementar la consulta Mostrar el código de las asignaturas
            impartidas por profesores del departamento con código 4...</enunciado><A>SELECT CodAsig FROM Asignatura A JOIN Imparte I ON A.CodAsig=I.CodAsig JOIN Profesor P ON
                I.dni=P.dni WHERE A.CodAsig=I.CodAsig AND I.dni=P.dni AND CodDep=4;</A><B>SELECT CodAsig FROM Asignatura A JOIN Imparte I ON A.CodAsig=I.CodAsig JOIN Profesor P ON
                I.dni=P.dni WHERE CodDep=4;</B><C>SELECT CodAsig FROM Asignatura A JOIN Imparte I ON A.CodAsig=I.CodAsig JOIN Profesor P ON
                I.dni=P.dni JOIN Departamento WHERE CodDep=4;</C><D>SELECT CodAsig FROM Asignatura A JOIN Imparte I ON CodAsig JOIN Profesor P ON dni WHERE
                CodDep=4;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Para filtrar en la cláusula WHERE aquellos nombres que empiecen por A se debe escribir:</enunciado><A>WHERE Nombre LIKE A%</A><B>WHERE Nombre LIKE "A%"</B><C>WHERE Nombre='A%'</C><D>WHERE Nombre LIKE 'A%'</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Para filtrar en el WHERE aquellos nombres cuya primera letra sea N, P, L, Q, M, S, T, A o B usando la
            función SUBSTR, se ha de escribir:</enunciado><A>WHERE SUBSTR(Nombre,1,1) IN ('N','P','L','Q','M','S','T','A','B')</A><B>WHERE SUBSTR(Nombre) IN ('N','P','L','Q','M','S','T','A','B')</B><C>WHERE SUBSTR(Nombre,1,1)=('N','P','L','Q','M','S','T','A','B')</C><D>WHERE SUBSTR(Nombre,1) IN ('N','P','L','Q','M','S','T','A','B')</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Usando la función LENGTH y para la columna ISBN NUMBER(13), la expresión que hay que usar en el WHERE
            para comprobar que su longitud sea de 13 dígitos será:</enunciado><A>WHERE LENGTH(TO_CHAR ISBN ) BETWEEN 13 AND 13</A><B>WHERE LENGTH(TO_CHAR(ISBN))=13</B><C>WHERE LENGTH( (ISBN)) LIKE '13'</C><D>WHERE LENGTH TO_CHAR(ISBN)=13</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál sería la consulta para mostrar el número de empleados que trabajan en el departamento de
            Contabilidad, Informática o Ventas?</enunciado><A>SELECT COUNT(dni) FROM Empleado E JOIN Departamento D USING E.CodDep=D. CodDep WHERE D.Nombre IN
                ('Contabilidad','Informática','Ventas');</A><B>SELECT SUM(CodAsig) FROM Empleado E, Departamento D WHERE E.CodDep=D. CodDep AND D.Nombre IN
                ('Contabilidad','Informática','Ventas');</B><C>SELECT COUNT(CodDep) FROM Empleado E, Departamento D WHERE E.CodDep=D.CodDep AND D.Nombre IN
                ('Contabilidad','Informática','Ventas');</C><D>SELECT COUNT(*) FROM Empleado WHERE CodDep IN(SELECT CodDep FROM Departamento WHERE Nombre IN
                ('Contabilidad','Informática','Ventas');</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>La consulta Mostrar el número de empleados por cada departamento será:</enunciado><A>SELECT COUNT(dni) FROM Empleado GROUP BY CodDep;</A><B>SELECT COUNT(dni), nombre FROM Empleado GROUP BY CodDep;</B><C>SELECT COUNT(*) FROM Empleado E1, Empleado E2 WHERE E1.CodDep=E2. CodDep GROUP BY CodDep;</C><D>SELECT COUNT(CodDep) FROM Empleado GROUP BY dni;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué subconsulta corresponde a la consulta SELECT COUNT(CodDep) FROM Empleado E, Departamento D WHERE
            E.CodDep=D.CodDep AND D.Nombre IN ('Contabilidad', 'Informática', 'Ventas')?</enunciado><A>SELECT COUNT(CodDep) FROM Empleado, Departamento D WHERE CodDep IN(SELECT CodDep FROM
                Departamento) WHERE D.Nombre IN ('Contabilidad', 'Informática', 'Ventas');</A><B>SELECT COUNT(CodDep) FROM Empleado WHERE CodDep IN(SELECT CodDep FROM Departamento D WHERE
                D.Nombre IN (SELECT Nombre FROM Departamento WHERE Nombre IN('Contabilidad', 'Informática', 'Ventas')));</B><C>SELECT COUNT(CodDep) FROM Empleado WHERE CodDep IN(SELECT CodDep FROM Departamento D WHERE
                D.Nombre IN (SELECT Nombre FROM Departamento WHERE Nombre IN('Contabilidad', 'Informática', 'Ventas')));</C><D>SELECT COUNT(*) FROM Departamento WHERE dni IN(SELECT dni FROM Empleado WHERE Nombre IN
                ('Contabilidad', 'Informática', 'Ventas'));</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Si queremos insertar en la tabla Emp(P·dni) los empleados de la tabla Empleado(P·dni, Nombre,
            N·prApellido) que no tienen primer apellido, el resultado será:</enunciado><A>INSERT INTO Emp VALUES SELECT dni FROM Empleado WHERE prApellido=NULL;</A><B>INSERT INTO Emp(dni) SELECT dni FROM Empleado WHERE prApellido IS NULL;</B><C>INSERT INTO Emp(dni) VALUES(SELECT dni FROM Empleado WHERE prApellido IS NULL);</C><D>INSERT INTO Emp SELECT dni, nombre FROM Empleado WHERE prApellido IS NULL;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Para crear un tipo objeto se usa el comando:</enunciado><A>CREATE TYPE AS OBJECT</A><B>CREATE OR REPLACE AS OBJECT</B><C>TYPE OR REPLACE TYPE AS OBJECT</C><D>CREATE TYPE IS TAB</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Un tipo de objeto puede incorporar otro tipo de objeto haciendo:</enunciado><A>DECLARE vProfesor tobjProfesor</A><B>Domicilio tObjDomicilio</B><C>Nombre VARCHAR2(30)</C><D>CREATE TYPE tObjDomicilio INHERITS tObjCodPostal</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Las restricciones que se pueden declarar en un PRAGMA RESTRICT_REFERENCES son:</enunciado><A>MAP|ORDER</A><B>MEMBER FUNCTION</B><C>SELF</C><D>RNDS, RNPS, WNDS, WNPD</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>Para implementar los métodos de un tipo de objeto se usa el comando:</enunciado><A>MEMBER FUNCTION</A><B>MAP MEMBER FUNCTION</B><C>CREATE TYPE BODY AS</C><D>TYPE OR REPLACE TYPE BODY</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Para almacenar objetos de fila se usa el comando:</enunciado><A>CREATE TYPE tipo AS OBJECT</A><B>CREATE TYPE tipo IS TABLE OF</B><C>CREATE TYPE tipo OF ROW</C><D>CREATE VARRAY OF</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Para insertar un registro en una tabla con nombre tEmpleado devolviendo el puntero a su campo clave
            en la variable vEmpl se usaría el comando:</enunciado><A>INSERT INTO Empleado VALUES(vEmpl) RETURNING REF(vEmpl)</A><B>INSERT vEmpleado VALUES(Empleado) RETURNING REF(vEmpl) INTO vEmpl;</B><C>INSERT INTO Empleado VALUES(vEmpleado) RETURNING REF(Empleado) INTO vEmpl;</C><D>INSERT INTO vEmpl VALUES(Empleado) RETURNING REF(vEmpl) INTO vEmpleado</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Para obtener el objeto que apunta una referencia se usa el operador:</enunciado><A>MAP</A><B>ORDER</B><C>DEREF</C><D>REF</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Para crear un tipo de tabla anidada se usa el comando:</enunciado><A>TYPE tabla IS TABLE OF tipoTabla</A><B>TYPE tipo IS TABLE OF Tabla</B><C>TYPE tipo AS OBJECT Tabla</C><D>CREATE TYPE tabla IS TABLE OF tipo AS OBJECT</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Para crear un subtipo Sociedad heredable del supertipo DatosGenerales se emplea el comando:</enunciado><A>CREATE TYPE tObjSociedad UNDER tObjDatosGEnerales AS (…) NOT FINAL;</A><B>CREATE TYPE tObjDatosGEnerales UNDER tObjSociedad AS (…) FINAL;</B><C>CREATE TYPE tObjDatosGEnerales UNDER tObjSociedad AS (…) NOT INSTANTIABLE;</C><D>CREATE TYPE tObjSociedad UNDER tObjDatosGEnerales AS (…) FINAL NOT INSTANTIABLE;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Para designar una columna de los registros que cumplen una condición en el WHERE se usa la palabra
            clave:</enunciado><A>REF</A><B>THE</B><C>SCOPE</C><D>DEREF</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>Para insertar la salida de una consulta en una variable se usa el comando:</enunciado><A>SELECT * FROM tabla INTO variable;</A><B>SELECT * FROM tabla INTO variable WHERE condicion;</B><C>SELECT variable INTO Tabla WHERE condicion;</C><D>SELECT * INTO variable FROM Tabla WHERE condicion;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>Dada la columna Empleado.fechaIngreso, ¿cómo se declararía y se reinicializaría una variable vFecha
            del mismo tipo y con el valor '20/04/2000'?</enunciado><A>vFecha Empleado.fechaIngreso%type:='20/04/2000';</A><B>Empleado.fechaIngreso vFecha%rowtype:='20/04/2000';</B><C>vFecha Empleado.fechaIngreso%date='20/04/2000';</C><D>vFecha fechaIngreso%row:='20/04/2000';</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué dos comandos se escribirían en un bloque PL/SQL para contar el número de Empleados y mostrar
            «Hay muchos» si hay más de 200?</enunciado><A>SELECT COUNT(*) FROM Empleado INTO vNumEmpl; IF vNumEmpl&gt;200 THEN PUT_LINE('Hay muchos'); END
                IF;</A><B>SELECT COUNT(*) INTO vNumEmpl FROM Empleado; IF vNumEmpl&gt;200 THEN DBMS_OUTPUT.PUT_LINE('Hay
                muchos'); END IF;</B><C>SELECT COUNT(*) FROM Empleado INTO vNumEmpl; IF Empleado.vNumEmpl&gt;200 THEN
                DBMS_OUTPUT.PUT_LINE('Hay muchos'); END IF;</C><D>SELECT COUNT(*) INTO Empleado.vNumEmpl FROM Empleado; IF Empleado.vNumEmpl&gt;200 THEN
                DBMS_OUTPUT.PUT_LINE('Hay muchos'); END IF;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué estructura repetitiva usarías para ejecutar, un número conocido de veces, un conjunto de
            comandos?</enunciado><A>Un bucle WHILE LOOP, LOOP EXIT WHEN o FOR IN LOOP indistintamente.</A><B>Solo con FOR IN LOOP.</B><C>Un bucle WHILE LOOP, LOOP EXIT WHEN o FOR IN LOOP, pero con FOR es más óptimo.</C><D>Solo con WHILE LOOP.</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>La declaración TYPE rEmpleado IS RECORD(dni NUMBER(8,0), Nombre VARCHAR2(30) NOT NULL) y la tabla
            Empleado con 20 registros:</enunciado><A>Permite declarar una variable del modo vEmpleado rEmpleado;</A><B>Permite hacer una consulta del tipo SELECT dni, Nombre INTO rEmpleado FROM Empleado WHERE
                dni=29388932;</B><C>Permite declarar una variable del tipo rEmpleado vEmpleado;</C><D>Permite hacer una consulta del tipo SELECT dni, Nombre INTO vEmpleado FROM Empleado;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>La declaración TYPE tEmpleado IS TABLE OF Empleado%ROWTYPE, vEmpleado tEmpleado y la tabla Empleado
            con 20 registros:</enunciado><A>Permite hacer una consulta del tipo SELECT dni, Nombre INTO vEmpleado FROM Empleado WHERE
                dni=29388932;</A><B>Permite hacer una consulta del tipo SELECT dni, Nombre INTO vEmpleado FROM Empleado WHERE
                Ciudad='Madrid';</B><C>Permite hacer una consulta del tipo SELECT count(dni) INTO vEmpleado FROM Empleado GROUP BY
                dni;</C><D>Permite hacer una consulta del tipo SELECT * INTO vEmpleado FROM Empleado WHERE
                Ciudad='Madrid';</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de los siguientes comandos con respecto al cursor cEmpleado no es correcto?</enunciado><A>CURSOR cEmpleado IS SELECT * FROM Empleado WHERE Ciudad='Madrid';</A><B>vrEmpleado Empleado%ROWTYPE;</B><C>FOR vrEmpleado IN cEmpleado LOOP</C><D>FOR cEmpleado IN vrEmpleado LOOP</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En relación a los disparadores, ¿qué comando está bien escrito?</enunciado><A>CREATE OR REPLACE TRIGGER BorraEmpl BEFORE INSERT DELETE Empleado ON EACH ROW</A><B>CREATE TRIGGER BorraEmpl AFTER INSERT Empleado ON EACH ROW</B><C>CREATE TRIGGER BorraEmpl BEFORE INSERT OR DELETE ON Empleado FOR EACH ROW</C><D>CREATE TRIGGER BorraEmpl BEFORE INSERT OR DELETE Empleado ON EACH ROW</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>Para la variable cadena='Hola mundo' y el procedimiento quitarVocales(cad IN OUT varchar2(255)), que
            elimina las vocales de la cadena:</enunciado><A>Al ejecutar los comandos en este orden, quitarVocales(cadena); cad='Hola'; el valor de cadena es
                ahora Hl.</A><B>Al ejecutar los comandos en este orden, cad='Hola'; quitarVocales(cadena); el valor de cadena es
                ahora Hl.</B><C>Al ejecutar los comandos en este orden, cad='Hola'; quitarVocales(cad); el valor de cadena es
                ahora Hl.</C><D>Al ejecutar los comandos en este orden, cad='Hola'; quitarVocales(cadena); el valor de cadena es
                ahora Hlmnd.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>En relación a las funciones, ¿cuál de las siguientes declaraciones es correcta?</enunciado><A>CREATE FUNCTION Formatear(IN cad VARCHAR2) RETURN VARCHAR2 IS</A><B>CREATE FUNCTION Formatear(cad VARCHAR2) RETURN VARCHAR2 IS</B><C>FUNCTION Formatear(cad) RETURN VARCHAR2 IS</C><D>CREATE OR REPLACE FUNCTION Formatear(IN cad VARCHAR2) RETURN VARCHAR2 IS</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué comando DDL se usa para eliminar una tabla de una base de datos?</enunciado><A>DROP TABLE</A><B>DELETE TABLE</B><C>REMOVE TABLE</C><D>ERASE TABLE</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de los siguientes comandos pertenece al DML?</enunciado><A>CREATE INDEX</A><B>TRUNCATE TABLE</B><C>UPDATE</C><D>DROP</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia se utiliza para modificar la estructura de una tabla existente?</enunciado><A>MODIFY</A><B>ALTER TABLE</B><C>CHANGE TABLE</C><D>REDEFINE</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué comando DDL se usa para crear un índice?</enunciado><A>MAKE INDEX</A><B>CREATE INDEX</B><C>NEW INDEX</C><D>INIT INDEX</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la diferencia principal entre DELETE y TRUNCATE?</enunciado><A>DELETE es más rápido</A><B>TRUNCATE permite WHERE</B><C>TRUNCATE borra todo sin registrar en log</C><D>DELETE borra todo sin posibilidad de rollback</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia se usa para insertar datos en una tabla?</enunciado><A>APPEND</A><B>ADD</B><C>INSERT INTO</C><D>SAVE INTO</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué hace la sentencia COMMIT en SQL?</enunciado><A>Guarda los cambios permanentemente</A><B>Deshace los cambios</B><C>Cierra la sesión</C><D>Finaliza la transacción sin guardar</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué comando permite cambiar el nombre de una tabla?</enunciado><A>MODIFY TABLE</A><B>CHANGE NAME</B><C>RENAME</C><D>ALTER RENAME</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de los siguientes comandos borra permanentemente una base de datos completa?</enunciado><A>REMOVE DATABASE</A><B>DELETE DATABASE</B><C>ERASE DATABASE</C><D>DROP DATABASE</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia es utilizada para cambiar el valor de una fila específica?</enunciado><A>CHANGE</A><B>EDIT</B><C>UPDATE</C><D>MODIFY VALUE</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué comando se utiliza para consultar información de una base de datos?</enunciado><A>SELECT</A><B>FETCH</B><C>QUERY</C><D>GET</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué significa SQL?</enunciado><A>Standard Query Language</A><B>Structured Question Language</B><C>Structured Query Language</C><D>Simple Query Logic</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué tipo de JOIN devuelve todas las filas cuando hay coincidencia en una de las tablas?</enunciado><A>INNER JOIN</A><B>LEFT JOIN</B><C>FULL JOIN</C><D>RIGHT JOIN</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el propósito de una clave primaria en una tabla?</enunciado><A>Almacenar contraseñas</A><B>Relacionar con otra tabla</B><C>Identificar filas de forma única</C><D>Validar los datos insertados</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál comando se usa para eliminar todos los registros de una tabla sin borrar la estructura?</enunciado><A>DELETE</A><B>DROP</B><C>REMOVE</C><D>TRUNCATE</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué operador se utiliza para buscar un valor dentro de un rango?</enunciado><A>BETWEEN</A><B>WITHIN</B><C>IN RANGE</C><D>INSIDE</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál sentencia se usa para combinar resultados de dos consultas?</enunciado><A>JOIN</A><B>UNION</B><C>MERGE</C><D>COMBINE</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué palabra clave se usa para ordenar los resultados de una consulta?</enunciado><A>SORT BY</A><B>ORDER</B><C>ARRANGE BY</C><D>ORDER BY</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué comando se usa para dar permisos a un usuario en SQL?</enunciado><A>PERMIT</A><B>GRANT</B><C>ALLOW</C><D>AUTHORIZE</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es el propósito del comando HAVING en SQL?</enunciado><A>Filtrar resultados después de agruparlos</A><B>Definir condiciones para INSERT</B><C>Filtrar filas antes de agrupar</C><D>Actualizar datos</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia elimina la columna 'foto' de la tabla 'grupos'?</enunciado><A>ALTER TABLE grupos DROP COLUMN foto;</A><B>DELETE COLUMN foto FROM grupos;</B><C>REMOVE foto FROM grupos;</C><D>DROP foto FROM grupos;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia elimina la columna 'portada' de la tabla 'albumes'?</enunciado><A>ALTER TABLE albumes DROP COLUMN portada;</A><B>DELETE portada FROM albumes;</B><C>REMOVE portada FROM albumes;</C><D>DROP portada FROM albumes;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia INSERT sería correcta para añadir el grupo U2?</enunciado><A>INSERT INTO grupos VALUES (1, 'U2', 'Irlandesa', 'U2 es una banda de rock originaria de Dublín
                (Irlanda) formada en 1976.');</A><B>INSERT INTO grupos (nombre, nacionalidad, biografía) VALUES ('U2', 'Irlandesa', 'U2 es una
                banda...');</B><C>INSERT INTO grupos (cod_grupo, nombre, nacionalidad, biografía) VALUES ('U2', 'Irlandesa', '...');</C><D>INSERT INTO grupos (cod_grupo, nombre, nacionalidad, biografía) VALUES (1, 'U2', 'Irlandesa', 'U2 es
                una banda de rock originaria de Dublín (Irlanda) formada en 1976.');</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál sería una sentencia válida para insertar el álbum 'The Joshua Tree' de U2 con cod_album 1 y
            cod_grupo 1?</enunciado><A>INSERT INTO albumes VALUES (1, 'The Joshua Tree', 1987, 1);</A><B>INSERT INTO albumes (cod_album, titulo, fecha, cod_grupo) VALUES (1, 'The Joshua Tree', 1987, 1);</B><C>ADD INTO albumes (1, 'The Joshua Tree', 1987, 1);</C><D>INSERT INTO albumes ('The Joshua Tree', 1987, 1);</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia INSERT agrega la canción 'Where the Streets Have No Name' al álbum 1?</enunciado><A>INSERT INTO canciones VALUES (1, 'Where the Streets Have No Name', '00:05:38', 1, 1);</A><B>INSERT INTO canciones (cod_cancion, titulo, duracion, num_pista, cod_album) VALUES (1, 'Where the
                Streets Have No Name', '00:05:38', 1, 1);</B><C>INSERT canción INTO canciones VALUES (1, 'Where...', '00:05:38', 1, 1);</C><D>ADD INTO canciones VALUES (1, 'Where...', '00:05:38', 1, 1);</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia SQL lista todos los grupos estadounidenses?</enunciado><A>SELECT * FROM grupos WHERE nacionalidad = 'Estadounidense';</A><B>SELECT nombre FROM grupos WHERE nacionalidad = 'EEUU';</B><C>SELECT nacionalidad FROM grupos WHERE nacionalidad LIKE '%USA%';</C><D>SELECT * FROM grupos WHERE pais = 'Estados Unidos';</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia muestra los álbumes publicados entre 1980 y 1990?</enunciado><A>SELECT * FROM albumes WHERE fecha BETWEEN 1980 AND 1990;</A><B>SELECT * FROM albumes WHERE fecha &gt;= 1980 AND fecha&gt;= 1990;</B><C>SELECT titulo FROM albumes WHERE fecha BETWEEN 1980 AND 1990;</C><D>Todas las anteriores son correctas.</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia muestra los grupos italianos con álbumes entre 1980 y 1990?</enunciado><A>SELECT * FROM grupos g JOIN albumes a ON g.cod_grupo = a.cod_grupo WHERE g.nacionalidad = 'Italiana'
                AND a.fecha BETWEEN 1980 AND 1990;</A><B>SELECT nombre FROM grupos WHERE nacionalidad = 'Italiana';</B><C>SELECT * FROM albumes WHERE fecha BETWEEN 1980 AND 1990;</C><D>SELECT * FROM grupos WHERE nacionalidad = 'Italiana' AND fecha BETWEEN 1980 AND 1990;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia muestra un listado de álbumes con sus géneros?</enunciado><A>SELECT a.titulo, g.nombre FROM albumes a JOIN generos g ON a.cod_genero = g.cod_genero;</A><B>SELECT * FROM generos;</B><C>SELECT * FROM albumes;</C><D>SELECT titulo FROM albumes WHERE genero IS NOT NULL;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo sabrías cuántos grupos hay por nacionalidad?</enunciado><A>SELECT nacionalidad, COUNT(*) FROM grupos GROUP BY nacionalidad;</A><B>SELECT COUNT(*) FROM grupos;</B><C>SELECT * FROM grupos GROUP BY nacionalidad;</C><D>SELECT nacionalidad FROM grupos GROUP BY nacionalidad;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción SQL crea una tabla llamada 'Empleado'?</enunciado><A>ADD TABLE Empleado (id INT, nombre VARCHAR(100));</A><B>NEW TABLE Empleado (id INT, nombre VARCHAR(100));</B><C>ALTER TABLE Empleado ADD COLUMN (id INT, nombre VARCHAR(100));</C><D>CREATE TABLE Empleado (id INT, nombre VARCHAR(100));</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál es la manera correcta de añadir una columna a una tabla existente usando SQL?</enunciado><A>CREATE TABLE Empleado ADD edad INT;</A><B>ALTER TABLE Empleado ADD COLUMN edad INT;</B><C>ADD COLUMN edad INT IN Empleado;</C><D>UPDATE TABLE Empleado ADD edad INT;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué cláusula indica que una columna no puede tener valores repetidos?</enunciado><A>PRIMARY KEY</A><B>CHECK</B><C>UNIQUE</C><D>DEFAULT</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál opción permite establecer automáticamente valores numéricos incrementales en una columna?</enunciado><A>AUTONUMBER</A><B>AUTOINCREMENTAL</B><C>AUTO_INCREMENT</C><D>AUTO_NUM</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cómo definirías una columna con valores por defecto usando SQL?</enunciado><A>Telefono VARCHAR(15) AUTO 'Desconocido'</A><B>Telefono VARCHAR(15) SET 'Desconocido'</B><C>Telefono VARCHAR(15) DEFAULT 'Desconocido'</C><D>Telefono VARCHAR(15) VALUE 'Desconocido'</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción SQL eliminaría la columna 'Telefono' de la tabla 'Empleado'?</enunciado><A>ALTER TABLE Empleado DROP COLUMN Telefono;</A><B>ALTER TABLE Empleado REMOVE Telefono;</B><C>ALTER TABLE Empleado DELETE COLUMN Telefono;</C><D>DROP COLUMN Telefono FROM Empleado;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué restricción asegura que una columna nunca contenga valores nulos?</enunciado><A>DEFAULT</A><B>NOT NULL</B><C>CHECK</C><D>UNIQUE</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de estas instrucciones crea correctamente una clave primaria compuesta en SQL?</enunciado><A>PRIMARY(id_empleado, id_proyecto)</A><B>SET PRIMARY KEY(id_empleado, id_proyecto)</B><C>PRIMARY KEY(id_empleado, id_proyecto)</C><D>PRIMARY KEY COMPOSED(id_empleado, id_proyecto)</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia SQL modificaría el tipo de dato de la columna 'salario' a DECIMAL(12,2)?</enunciado><A>ALTER TABLE empleados MODIFY COLUMN salario DECIMAL(12,2);</A><B>ALTER TABLE empleados UPDATE salario DECIMAL(12,2);</B><C>ALTER salario COLUMN DECIMAL(12,2);</C><D>CHANGE COLUMN salario DECIMAL(12,2);</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál de las siguientes instrucciones SQL añade una restricción UNIQUE sobre la columna 'Email'?</enunciado><A>ALTER TABLE empleados ADD CONSTRAINT UNIQUE (Email);</A><B>ALTER TABLE empleados ADD COLUMN UNIQUE Email;</B><C>ALTER empleados TABLE UNIQUE Email;</C><D>SET UNIQUE Email ON empleados;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta devuelve todos los empleados ordenados por salario descendente?</enunciado><A>SELECT * FROM empleados ORDER salario DESC;</A><B>SELECT salario DESC FROM empleados;</B><C>SELECT * FROM empleados SORT salario DESC;</C><D>SELECT * FROM empleados ORDER BY salario DESC;</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué función SQL usarías para contar el número total de empleados en una tabla?</enunciado><A>COUNT()</A><B>TOTAL()</B><C>SUM()</C><D>AVG()</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta calcula el salario promedio de todos los empleados?</enunciado><A>SELECT SUM(salario) FROM empleados;</A><B>SELECT AVG(salario) FROM empleados;</B><C>SELECT TOTAL(salario) FROM empleados;</C><D>SELECT COUNT(salario) FROM empleados;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué sentencia SQL devuelve cuántos empleados hay por cada departamento?</enunciado><A>SELECT departamento, COUNT(*) FROM empleados GROUP BY departamento;</A><B>SELECT departamento, SUM(*) FROM empleados;</B><C>SELECT departamento, COUNT(*) FROM empleados GROUP BY salario;</C><D>SELECT departamento, COUNT(*) FROM empleados ORDER BY departamento;</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué instrucción SQL devuelve todos los empleados cuyo salario es superior a 3000?</enunciado><A>SELECT nombre FROM empleados HAVING salario &gt; 3000;</A><B>SELECT nombre FROM empleados SALARIO &gt; 3000;</B><C>SELECT nombre FROM empleados ORDER BY salario &gt; 3000;</C><D>SELECT nombre FROM empleados WHERE salario &gt; 3000;</D><respuesta_correcta>D</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué consulta devuelve los empleados que tienen un salario superior al salario promedio general de la
            empresa?</enunciado><A>SELECT nombre FROM empleados WHERE salario &gt; AVG(salario);</A><B>SELECT nombre FROM empleados HAVING salario &gt; AVG(salario);</B><C>SELECT nombre FROM empleados WHERE salario &gt; (SELECT AVG(salario) FROM empleados);</C><D>SELECT AVG(salario) FROM empleados WHERE salario &gt; promedio;</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué cláusula se utiliza para filtrar resultados agrupados por condiciones específicas?</enunciado><A>HAVING</A><B>GROUP BY</B><C>ORDER BY</C><D>WHERE</D><respuesta_correcta>A</respuesta_correcta></pregunta><pregunta><enunciado>¿Qué consulta obtiene los departamentos cuyo salario promedio supera los 4000 euros?</enunciado><A>SELECT departamento FROM empleados WHERE AVG(salario) &gt; 4000;</A><B>SELECT departamento, AVG(salario) FROM empleados;</B><C>SELECT departamento FROM empleados GROUP BY departamento HAVING AVG(salario) &gt; 4000;</C><D>SELECT departamento FROM empleados GROUP BY departamento WHERE AVG(salario) &gt; 4000;</D><respuesta_correcta>C</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta obtiene los empleados junto con sus departamentos (todos tienen departamento)?</enunciado><A>SELECT empleados.nombre, departamentos.nombre FROM empleados RIGHT JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</A><B>SELECT empleados.nombre, departamentos.nombre FROM empleados JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</B><C>SELECT empleados.nombre, departamentos.nombre FROM empleados OUTER JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</C><D>SELECT empleados.nombre, departamentos.nombre FROM empleados LEFT JOIN departamentos ON
                empleados.id_departamento = departamentos.id_departamento;</D><respuesta_correcta>B</respuesta_correcta></pregunta><pregunta><enunciado>¿Cuál consulta obtiene los empleados que NO están asignados a ningún proyecto?</enunciado><A>SELECT empleados.nombre FROM empleados JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado WHERE asignaciones.id_empleado IS NULL;</A><B>SELECT empleados.nombre FROM empleados LEFT JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado WHERE asignaciones.id_empleado IS NULL;</B><C>SELECT empleados.nombre FROM empleados JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado;</C><D>SELECT empleados.nombre FROM empleados RIGHT JOIN asignaciones ON empleados.id_empleado =
                asignaciones.id_empleado;</D><respuesta_correcta>B</respuesta_correcta></pregunta></documento>